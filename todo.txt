> lambda bound vars to not appear in free_vars
> lambda - dx (x) in varfunc, when calling reduce make the generated shift a 'keep'

> \sum, \lim accept only body of paren if paren follows directly

> allow N**2 y?
> N -N x -> N (-N (x))

> diff of multivar function displayed as partial (this depends on changing location of sxlat limit, sum, intg, .limit, etc... so that free_vars can work better)

> ast2tex/nat intg to wrap exprs with potential differentials?
> ast2tex/nat \int dx * dx dx

> x aa**2 missing space
> "d / 2" is "(d) / 2", fix it

> CREATE SYMPY OBJECTS FOR PYTHON OBJECTS IN SYM?!?

> redo _expr_diff "a d/dx b"? - * Differentiation now has higher precedence than implicit multiplication ahead of it: "a d/dx b" -> "a * d/dx (b)", "\int a dx d / dx b"
> change AST._free_vars in sym to try to use ast2spt().free_symbols without .doit() and fall back to AST function if that fails


> \operatorname ufuncs from sympy latex
> ufuncs absorb identical variables f(x)(x) -> f(x)
> option to convert diffs of undefined functions assigned to variables back to to df/dx instead of d/dx f(x)
> ufuncs do not stay explicit in vars tab, make explicit when copying?

> remove keep from lalr1

> test_sym cases - call derivative of lambda

> ?x0(t) -> ?x(t)(0), ?x0(t)' -> ?x(t)'(0) from dsolve
> \. F(xi_0) |_{x_i0 = 2x - 3y} F(xi_0) (x_i0 = 2x - 3y) from pdsolve and the parsing
> keep track of what undefined functions are created during processing?

> overhaul server env option command line setting

> overhaul = and == to try to minimize where == is needed for display


> subs autocomplete

> scan grammar and add PopConfs where appropriate
> analyze which reductions are stored as conflicts most


> subs clarity parentheses for tex display like d/dx (f), attr, etc...?
> (a or b) or (a and b) - result parenthesizing for clarity
> 1 + (lambda y: y) vs. 1 + lambda y: y - parenthesis issue for clarity
> @ and % without parentheses consistency?
> \sum and \lim parens for clarity
> clean up safety parens from grammar tail element overhaul
> clean up sym lambda keyword safety wrapping

> "__" subscript shortcut with rules like "**"?


> doc: change to binding priority - sin**f(x) - sin**a.b(x) - sin**a.b{x}
> doc: new integration behavior
> doc: can call derivative of lambda
> doc: give anonymous ufuncs name of var on assignment to var
> doc: removed $ function escape character
> doc: ast2spt calls even though they look like multiplies
> doc: ufuncs
> doc: parentheses create implicit undefined functions
> doc: new functionality of @ and %
> doc: lowercase functions limit, integrate, etc... always execute
> doc: lambda function execution and binding
> doc: ODEs
> doc: PDEs


> test_sym - test parsing sympy latex

> allow funcs as vars for like symbols (..., cls = Functions)?


> Boolean .could_extract_minus_sign() for calculations

> relocate error hint text in web client to input area
> improve error reporting with position of error returned from reduction functions if possible lalr1.Syntax (text, pos)
> syntax error of diffp of multivar ufunc in sparser?
> more informative syntax errors from ics functions

> test_sym check for VarNulls and reject expression if detected
> add slice() to test_sym
> add back "forbidden" functions to test_sym (reject NullVars sxlats)? - remove or reject null vars after
> CENSORED variables problem with matches


> again redo spt2ast_Add?
> _spt2ast_Mul - option to not absorb fraction into non-fraction

> parse from python ln x / ln base -> \log_{base} x? only for number bases?

> patch dsolve to do: dsolve (y'' + 11 y' + 24 y, y (0) = 0, y'(0) = -7)?

> double check all _ast2? (AST (...)) for parent issues

> not keyword precedence
> More Examples: Parentheses (unnecessary)

> test_server multi maths from semicolon expressions


> \log loggamma=2 py representation? also sqrt? (use = instead of Eq due to function names as variables)
> proper sqrt and log AST initialization via __new__, slice, maybe others

> f (x) = x**2; f (x)

> quick mode function name characters allow to follow immediately?
> allow log_base without the \?
> sum_{start <= x < stop} -> \sum_{x = start}^{stop - 1}?
> do not write out parentheses for integration where not needed - \int {d / dx (x**2)} dx -> \int d / dx (x**2) dx?

> xlat py f = Lambda (x, x**2) -> f (x) = x**2?

> make test_sym friendlier to quick mode
> verify all is_var -> is_var_nonconst where consts not allowed
> worry about invalid varnames (reserved function names) or leave as convenience?
> SymPy function aliases as vars? "D = Derivative"?

> make semicolon separated plots work

> overhaul function call keyword arguments: expr -> ('kw', expr)?
> overhaul lambda AST variable storage: ('@', 'var') -> 'var'?

> ast2spt mul remove callable?

> allow leading underscore for vars and funcs and leading \_ for tex?
> clean up sparser TOKENS and centralize repeated patterns

> evil extra spacing before single-quote strings!
> # comment end of line?

> importing modules to allow custom code execution
> module and function asts?

> better plotting limits specification

> test_python module

> vector calculus
> nabla - gradient, laplacian
> Proper implementation of vectors with "\vec{x}" and "\hat{i}" variables?

> random server port selection / fallback
> ProductSet?
> ImageSet?

> formatting: no spacing for nums - 3 x -> 3x?
> formatting: quick mode no spacing for vars x y z -> xyz?
> formatting: non-quick mode explicit tex spacing for vars x y -> x\ y?

> SYM.PY REFACTOR!

> make sympad importable?

> Custom Contains and other set operation fallbacks to allow symbols to stand in for sets?
> 1 in x and other sets to accept symbols, how?
> plots as objects?
> flush sys.stdout to msg before sending exception?
> xlat different types and initializations of matrices?
> long variable name shortcut in quick mode? $? @?
> rewrite sqrt during autocomplete to show radix?

> floor / ceiling

> break out state machine from server

> server send back AST from validaiton to facilitate evaluation?

> sequence (factorial (k), (k, 1, oo)) (ellipsis)
> ImageSet (Lambda (n, 2 n pi + pi / 2), Integers)

> more graphical plots
> numpy support


Slow parse:
-----------

This is slow due to abuse of regex!
13.4375s: \left.-\emptyset**False/"s"'\right|_{\substack{\.lambdax,y,z:0*y1*dz|_{b^munotinlambda:y1notin\fracPix0notin[[False,-1.217383816320693e-12,a]]={{:w_{1}}:((a)),((oo,1e+100)):\sum_{x=False}^\pix0,{\partial:1.5165219116286896e-05}:\{w_{1},\xi,-.1}},\{((Complexes)),$nvQUW(real=True,commutative=True)}={},\frac\{y1,1310759352132.995}\left.\partialx\right|_{-1.0=2}=\partialx!andy1\cdot\partialxandnotw_{1}}={{{8.752331030243382e+16,oo}}}*:\left.1.0\right|_{True=False}>=sqrt_mod_iter(1e100)lnpartialx/Lambda_{63}oraor\xi}}


Errors:
-------


print ('\n'.join (str (s) for s in confs + stack + [rule, pos]))
(-105, 1, 1, 62, ['VAR', 'DIVIDE', 'VAR', 'PARENL', 'VAR', 'PARENR', 'PARENL', 'NUM', 'PARENR', '$end'], [(0, None, 0), (62, expr_div, 0, ('@', 'd'))], ([], True, None, False))
(-153, 9, 6, 23, ['VAR', 'DIVIDE', 'VAR', 'PARENL', 'VAR', 'PARENR', 'PARENL', 'NUM', 'PARENR', '$end'], [(0, None, 0), (62, expr_div, 0, ('@', 'd')), (150, DIVIDE, 1), (23, expr_ufunc, 2, ('-ufunc', 'dx', (('@', 'f'),)))], ([], True, None, False))
(0, None, 0)
(62, expr_div, 0, ('@', 'd'))
(150, DIVIDE, 1)
(23, expr_ufunc, 2, ('-ufunc', 'dx', (('@', 'f'),)))
(110, expr_pcommas, 9, ('#', '3'))
('expr_ufunc_ics', ('expr_ufunc', 'expr_pcommas'))
2

print ('\n'.join (str (s) for s in confs + stack + [rule, pos]))
(-134, 1, 1, 81, ['VAR', 'DBLSTAR', 'NUM', 'DIVIDE', 'VAR', 'VAR', 'PARENL', 'VAR', 'PARENR', 'PARENL', 'NUM', 'PARENR', '$end'], [(0, None, 0), (81, expr_diffp_ics, 0, ('@', 'd'))], ([], True, None, False))
(-105, 5, 3, 62, ['VAR', 'DBLSTAR', 'NUM', 'DIVIDE', 'VAR', 'VAR', 'PARENL', 'VAR', 'PARENR', 'PARENL', 'NUM', 'PARENR', '$end'], [(0, None, 0), (62, expr_div, 0, ('^', ('@', 'd'), ('#', '2')))], ([], True, None, False))
(-142, 10, 5, 27, ['VAR', 'DBLSTAR', 'NUM', 'DIVIDE', 'VAR', 'VAR', 'PARENL', 'VAR', 'PARENR', 'PARENL', 'NUM', 'PARENR', '$end'], [(0, None, 0), (62, expr_div, 0, ('^', ('@', 'd'), ('#', '2'))), (150, DIVIDE, 5), (27, expr_var, 7, ('@', 'dy'))], ([], True, None, False))
(-153, 17, 9, 23, ['VAR', 'DBLSTAR', 'NUM', 'DIVIDE', 'VAR', 'VAR', 'PARENL', 'VAR', 'PARENR', 'PARENL', 'NUM', 'PARENR', '$end'], [(0, None, 0), (62, expr_div, 0, ('^', ('@', 'd'), ('#', '2'))), (150, DIVIDE, 5), (27, expr_var, 7, ('@', 'dy')), (23, expr_ufunc, 10, ('-ufunc', 'dx', (('@', 'f'),)))], ([], True, None, False))
(0, None, 0)
(62, expr_div, 0, ('^', ('@', 'd'), ('#', '2')))
(150, DIVIDE, 5)
(27, expr_var, 7, ('@', 'dy'))
(23, expr_ufunc, 10, ('-ufunc', 'dx', (('@', 'f'),)))
(110, expr_pcommas, 17, ('#', '3'))
('expr_ufunc_ics', ('expr_ufunc', 'expr_pcommas'))
10
