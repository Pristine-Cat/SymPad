#!/usr/bin/env python
# python 3.6+

# THIS SCRIPT WAS AUTOGENERATED FROM SOURCE FILES FOUND AT:
# https://github.com/Pristine-Cat/SymPad

# Copyright (c) 2019 Tomasz Pytel
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

_RUNNING_AS_SINGLE_SCRIPT = True

import sys
sys.path.insert (0, '') # allow importing from current directory first (for SymPy development version)

_FILES = {

	'style.css': # style.css

r"""* {
	box-sizing: border-box;
	margin: 0;
	padding: 0;
}

body {
	margin-top: 1em;
	margin-bottom: 6em;
	cursor: default;
}

#Clipboard {
	position: fixed;
	bottom: 0;
	color: transparent;
	border: 0px;
}

#Background {
	position: fixed;
	z-index: -1;
	left: 0;
	top: 0;
}

#Greeting {
	position: fixed;
	left: 50%;
	top: 50%;
	transform: translate(-50%, -50%);
	color: #0007;
}

.GreetingA {
	display: block;
	color: #0007;
	text-decoration: none;
	margin-bottom: 0.5em;
}

#InputBG {
	position: fixed;
	z-index: 2;
	height: 4em;
	bottom: 0;
	left: 0;
	right: 0;
	background-color: #0000;
}

#InputBGLeft {
	position: fixed;
	z-index: 5;
	height: 4em;
	bottom: 0;
	left: 0;
	background-color: #0000;
}

#InputBGRight {
	position: fixed;
	z-index: 5;
	height: 4em;
	bottom: 0;
	right: 0;
	background-color: #0000;
}

#Input {
	position: fixed;
	z-index: 3;
	bottom: 2em;
	left: 4em;
	right: 1em;
	border-color: transparent;
	outline-color: transparent;
	background-color: transparent;
}

#InputOverlay {
	z-index: 4;
	pointer-events: none;
}

#OverlayGood {
	white-space: pre;
	-webkit-text-fill-color: transparent;
}

#OverlayError {
	position: absolute;
	white-space: pre;
	-webkit-text-fill-color: #f44;
}

#OverlayAutocomplete {
	position: absolute;
	white-space: pre;
	-webkit-text-fill-color: #999;
}

.LogEntry {
	width: 100%;
	margin-bottom: 1.5em;
}

.LogMargin {
	display: inline-block;
	height: 100%;
	width: 4em;
	vertical-align: top;
	text-align: right;
	padding-right: 0.5em;
}

.LogBody {
	display: inline-block;
	margin-right: -9999em;
}

.LogWait {
	vertical-align: top;
}

.LogInput {
	margin-bottom: 0.75em;
	width: fit-content;
	cursor: pointer;
}

.LogEval {
	position: relative;
	margin-bottom: 0.25em;
	cursor: pointer;
}

.LogMsg {
	margin-bottom: 0.25em;
}

.LogError {
	margin-bottom: 0.25em;
	color: red;
}

.LogErrorTriange {
	position: absolute;
	left: -1.25em;
	top: 0.25em;
	font-size: 0.7em;
	color: red;
	font-weight: bold;
}
""".encode ("utf8"),

	'script.js': # script.js

r"""// TODO: Change how left/right arrows interact with autocomplete.
// TODO: Stupid scrollbars...
// TODO: Change input to text field for longer expression support?
// TODO: Arrow keys in Edge?
// TODO: clear() function to delete old log items?

URL              = '/';
MJQueue          = null;
MarginTop        = Infinity;
PreventFocusOut  = true;

LogIdx           = 0;
UniqueID         = 1;

Validations      = [undefined];
Evaluations      = [undefined];
ErrorIdx         = null;
Autocomplete     = [];

LastClickTime    = 0;
NumClicks        = 0;

GreetingFadedOut = false;

// replaced in env.js
History          = [];
HistIdx          = 0;
Version          = 'None'
DisplayStyle     = 1

//...............................................................................................
function generateBG () {
	function writeRandomData (data, x0, y0, width, height) {
		let p, d;

		for (let y = y0; y < height; y ++) {
			p = (width * y + x0) * 4;

			for (let x = x0; x < width; x ++) {
				d            = 244 + Math.floor (Math.random () * 12);
				data [p]     = data [p + 1] = d;
				data [p + 2] = d - 8;
				data [p + 3] = 255;
				p            = p + 4;
			}
		}
	}

	let canv    = document.getElementById ('Background');
	canv.width  = window.innerWidth;
	canv.height = window.innerHeight;
	let ctx     = canv.getContext ('2d');
	let imgd    = ctx.getImageData (0, 0, canv.width, canv.height); // ctx.createImageData (width, height);

	writeRandomData (imgd.data, 0, 0, canv.width, canv.height);
	ctx.putImageData (imgd, 0, 0);

	if (window.location.pathname == '/') {
		for (let name of ['#InputBG', '#InputBGLeft', '#InputBGRight']) {
			canv        = $(name) [0];
			ctx         = canv.getContext ('2d');
			canv.width  = window.innerWidth;

			ctx.putImageData (imgd, 0, 0);
		}
	}
}

//...............................................................................................
function copyInputStyle () {
	let left = $('#LogEntry1').position ().left;

	JQInput.css ({left: left})
	JQInput.width (window.innerWidth - left - 32);
	$('#InputBGLeft').width (left);
	$('#InputBGRight').css ({left: window.innerWidth - 30});

	let style   = getComputedStyle (document.getElementById ('Input'));
	let overlay = document.getElementById ('InputOverlay');

  for (let prop of style) {
    overlay.style [prop] = style [prop];
	}

	overlay.style ['z-index']        = 4;
	overlay.style ['pointer-events'] = 'none';
}

//...............................................................................................
function scrollToEnd () {
	window.scrollTo (0, document.body.scrollHeight);
}

//...............................................................................................
function resize () {
	copyInputStyle ();
	scrollToEnd ();
	generateBG ();
}

//...............................................................................................
function logResize () {
	// let atEnd  = !(document.documentElement.offsetHeight - document.documentElement.scrollTop - window.innerHeight);
	let margin = Math.max (BodyMarginTop, Math.floor (window.innerHeight - $('body').height () - BodyMarginBottom + 3)); // +3 is fudge factor

	if (margin < MarginTop) {
		MarginTop = margin
		$('body').css ({'margin-top': margin});
	}

	// if (atEnd) {
	// 	scrollToEnd ();
	// }
}

//...............................................................................................
var LastDocHeight = undefined;
var LastWinHeight = undefined;

function monitorStuff () {
	let curDocHeight = $(document).height ();
	let curWinHeight = $(window).height ();

	if (curDocHeight != LastDocHeight || curWinHeight != LastWinHeight) {
		copyInputStyle ();

		window.LastDocHeight = curDocHeight;
		window.LastWinHeight = curWinHeight;
	}

	if (PreventFocusOut) {
		JQInput.focus ();
	}

	updateOverlayPosition ();
	setTimeout (monitorStuff, 50);
}

//...............................................................................................
function readyMathJax () {
	window.MJQueue = MathJax.Hub.queue;

	if (DisplayStyle) {
		var TEX        = MathJax.InputJax.TeX;
		var PREFILTER  = TEX.prefilterMath;

		TEX.Augment ({
			prefilterMath: function (tex, displaymode, script) {
				return PREFILTER.call (TEX, '\\displaystyle{' + tex + '}', displaymode, script);
			}
		});
	}
}

//...............................................................................................
function reprioritizeMJQueue () {
	let p = MJQueue.queue.pop ();

	if (p !== undefined) {
		MJQueue.queue.splice (0, 0, p);
	}
}

//...............................................................................................
function addLogEntry () {
	LogIdx += 1;

	$('#Log').append (`
			<div class="LogEntry"><div class="LogMargin">${LogIdx}.</div><div class="LogBody" id="LogEntry${LogIdx}"><div class="LogInput" id="LogInput${LogIdx}">
				<img class="LogWait" id="LogInputWait${LogIdx}" src="https://i.gifer.com/origin/3f/3face8da2a6c3dcd27cb4a1aaa32c926_w200.webp" width="16" style="visibility: hidden">
			</div></div></div>`)

	Validations.push (undefined);
	Evaluations.push (undefined);
}

//...............................................................................................
function writeToClipboard (text) {
	PreventFocusOut = false;

	$('#Clipboard').val (text);
	$('#Clipboard').focus ();
	$('#Clipboard').select ();
	document.execCommand ('copy');

	PreventFocusOut = true;

	JQInput.focus ();
}

//...............................................................................................
function copyToClipboard (e, val_or_eval, idx, subidx = 0) {
	let t = performance.now ();

	if ((t - LastClickTime) > 500) {
		NumClicks = 1;
	} else{
		NumClicks += 1;
	}

	LastClickTime = t;
	let resp      = val_or_eval ? Evaluations [idx].math [subidx] : Validations [idx];

	writeToClipboard (NumClicks == 1 ? resp.nat : NumClicks == 2 ? resp.py : resp.tex);

	e.style.color      = 'transparent';
	e.style.background = 'black';

	setTimeout (function () {
		e.style.color      = 'black';
		e.style.background = 'transparent';
	}, 100);
}

//...............................................................................................
function updateOverlayPosition () {
	let left       = -JQInput.scrollLeft ();
	let goodwidth  = $('#OverlayGood').width ();
	let errorwidth = $('#OverlayError').width ();

	$('#OverlayGood').css ({left: left})
	$('#OverlayError').css ({top: 0, left: left + goodwidth});
	$('#OverlayAutocomplete').css ({top: 0, left: left + goodwidth + errorwidth});
}

//...............................................................................................
function updateOverlay (text, erridx, autocomplete) {
	ErrorIdx     = erridx;
	Autocomplete = autocomplete;

	if (ErrorIdx === null) {
		$('#OverlayGood').text (text);
		$('#OverlayError').text ('');

	} else {
		$('#OverlayGood').text (text.substr (0, ErrorIdx));
		$('#OverlayError').text (text.substr (ErrorIdx));
	}

	$('#OverlayAutocomplete').text (Autocomplete.join (''));

	updateOverlayPosition ();
}

//...............................................................................................
function ajaxResponse (resp) {
	if (resp.mode == 'validate') {
		if (Validations [resp.idx] !== undefined && Validations [resp.idx].subidx >= resp.subidx) {
			return; // ignore out of order responses (which should never happen with single threaded server)
		}

		if (resp.tex !== null) {
			Validations [resp.idx] = resp;

			let eLogInput = document.getElementById ('LogInput' + resp.idx);

			let queue              = [];
			[queue, MJQueue.queue] = [MJQueue.queue, queue];

			MJQueue.queue = queue.filter (function (obj, idx, arr) { // remove previous pending updates to same element
				return obj.data [0].parentElement !== eLogInput;
			})

			let eLogInputWait              = document.getElementById ('LogInputWait' + resp.idx);
			eLogInputWait.style.visibility = '';

			let idMath = 'LogInputMath' + UniqueID ++;
			$(eLogInput).append (`<span id="${idMath}" onclick="copyToClipboard (this, 0, ${resp.idx})" style="visibility: hidden">$${resp.tex}$</span>`);
			let eMath  = document.getElementById (idMath);

			MJQueue.Push (['Typeset', MathJax.Hub, eMath, function () {
				if (eMath === eLogInput.children [eLogInput.children.length - 1]) {
					eLogInput.appendChild (eLogInputWait);

					for (let i = eLogInput.children.length - 3; i >= 0; i --) {
						eLogInput.removeChild (eLogInput.children [i]);
					}

					eLogInputWait.style.visibility = 'hidden';
					eMath.style.visibility         = '';

					logResize ();
					scrollToEnd (); // ???
				}
			}]);

			reprioritizeMJQueue ();
		}

		updateOverlay (JQInput.val (), resp.erridx, resp.autocomplete);

	} else { // resp.mode == 'evaluate'
		Evaluations [resp.idx] = resp;

		let eLogEval = document.getElementById ('LogEval' + resp.idx);

		eLogEval.removeChild (document.getElementById ('LogEvalWait' + resp.idx));

		if (resp.err !== undefined) { // error?
			if (resp.err.length > 1) {
				let idLogErrorHidden = 'LogErrorHidden' + resp.idx;
				$(eLogEval).append (`<div id="${idLogErrorHidden}" style="display: none"></div>`);
				var eLogErrorHidden  = document.getElementById (idLogErrorHidden);

				for (let i = 0; i < resp.err.length - 1; i ++) {
					$(eLogErrorHidden).append (`<div class="LogError">${resp.err [i].replace (/  /g, '&emsp;')}</div>`);
				}
			}

			let idLogErrorTriangle = 'LogErrorTriangle' + resp.idx;
			$(eLogEval).append (`<div class="LogError">${resp.err [resp.err.length - 1]}</div><div class="LogErrorTriange" id="LogErrorTriangle${resp.idx}">\u25b7</div>`);
			var eLogErrorTriangle  = document.getElementById (idLogErrorTriangle);

			$(eLogEval).click (function () {
				if (eLogErrorHidden.style.display === 'none') {
					eLogErrorHidden.style.display = 'block';
					eLogErrorTriangle.innerText   = '\u25bd';
				} else {
					eLogErrorHidden.style.display = 'none';
					eLogErrorTriangle.innerText   = '\u25b7';
				}

				logResize ();
			});

			logResize ();
			scrollToEnd ();

		} else { // no error
			if (resp.math !== undefined && resp.math.length) { // math results present?
				for (let subidx in resp.math) {
					let idLogEvalDiv  = `LogEvalDiv${resp.idx}_${subidx}`;
					let idLogEvalMath = `LogEvalMath${resp.idx}_${subidx}`;

					$(eLogEval).append (`<div id="${idLogEvalDiv}" class="LogEval"><span id="${idLogEvalMath}" style="visibility: hidden" onclick="copyToClipboard (this, 1, ${resp.idx}, ${subidx})">$${resp.math [subidx].tex}$</span>
							<img id="LogEvalWait${resp.idx}_${subidx}" class="LogWait" src="https://i.gifer.com/origin/3f/3face8da2a6c3dcd27cb4a1aaa32c926_w200.webp" width="16">
							</div>`);

					let eLogEvalDiv   = document.getElementById (idLogEvalDiv);
					let eLogEvalMath  = document.getElementById (idLogEvalMath);

					MJQueue.Push (['Typeset', MathJax.Hub, eLogEvalMath, function () {
						eLogEvalDiv.removeChild (document.getElementById (`LogEvalWait${resp.idx}_${subidx}`));

						eLogEvalMath.style.visibility = '';

						logResize ();
						scrollToEnd ();
					}]);

					reprioritizeMJQueue ();
				}
			}

			if (resp.img !== undefined) { // image present?
				$(eLogEval).append (`<div><img src='data:image/png;base64,${resp.img}'></div>`);

				setTimeout (function () { // image seems to take some time to register size even though it is directly present
					logResize ();
					scrollToEnd ();
				}, 0);
			}

			if (resp.msg !== undefined && resp.msg.length) { // message present?
				for (let msg of resp.msg) {
					$(eLogEval).append (`<div class="LogMsg">${msg.replace (/  /g, '&emsp;')}</div>`);
				}

				logResize ();
				scrollToEnd ();
			}
		}
	}
}

//...............................................................................................
function inputting (text, reset = false) {
	if (reset) {
		ErrorIdx     = null;
		Autocomplete = [];

		JQInput.val (text);
	}

	updateOverlay (text, ErrorIdx, Autocomplete);

	$.ajax ({
		url: URL,
		type: 'POST',
		cache: false,
		dataType: 'json',
		success: ajaxResponse,
		data: {
			mode: 'validate',
			idx: LogIdx,
			subidx: UniqueID ++,
			text: text,
		},
	});
}

//...............................................................................................
function inputted (text) {
	$.ajax ({
		url: URL,
		type: 'POST',
		cache: false,
		dataType: 'json',
		success: ajaxResponse,
		data: {
			mode: 'evaluate',
			idx: LogIdx,
			text: text,
		},
	});

	$('#LogEntry' + LogIdx).append (`
			<div class="LogEval" id="LogEval${LogIdx}">
				<img class="LogWait" id="LogEvalWait${LogIdx}" src="https://i.gifer.com/origin/3f/3face8da2a6c3dcd27cb4a1aaa32c926_w200.webp" width="16">
			</div>`);

	History.push (text);

	HistIdx = History.length;

	addLogEntry ();
	logResize ();
	scrollToEnd ();
}

//...............................................................................................
function inputKeypress (e) {
	if (e.which == 13) {
		s = JQInput.val ().trim ();

		if ((s && ErrorIdx === null) || s === '?') {
			if (!GreetingFadedOut) {
				GreetingFadedOut = true;
				$('#Greeting').fadeOut (3000);
			}

			if (s === 'help' || s === '?') {
				window.open (`${URL}help.html`);
				inputting ('', true);

				return false;
			}

			if (Autocomplete.length > 0) {
				s = s + Autocomplete.join ('');
				inputting (s);
			}

			JQInput.val ('');
			updateOverlay ('', null, []);
			inputted (s);

			return false;
		}

	} else if (e.which == 32) {
		if (!JQInput.val ()) {
			return false;
		}
	}

	return true;
}

//...............................................................................................
function inputKeydown (e) {
	if (e.code == 'Escape') {
		e.preventDefault ();

		if (JQInput.val ()) {
			HistIdx = History.length;
			inputting ('', true);

			return false;
		}

	} else if (e.code == 'Tab') {
		e.preventDefault ();
		$(this).focus ();

		return false;

	} else if (e.code == 'ArrowUp') {
		e.preventDefault ();

		if (HistIdx) {
			inputting (History [-- HistIdx], true);

			return false;
		}

	} else if (e.code == 'ArrowDown') {
		e.preventDefault ();

		if (HistIdx < History.length - 1) {
			inputting (History [++ HistIdx], true);

			return false;

		} else if (HistIdx != History.length) {
			HistIdx = History.length;
			inputting ('', true);

			return false;
		}

	} else if (e.code == 'ArrowRight') {
		if (JQInput.get (0).selectionStart === JQInput.val ().length && Autocomplete.length) {
			let text = JQInput.val ();

			// if ((Autocomplete [0] === ' \\right') || (Autocomplete [0] === '|')) {
			// 	text         = text + Autocomplete.slice (0, 2).join ('');
			// 	Autocomplete = Autocomplete.slice (2);

			// } else {
			// 	text         = text + Autocomplete [0];
			// 	Autocomplete = Autocomplete.slice (1);
			// }
			text         = text + Autocomplete [0];
			Autocomplete = Autocomplete.slice (1);

			JQInput.val (text);
			inputting (text);
			// updateOverlay (text, ErrorIdx, Autocomplete);
		}
	}

	setTimeout (updateOverlayPosition, 0);

	return true;
}

//...............................................................................................
// function inputFocusout (e) {
// 	if (PreventFocusOut) {
// 		e.preventDefault ();
// 		$(this).focus ();

// 		return false;
// 	}
// }

//...............................................................................................
$(function () {
	window.JQInput = $('#Input');

	if (window.location.pathname != '/') {
		generateBG ();
		return;
	}

	let margin       = $('body').css ('margin-top');
	BodyMarginTop    = Number (margin.slice (0, margin.length - 2));
	margin           = $('body').css ('margin-bottom');
	BodyMarginBottom = Number (margin.slice (0, margin.length - 2));

	$('#Clipboard').prop ('readonly', true);
	$('#InputBG') [0].height = $('#InputBG').height ();

	JQInput.keypress (inputKeypress);
	JQInput.keydown (inputKeydown);
	// JQInput.focusout (inputFocusout);
	// JQInput.blur (inputFocusout);

	addLogEntry ();
	logResize ();
	resize ();
	monitorStuff ();
});


// $('#txtSearch').blur(function (event) {
// 	setTimeout(function () { $("#txtSearch").focus(); }, 20);
// });

// document.getElementById('txtSearch').addEventListener('blur', e => {
//   e.target.focus();
// });

// cursor_test = function (element) {
// 	if (!element.children.length && element.innerText == '∥') {
// 		console.log (element, element.classList);
// 		element.innerText = '|';
// 		element.classList.add ('blinking');
// 	}

// 	for (let e of element.children) {
// 		cursor_test (e);
// 	}
// }

// cursor_test (eLogInput.children [0]);
""".encode ("utf8"),

	'index.html': # index.html

r"""<!DOCTYPE html>
<html>
<head>

<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link rel="icon" href="https://www.sympy.org/static/SymPy-Favicon.ico">
<title>SymPad</title>
<link rel="stylesheet" type="text/css" href="style.css">

<script type="text/javascript" src="https://code.jquery.com/jquery-3.4.1.js" integrity="sha256-WpOohJOqMqqyKL9FccASB9O0KwACQJpFTUBLTYOVvVU=" crossorigin="anonymous"></script>
<script type="text/javascript" src="script.js"></script>
<script type="text/javascript" src="env.js"></script>
<script type="text/x-mathjax-config">
	MathJax.Hub.Config ({
		messageStyle: "none",
		tex2jax: {inlineMath: [["$","$"], ["\\(","\\)"]]}
	});

	MathJax.Hub.Register.StartupHook ("End", readyMathJax);
</script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_CHTML-full"></script>

</head>

<body onresize="resize ()">

<input id="Clipboard">
<canvas id="Background"></canvas>

<div id="Greeting">
	<div align="center">
		<h2>SymPad</h2>
		<h5><script type="text/javascript">document.write (Version)</script></h5>
		<br><br>
		Type '<b>help</b>' or '<b>?</b>' at any time for more information.
		<br>
		- or -
		<br>
		Type or click any of the following to get started:
	</div>
	<br><br>
	<a class="GreetingA" href="javascript:inputting ('cos**-1 0 + \\log_2{8}', true)">cos**-1 0 + \log_2{8}</a>
	<a class="GreetingA" href="javascript:inputting ('expand ((1 + x)**4)', true)">expand ((1 + x)**4)</a>
	<a class="GreetingA" href="javascript:inputting ('factor (x**3 + 3 y x**2 + 3 x y**2 + y**3)', true)">factor (x**3 + 3 y x**2 + 3 x y**2 + y**3)</a>
	<a class="GreetingA" href="javascript:inputting ('series (e^x, x, 0, 5)', true)">series (e^x, x, 0, 5)</a>
	<a class="GreetingA" href="javascript:inputting ('solve (x**2 + y = 4, x)', true)">solve (x**2 + y = 4, x)</a>
	<a class="GreetingA" href="javascript:inputting ('\\lim_{x\\to\\infty} 1/x', true)">\lim_{x\to\infty} 1/x</a>
	<a class="GreetingA" href="javascript:inputting ('Limit (\\frac1x, x, 0, dir=\'-\')', true)">Limit (\frac1x, x, 0, dir='-')</a>
	<a class="GreetingA" href="javascript:inputting ('\\sum_{n=0}**oo x^n / n!', true)">\sum_{n=0}**oo x^n / n!</a>
	<a class="GreetingA" href="javascript:inputting ('Derivative (x**2y**2, x, y, 2)', true)">Derivative (x**2y**2, x, y, 2)</a>
	<a class="GreetingA" href="javascript:inputting ('d**6 / dx dy**2 dz**3 x^3 y^3 z^3', true)">d**6 / dx dy**2 dz**3 x^3 y^3 z^3</a>
	<a class="GreetingA" href="javascript:inputting ('Integral (e^{-x^2}, (x, 0, \\infty))', true)">Integral (e^{-x^2}, (x, 0, \infty))</a>
	<a class="GreetingA" href="javascript:inputting ('\\int_0^\\pi \\int_0^{2pi} \\int_0^1 rho**2 sin\\phi drho dtheta dphi', true)">\int_0^\pi \int_0^{2pi} \int_0^1 rho**2 sin\phi drho dtheta dphi</a>
	<a class="GreetingA" href="javascript:inputting ('\\[[1, 2], [3, 4]]**-1', true)">\[[1, 2], [3, 4]]**-1</a>
	<a class="GreetingA" href="javascript:inputting ('Matrix ([[1, 2, 3], [4, 5, 6]]) [:,1].transpose ()', true)">Matrix ([[1, 2, 3], [4, 5, 6]]) [:,1].transpose ()</a>
	<a class="GreetingA" href="javascript:inputting ('Matrix (4, 4, lambda r, c: c + r if c &gt; r else 0)', true)">Matrix (4, 4, lambda r, c: c + r if c &gt; r else 0)</a>
	<a class="GreetingA" href="javascript:inputting ('(({1, 2, 3} && {2, 3, 4}) ^^ {3, 4, 5}) - \\{4} || {7,}', true)">(({1, 2, 3} && {2, 3, 4}) ^^ {3, 4, 5}) - \{4} || {7,}</a>
	<a class="GreetingA" href="javascript:inputting ('plotf (2pi, -2, 2, sin x, \'r=sin\', cos x, \'g=cos\', tan x, \'b=tan\')', true)">plotf (2pi, -2, 2, sin x, 'r=sin', cos x, 'g=cos', tan x, 'b=tan')</a>

<!--
<a class="GreetingA" href="javascript:inputting ('
', true)">
</a>
 -->
	<br><br>
	<div align="center">
	Copyright (c) 2019 Tomasz Pytel. <a href="https://github.com/Pristine-Cat/SymPad" target="_blank" style="color: #0007">SymPad on GitHub</a>
	</div>
</div>

<div id="Log"></div>

<canvas id="InputBG"></canvas>
<canvas id="InputBGLeft"></canvas>
<canvas id="InputBGRight"></canvas>
<input id="Input" oninput="inputting (this.value)" autofocus>
<div id="InputOverlay"><span id="OverlayGood"></span><span id="OverlayError"></span><span id="OverlayAutocomplete"></span></div>

</body>
</html>""".encode ("utf8"),

	'help.html': # help.html

r"""<!DOCTYPE html>
<html>
<head>

<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<link rel="icon" href="https://www.sympy.org/static/SymPy-Favicon.ico">
<title>SymPad Help</title>
<link rel="stylesheet" type="text/css" href="style.css">

<style>
	body { margin: 3em 4em; }
	h2 { margin: 2em 0 1em 0; }
	h4 { margin: 1.5em 0 0.75em 0; }
	p { margin: 0 0 1.2em 1em; line-height: 150%; }
	i { color: #0008; }
	del { color: red; }
</style>

<script type="text/javascript" src="https://code.jquery.com/jquery-3.4.1.js" integrity="sha256-WpOohJOqMqqyKL9FccASB9O0KwACQJpFTUBLTYOVvVU=" crossorigin="anonymous"></script>
<script type="text/javascript" src="script.js"></script>
<script type="text/javascript" src="env.js"></script>
<script type="text/x-mathjax-config">
	MathJax.Hub.Config ({
		messageStyle: "none",
		tex2jax: {inlineMath: [["$","$"], ["\\(","\\)"]]}
	});
</script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_CHTML-full"></script>

</head>

<body onresize="generateBG ()">

<canvas id="Background"></canvas>

<h1 align="center" style="margin: 0">SymPad</h1>
<h4 align="center" style="margin: 0"><script type="text/javascript">document.write (Version)</script></h4>

<h2>Introduction</h2>

<p>
SymPad is a simple single script symbolic calculator / scratchpad using SymPy for the math and MathJax for the display in a browser.
It is a labor of love and grew out of a desire for an easy way to calculate a quick integral while studying some math without having to start a shell every time and import a package or fire up a browser and navigate to a site (technincally that last bit is exactly what happens but the response time is better :)
This desire for simplicity led to the single script option "sympad.py" which I could plop down on the desktop and execute when needed.
User input is intended to be quick, easy and intuitive and is displayed in symbolic form as it is being entered.
Sympad will accept Python expressions, LaTeX formatting, Unicode math symbols and a native shorthand intended for fast entry, or a mix of all of these.
The input will be evaluated symbolically or numerically with the results being copy/pasteable in Python or LaTeX formats, so it acts as a translator as well.
</p>

<h4>Quick Start</h4>

<p>
The best way to see what SymPad can do is by doing, so try entering any of the following into SymPad:
</p><p>
cos**-1 0 + \log_2{8}<br>
expand ((1 + x)**4)<br>
factor (x**3 + 3 y x**2 + 3 x y**2 + y**3)<br>
series (e^x, x, 0, 5)<br>
solve (x**2 + y = 4, x)<br>
\lim_{x\to\infty} 1/x<br>
Limit (\frac1x, x, 0, dir='-')<br>
\sum_{n=0}**oo x^n / n!<br>
Derivative (x**2y**2, x, y, 2)<br>
d**6 / dx dy**2 dz**3 x^3 y^3 z^3<br>
Integral (e^{-x^2}, (x, 0, \infty))<br>
\int_0^\pi \int_0^{2pi} \int_0^1 rho**2 sin\phi drho dtheta dphi<br>
\[[1, 2], [3, 4]]**-1<br>
Matrix ([[1, 2, 3], [4, 5, 6]]) [:,1].transpose ()<br>
Matrix (4, 4, lambda r, c: c + r if c &gt; r else 0)<br>
(({1, 2, 3} && {2, 3, 4}) ^^ {3, 4, 5}) - \{4} || {7,}<br>
plotf (2pi, -2, 2, sin x, 'r=sin', cos x, 'g=cos', tan x, 'b=tan')<br>
</p>

<h4>Multiline Examples</h4>

<p>
Enter the lines that follow one by one to see the effect:
</p><p>
1<br>
expand (_(x+1))<br>
expand (_(x+1))<i>&emsp;**(or press the up arrow)</i><br>
expand (_(x+1))<i>&emsp;...</i><br>
</p><p>
Or the following:
</p><p>
a, b = 1, 1<br>
a, b = b, a + b<br>
a, b = b, a + b<i>&emsp;**(or press the up arrow)</i><br>
a, b = b, a + b<i>&emsp;...</i><br>
</p><p>
Automatic variable substitution:
</p><p>
y = x**2 + 2x + 1<br>
y<br>
x = 2<br>
y<br>
del x<br>
y<br>
</p>

<p>
For more examples see the appendix.
</p>

<h4>Usage</h4>

<p>
You enter expresstions and they get evaluated.
The expressions may be in normal Pythonic style like "<b>a * (b + sin (x)**2 + 3/4) / 2</b>", LaTeX such as "<b>a\frac{b+\sin^2{x}+\frac34}{2}</b>" or a mix "<b>a * (b + \sin**2{x} + \frac34) / 2</b>".
The input is displayed symbolically as you type.
Input history is supported with the up and down arrows.
SymPad will give some limited options for autocompletion for certain expressions sometimes, this mostly means that you will not have to close parentheses.
</p><p>
The symbolic expressions can be copied to the clipboard in various formats.
Single-click for a simple native format meant to be pasted back into the input field.
A double click-copies the expression in Python format suitable for pasting into a Python shell or source file.
Finally, a triple-click will copy the expression in LaTeX format.
The single-click native and double-click Python formats should almost always be pasteable back into SymPad, whereas the LaTeX format may or may not be depending on what elements are present.
</p>

<h4>Quick Input Mode</h4>

<p>
This is the input mode SymPad was born in and still my preferred mode for quick calculations due to the ease and speed of input.
SymPad normally allows long variable names, requires spaces between them for implicit multiplication and enforces grammatical breaks between function names and variables.
This can be turned off by switching into quick input mode using the function "<b>env(quick)</b>" or by using the "<b>--quick</b>" option on the command line.
When in this mode long variable names are sacrificed for quicker input of single letter variables (Latin or Greek - with or without leading slash) and explicit space characters are no longer necessary between variables and recognized function names, though they are required AFTER function names.
This means that an expression entered in normal mode like this "<b>x y z sin w**2</b>" can be entered in quick mode like this "<b>xyzsin w**2</b>".
Note that a grammatical break is also still required AFTER text operators like "<b>if</b>", "<b>else</b>", "<b>in</b>", "<b>not in</b>", etc... otherwise they would make too many functions inaccessible by being recognized as part of a word.
For convenience certain multi-character variables are accepted in quick mode - Greek letters (including "<b>pi</b>"), "<b>oo</b>" for infinity and "<b>zoo</b>" for complex infinity, "<b>partial</b>", "<b>True</b>", "<b>False</b>" and "<b>None</b>".
</p>

<h2>Types</h2>

<h4>Numbers</h4>

<p>
Numbers take the standard integer or floating point form or exponential form such as 123, -2.567, 1e+100, 3E-45 or -1.521e22.
The precision for all SymPy Floats used in evaluation is set to the highest precision number present in the equation or referenced variables, so if you ask for the cosine of a number with 50 decimal digits your answer will have at least 50 decimal digits.
</p><p>
Keep in mind that "<b>e</b>" or "<b>E</b>" is the Euler"s number constant $e$ and if you are trying to enter 2 times $e$ plus 22 then do not write it all together as "<b>2e+22</b>" as this will be interpreted to be "<b>2 * 10^22</b>".
Instead, use spaces and/or explicit multiplication: "<b>2 * e + 22</b>".
Imaginary numbers are entered using the imaginary unit "<b>i</b>" or "<b>I</b>" depending on preference, no Pythonic "<b>j</b>" option at the moment but it can be hacked by setting "<b>j = i</b>" in SymPad.
</p>

<h4>Variables</h4>

<p>
Variable names can be a mix of Python and LaTeX format, they can be multi-character but cannot start with an underscore "<b>_</b>" or a number though they may contain those.
Standard identifiers are accepted as well as single Greek letters optionally preceded by a slash such as "<b>\alpha</b>" ($\alpha$), "<b>epsilon</b>" ($\epsilon$) or "<b>\Psi</b>" ($\Psi$).
The Greek letters recognized and rendered in ... Greek ... are only those normally present within LaTeX which can not be visually confused with Latin letters, those Greek letters are accepted in Unicode as well.
</p><p>
The variable names "<b>i</b>", "<b>e</b>" and "<b>\pi</b>" represent their respective mathematical constants $i$, $e$ and $\pi$.
"<b>pi</b>" and "<b>oo</b>" are also available for $\pi$ and $\infty$.
Python's "<b>None</b>", "<b>True</b>" and "<b>False</b>" are also present.
Variable names may be followed by various primes ' such as "<b> var' </b>" ($var'$) or "<b> \omega'' </b>" ($\omega''$).
By default, the lowercase "<b>e</b>" and "<b>i</b>" letters are used to represent Euler's number and the imaginary unit instead of the default SymPy uppercase "<b>E</b>" and "<b>I</b>".
This is objectively prettier, but can be changed via the "<b>env (EI)</b>" and "<b>env (noEI)</b>" function.
The SymPy constant usage can also be activated via the command line switch "<b>--EI</b>".
</p><p>
Differentials are entered as "<b>dx</b>", "<b>partialx</b>", "<b>\partialx</b>", "<b>\partial x</b>" or "<b>∂x</b>" and are treated as a single variable.
If you want to enter "<b>d</b>" * "<b>x</b>" multiplied implicitly then put a space between them or two spaces between the "<b>\partial</b>" and the "<b>x</b>".
There is nothing special about differential variables other than their specific use in differentiation and integration.
</p><p>
Variables may be assigned values, references to other variables or even entire expressions which will subsequently be substituted for those variables in any future expression evaluation.
They may also be assigned a user function which allows you to use them as macro expression functions, that is covered in the section on functions.
</p>

<h4>Vectors and Matrices</h4>

<p>
Vectors are passed as a single level of brackets such as "<b>\[1, 2]</b>" or "<b>\[x, y, z]</b>" and these are interpreted as column matrices.
Matrices are passed as nested rows of brackets with the first bracket being preceeded by a slash.
A 2x3 matrix would be specified as  "<b>\[[1, 2, 3], [4, 5, 6]]</b>", a 1x3 would be "<b>\[[1, 2, 3]]</b>" and a 3x1 would be either "<b>\[[1], [2], [3]]</b>" or the easier to write "<b>\[1, 2, 3]</b>" since this is equivalent.
These can also be entered using LaTeX "<b>\<span></span>begin{(v|b|p|)matrix} \<span></span>end{(v|b|p|)matrix}</b>" format.
</p>

<h4>Piecewise Expressions</h4>

<p>
These are supported and can be entered as SymPy "<b>Piecewise</b>" functions, LaTeX "<b>\<span></span>begin{cases} \<span></span>end{cases}</b>" notation or the native Python-like conditional expressions of the form "<b>a if condition else b</b>".
They may be arbitrarily long - "<b>a if condition1 else b if condition2 else ...</b>" and may leave off the last "<b>else</b>" which is equivalent to a SymPy "<b>Piecewise</b>" function without a terminating "<b>True</b>" condition.
</p>

<h4>Strings</h4>

<p>
These exist for the sole purpose of passing string hints or other arguments to SymPy functions. They work as expected being enclosed by single or double quotes and
supporting escape sequences. For example "<b>Limit (1/x, x, 0, '-')</b>".
</p>

<h4>Lists and Tuples</h4>

<p>
Standard Python bracket enclosed lists and optionally parentheses enclosed tuples are accepted.
Like strings these exist for the purpose of passing parameters to functions like "<b>Matrix ([[1, 2], [3, 4]])</b>".
</p>

<h4>Dictionaries</h4>

<p>
Standard Python dictionaries entered using the same format "<b>{a: b, c: d}</b>".
Like strings, lists and tuples these exist for the purpose of passing and recieving parameters to and from functions.
</p>

<h4>Sets</h4>

<p>
These are not the standard Python sets but rather are represented internally by the SymPy object "<b>FiniteSet</b>".
They can be entered via said "<b>FiniteSet</b>" function or via standard Python syntax for sets containing more than one element like "<b>{a, b, c}</b>".
To enter a set of zero or one element use the slash-curly set override syntax to open the set as such "<b>\{1}</b>" or "<b>{1,}</b>" for a one-element set or "<b>\{}</b>" for the empty set, otherwise for one element the curlys would be interpreted as parentheses and just like in Python the "<b>{}</b>" string is an empty dictionary, not a set.
As said these are converted to "<b>FiniteSet</b>" for evaluation. If however you need a true Python set for some reason then wrap the set or any other iterable in the Python "<b>set()</b>" function, this will always result in a Python set inside the calculations, though it will be returned to SymPy as a "<b>FiniteSet</b>" after the calculation completes.
</p><p>
The following default sets are available at the top level: "<b>Complexes</b>", "<b>Reals</b>", "<b>Naturals</b>", "<b>Naturals0</b>" and "<b>Integers</b>".
</p>

<h2>Operations</h2>

<h4>Addition and Multiplication</h4>

<p>
Addition is addition and subtraction is subtraction: "<b>a + b</b>", "<b>a - b</b>".
Multiplication is explicit with a "<b>*</b>" operator or implicit simply by writing two symbols next to each other with a space in between so that "<b>a * b</b>" is the same as "<b>a b</b>".
There is however a difference between the two in that the implicit version has a higher precedence than the explicit, which means that explicit multiplication will end a limit, sum, derivative or division "<b>/</b>" expression whereas implicit multiplication will not, e.g. "<b>1/x y</b>" = $\frac{1}{x y}$ whereas "<b>1/x*y</b>" = $\frac{1}{x} \cdot y$.
</p><p>
Division also has two operators, the normal "<b>/</b>" which has a fairly low precedence and the LaTeX "<b>\frac</b>" version which has a very high precedence, even higher than exponentiation.
So high in fact that parentheses are not needed if using "<b>\frac</b>" as an exponent as in "<b>x^\frac{1}{2}</b>" = $x^\frac{1}{2}$.
The "<b>\frac</b>" operation also does not need parentheses if using single digit operands or single letter variables (Latin or Greek) such as "<b>\frac12</b>" = $\frac12$ or "<b>\frac\alpha\beta</b>" = $\frac\alpha\beta$.
</p>

<h4>Exponentiation</h4>

<p>
There are two power opearators "<b>^</b>" and "<b>**</b>". They have the same precedence and can be used interchangeably but follow slightly different
parsing rules. The "<b>^</b>" operator follows LaTeX rules which only allow a single positive digit or letter variable (Lating or Greek) without the use
of curly braces whereas the "<b>**</b>" follows Python rules which allow negative values or variables or functions. To illustrate the diffference:
"<b>x**-2</b>" = $x^{-2}$ whereas "<b>x^-2</b>" = $x^-2$ (which makes no sense). Also, "<b>e**ln(x)</b>" will work as expected $e^{\ln(x)}$ whereas
"<b>e^ln(x)</b>" = $e^ln(x)$.
</p>

<h4>Logarithms</h4>

<p>
The natural logarithm of x is specified by "<b>ln x</b>", "<b>\ln x</b>", "<b>log x</b>", "<b>\log{x}</b>". A logarithm in a specific base is specified
by "<b>\log_b x</b>" = $\log_b x$, "<b>\log_{10}(1000)</b>" = $\log_{10}{1000}$ = 3, etc...
</p>

<h4>Roots</h4>

<p>
The square root of x ($\sqrt{x}$) may be entered in any of these forms "<b>sqrt x</b>", "<b>\sqrt x</b>", "<b>sqrt (x)</b>", "<b>\sqrt{x}</b>", with or without the slash.
The cube (or any other) root is similar, $\sqrt[3]x$ = "<b>sqrt[3]x</b>", "<b>sqrt[3] (x)</b>" or "<b>\sqrt[3] {x}</b>".
</p>

<h4>Factorial</h4>

<p>
"<b>4!</b>" = "<b>24</b>", "<b>x!</b>" = "<b>factorial(x)</b>", "<b>(-0.5)!</b>" = "<b>1.77245385090552</b>" and "<b>simplify(x!/x)</b>" = "<b>gamma(x)</b>".
</p>

<h4>Absolute Value</h4>

<p>
The shorthand for the absolute value of "<b>x</b>" is "<b>|x|</b>" though this may be ambiguous if using multiple absolute value bars, in which case simply wrap it in curly braces or parentheses as such "<b>{|x|}</b>".
</p>

<h4>Limits</h4>

<p>
To take the limit of an expression "<b>z</b>" as variable "<b>x</b>" approaches "<b>y</b>" enter "<b>\lim_{x \to y} (z)</b>" = $\lim_{x\to y} (z)$.
This will only give the limit if it exists and is the same when approaching from both directions, unlike SymPy which defaults to approaching from the
positive direction. To specify a direction add "<b>^+</b>" or "<b>^-</b>" to the equation as such: "<b>\lim_{x \to 0^+} 1/x</b>" = $\lim_{x\to 0^+}
\frac1x$ = $\infty$ and "<b>\lim_{x \to 0^-} 1/x</b>" = $\lim_{x\to 0^-} \frac1x$ = $-\infty$. Addition and explicit multiplication terminate a limit
expression. Limits may also be entered using the standard SymPy syntax "<b>Limit (expression, variable, to)</b>", this defaults to limit from positive
direction like SymPy, or you may specify a direction "<b>Limit (expression, variable, to, dir='+-')</b>".
</p>

<h4>Sums</h4>

<p>
The summation (finite or infinite) of expression "<b>z</b>" as variable "<b>n</b>" ranges from "<b>a</b>" to "<b>b</b>" is written as "<b>\sum_{n=a}^b
(z)</b>" = $\sum_{n=a}^b (z)$. Iterated sums work as expected, "<b>\sum_{n=1}^3 \sum_{m=1}^n m</b>" = $\sum_{n=1}^3 \sum_{m=1}^n m$ = 10. Addition and
explicit multiplication terminate a sum expression.
Sums may also be entered using the standard SymPy syntax "<b>Sum (expression, (variable, from, to))</b>".
</p>

<h4>Differentiation</h4>

<p>
The derivative of expression "<b>z</b>" with respect to "<b>x</b>" is entered as "<b>d/dx z</b>" or "<b>\frac{d}{dx} z</b>" = $\frac{d}{dx} z$. The
second derivative is "<b>d^2/dx^2 (z)</b>" or "<b>\frac{d^2}{dx^2} (z)</b>" = $\frac{d^2}{dx^2} (z)$. Using "<b>\partial</b>" ($\partial$) is allowed but
must be consistent within the expression. Mixed derivatives are entered as "<b>d^2 / dx dy (z)</b>" or "<b>\partial^2 / \partial x\partial y (z)</b>" =
$\frac{\partial^2}{\partial x\partial y} (z)$. Derivatives may also be entered using the standard SymPy syntax "<b>Derivative (expression, var1, var2,
power2, ...)</b>".
</p>

<h4>Integration</h4>

<p>
The anti-derivative of expression "<b>z</b>" with respect to x is written as "<b>\int z dx</b>" = $\int z\ dx$. The definite integral from "<b>a</b>" to
"<b>b</b>" is "<b>\int_a^b z dx</b>" = $\int_a^b z\ dx$. "<b>\int dx/x</b>" = $\int \frac1x\ dx$. Iterated and improper integrals also work. Integrals
may also be entered using the standard SymPy syntax "<b>Integral (expression, (variable, from, to), ...)</b>".
</p>

<h4>Comparison</h4>

<p>
Are parsed from the standard Python "<b>=, ==, !=, &lt;, &lt;=, &gt;, &gt;=</b>" or LaTeX "<b>\ne, \neq, \lt, \le, \gt, \ge</b>" symbols.
Currently only a single comparison is allowed so an expression like "<b>0 &lt;= x &lt;= 2</b>" is not valid.
Note that the "<b>=</b>" and "<b>==</b>" operators are equivalent for SymPy and mapped to the same "<b>Eq</b>" object in expressions but the single "<b>=</b>" operator has a lower precedence than the others and is used by SymPad for variable assignment whereas the double "<b>==</b>" only ever implies comparison.
</p><p>
The membership test "<b>in</b>" and "<b>not in</b>" are related to the comparison operators in that they generate a boolean value and just like in Python they live on the same precedence level.
These may be entered like in Python, using the LaTeX versions "<b>\in</b>" and "<b>\notin</b>" or directly using the Unicode characters "<b>∈</b>" and "<b>∉</b>" and they test for membership in any sequence or iterable.
</p>

<h4>Set Operations</h4>

<p>
These basic set operations are supported: "<b>+</b>", "<b>||</b>" or "<b>\cup</b>" for union - "<b>{1, 2} || {2, 3} = {1, 2, 3}</b>".
"<b>&&</b>" or "<b>\cap</b>" for intersection - "<b>{1, 2} && {2, 3} = {2,}</b>".
"<b>^^</b>" or "<b>\ominus</b>" for symmetric difference - "<b>{1, 2} ^^ {2, 3} = {1, 3}</b>".
"<b>-</b>" for relative complement - "<b>{1, 2} - {2, 3} = {1,}</b>".
The comparison operators can be applied to sets to test for subset "<b>&lt;</b>", proper subset "<b>&lt;=</b>", superset "<b>&gt;</b>" or proper superset "<b>&gt;=</b>".
The membership test operators "<b>in</b>" and "<b>not in</b>" work on sets as expected.
</p><p>
SymPy sets are a little broken in that the set operations will not accept undefined variables as stand-ins for sets to be evaluated later, which would mean that lambda functions using sets would not normally be possible.
A partial fix is to wrap the set operations in a lambda or variable assignment using the no-evaluate pseudo function like this "<b>f = lambda a, b: %(a || b)</b>", this will allow you to use the lambda but will still error out if you try to assign it to another
variable or view it.
</p>

<h4>Parentheses</h4>

<p>
Explicit "<b>( )</b>" or implicit curly "<b>{ }</b>" parentheses allow prioritization of lower precedence operations over higher ones as usual and also
delineate an expression as an input to a function. They may be used interchangeably for single expressions, the only difference being that the implicit
version is not drawn if it does not need to be. The case where explicit "<b>( )</b>" parentheses are needed ... explicitly ... is when calling functions
in general and always when calling functions which take multiple parameters like "<b>max(1, 2, 3)</b>". The curly braces are used as shorthand for sets
and dictionaries if commas are present, but that is a different syntactic usage, curlys with no commas are essentially invisible parentheses.
</p>

<h4>Indexing</h4>

<p>
Python style bracket indexing is natively supported for all objects using single or tuple indices and slices - "<b>'Hello'[::-1]</b>" = "<b>'olleH'</b>", "<b>\[[1, 2, 3], [4, 5, 6]] [1, 2]</b>" = "<b>6</b>" and "<b>\[[1, 2, 3], [4, 5, 6]] [:, 1:]</b>" = "<b>\[[2, 3], [5, 6]]</b>".
</p>

<h4>Member Access</h4>

<p>
You can access member data or functions of an expression just like in Python with the "<b>.</b>" operator.
If the attribute name following the dot is followed by a parenthesized expression then it will be treated as a function call instead of an implicit multiplication, otherwise it is a data member.
For example, two ways to get the transpose of a matrix are "<b>\[[1, 2, 3], [4, 5, 6]].T</b>" and "<b>\[[1, 2, 3], [4, 5, 6]].transpose ()</b>".
</p>

<h4>Variable Assignment</h4>

<p>
Using the syntax "<b>var = expression</b>" you can assign some value to be substituted for that variable in all expressions.
For example, doing "<b>x = pi</b>" and then evaluating "<b>cos x</b>" will give you "<b>-1</b>".
Anything can be assigned to any valid variable like mathematical expressions, Python objects like strings or lists, user lambda functions or even references to other variables.
To delete an assignment use the "<b>del var</b>" function, to delete all non-lambda variables do "<b>del vars</b>", to delete all user defined lambda functions do "<b>del funcs</b>" and to delete ALL assignments use "<b>delall</b>".
To see what variables are currently assigned to, use the "<b>vars</b>" function.
This will not show lambda assignments though, to see those use "<b>funcs</b>".
</p><p>
Tuple assignment is supported and as in Python the source can be another tuple or a single iterable object like "<b>x, y = 1, 2</b>".
A useless example of iterable assignment would be setting "<b> a, b, c = 'str' </b>" which would give you "<b> a = 's' </b>", "<b> b = 't' </b>" and "<b> c = 'r' </b>".
</p><p>
There are two distinct types of assignment that can occur and you should be aware of the difference between them.
Copy assignment is the standard type of assignment used by default in most computer languages where if you start with "<b>x = 1</b>" and you then enter "<b>y = x</b>" then the value "<b>1</b>" will be copied to the "<b>y</b>" variable.
The value of "<b>y</b>" will be independent of whatever else happens to the variable "<b>x</b>" after this.
</p><p>
The other kind of assignment is a reference assignment which will map the source variable instead of copying its value to the target.
This means that if you have a reference set like "<b>y = x</b>" and the value of "<b>x</b>" changes then the value of "<b>y</b>" will reflect this new value as well.
The reference assignment happens if you try to assign variables which do not exist, so setting "<b>y = x</b>" before "<b>x</b>" has been created will result in a reference.
Otherwise you can force a reference by using the "<b>@()</b>" pseudo-function.
Doing "<b>y = @x</b>" will create a reference to "<b>x</b>" itself instead of copying the value if it exists.
The "<b>@(expr)</b>" function technically prevents variable remapping for the expression it encompasses, so if you have the variable "<b>x = 2</b>" set and you do "<b>@(x)</b>" then you will get "<b>x</b>" and not "<b>2</b>".
</p><p>
Another potentially useful meta-function for assignment is "<b>%(expr)</b>".
This function defers evaluation of the expression for one round thus allowing things like assigning an integral operation to a variable instead of the result of the integral - "<b>f = %(\int a dx)</b>".
In this way you can assign different values to "<b>a</b>" and have the integration happen automatically any time you access the "<b>f</b>" variable instead of just using the result of whatever variables were defined at the time of definition.
</p>

<h4>Simplification</h4>

<p>
Apart from the explicit simplification you can always do via the "<b>simplify()</b>" function, by default SymPad will try to simplify the result of any calculation before returning it.
This is due to the fact that many times SymPy prefers to return results quicker and leaves the option to simplify to the user - in this case SymPad, whereas SymPad is the kind of application which should always present the simplest possible representation of a result.
This behavior can be turned off by calling "<b>env(nosimplify)</b>"" and turned back on via "<b>env('simplify')</b>", note the string quotes since "<b>simplify</b>" is a reserved SymPy function name.
</p><p>
A separate type of simplification is done for matrix operations since native SymPy matrix operations tend to blow up fairly quickly.
This simplification is on by default and simplifies matrices any time they are multiplied which helps control intermediate results in complex matrix operations and gives an already simplified answer once the operation completes.
This tends to slow down normal matrix operations a little but prevents the kind of lockup that can occur if a complex operation leaves a matrix in a state which is impossible for the normal "<b>simplify()</b>" function to correct.
This simplification can be turned off and on via "<b>env(nomatsimp)</b>" and "<b>env(matsimp)</b>".
</p>

<h2>Functions</h2>

<p>
There are two types of functions made available in SymPad - all the SymPy native functions are available directly just by typing their name (a few escaped with "<b>$</b>"), as well as user created lambda functions assigned to variables.
In addition, member functions of objects are supported and callable like "<b>Matrix ([1, 2, 3]).transpose ()</b>".
All functions may take multiple comma-separated arguments and the SymPy functions also optionally take keyword arguments.
</p>

<h4>SymPy Functions</h4>

<p>
Almost all SymPy function and objects from the top level of the SymPy module are made available directly for calling by their name like "<b>tan(x)</b>", the only restriction being they must be longer than a single character and may not begin with an underscore.
Though those and functions and others beginning with an underscore as well as many __builtins__ can still be accessed with the "<b>$</b>" function override escape character, for example "<b>$print ("Hello World...")</b>".
Only the "safe" __builtin__ functions are specifically made available, functions like "<b>eval</b>", "<b>exec</b>" and many more have been left out and are not accessible.
The reason for excluding single letter functions is that due to the way the grammar works all natively recognized function names are permanently excluded from being used as variables and since very often single letters are used as variable names this would be problematic.
A workaround is in place and described further down.
</p><p>
The standard trigonometric and hyperbolic functions and their inverses can be entered as usual, the forward functions with or without a leading slash: "<b>sin</b>", "<b>\coth</b>".
The inverses are entered as Pythonic functions without a slash like "<b>atan</b>" or "<b>acscsh</b>" and the LaTeX versions take a slash and and are spelled out "<b>\arctan</b>".
The inverses may also be specified using the common mathematical syntax: "<b>\tan^{-1}x</b>" or "<b>cos**-1 x</b>".
This form of exponentiating a function is extended as an input shortcut for all top-level functions so that typing "<b>ln**2x</b>" is a quick way to enter "<b>(ln(x))**2</b>".
This does not apply to member functions or user created lambda functions.
Keep in mind that the "<b>-1</b>" exponent in those contexts is just a -1 and does not specify the inverse function as it does for the forward trigonometric and hyperbolic functions.
</p><p>
Top-level and user lambda functions also don't require explicit parentheses in order to allow quick entry like "<b>sqrt 2</b>" or "<b>sin**-1x</b>" but for any parameter more complicated than another function or variable to a power they will be needed.
Functions which take zero or more than one single parameter, as well as member functions such as "<b>\[[1, 1], [0, 1]].det()</b>" always require explicit parentheses.
Many functions which have a common mathematical display style are translated on the fly for rendering in that style.
These include the functions "<b>abs/Abs (x)</b>" which are rendered as the standard bar syntax for absolute value "<b>|x|</b>", the "<b>factorial (x)</b>" function becomes "<b>x!</b>" and "<b>exp (x)</b>" displays as "<b>e^x</b>".
Some other functions which are translated are "<b>Derivative</b>", "<b>diff</b>", "<b>Integral</b>", "<b>integrate</b>", "<b>Limit</b>", "<b>limit</b>", "<b>Matrix</b>", "<b>Piecewise</b>", "<b>pow</b>", "<b>Pow</b>" and "<b>Sum</b>", and more...
</p>

<h4>Lambda Functions</h4>

<p>
User created lambda functions are supported and are specified the same way as Python lambdas - "<b>lambda x, y: (x+y)**2</b>".
In order to make use of them though you must assign them to a variable like "<b>f = lambda x: x**2</b>", now when you call "<b>f(3)</b>" you will get "<b>9</b>" as the result.
When a lambda function is defined no variables are mapped and no functions are called or expressions doit()-ed, this means that if a lambda references an assigned global variable the variable will be bound upon execution, not definition of the lambda.
This also means that if you create a lambda like "<b>f = lambda x: \int x dx</b>", the integral will not be evaluated until the lambda is executed.
Lambda functions may reference other lambda functions as long as those are defined at the time of creation.
Lambdas may be passed to SymPy functions which take those and use them for something but these may not reference other user lambdas.
Lambda recursion is not supported.
</p>

<h4>Functions, Parentheses and Implicit Multiplication</h4>

<p>
SymPad supports implicit multiplication, that is writing two variables next to each other to indicate multiplication so "<b>x y</b>" = "<b>x * y</b>".
This brings some problems, such as deciding when "<b>x (a + b)</b>" is a function call and when it is multiplication.
SymPad solves this by recognizing all top-level SymPy package function names and classes as functions and accepting the next expression as the argument(s) to that function.
This brings along its own set of peculiarities such as removing those names from the possible namespace pool of variables, this means that you can never redefine "<b>sin</b>" as anything else, but why would you want to?
</p><p>
This recognition only works on top-level objects, for members of an object the presence of a parenthesized expression after the attribute name will imply a function call.
If that is not the intent and you instead want to treat the member as a data variable and multiply it with something then you must use explicit "<b>*</b>" multiplication or the curly parentheses as such "<b>\[1, 2, 3].T * (a + b)</b>" or "<b>\[1, 2, 3].T {a + b}</b>".
If you try to do this with regular parentheses then a function call will be attempted with "<b>a + b</b>" as the argument.
The meaning of parentheses for assigned user variables is inferred from whether the variable is a lambda or not, for lambdas parentheses are a function call and for other types they indicate multiplication.
</p><p>
In a roundabout sort of way this all led to a peculiar delima.
There is a namespace collision between the Greek letters "<b>beta</b>", "<b>zeta</b>", "<b>gamma</b>", "<b>Gamma</b>" and "<b>Lambda</b>" and SymPy functions with those names (well, lowercase SymPy "<b>gamma()</b>" really, but it is represented normally with the uppercase Greek letter).
This means that those function names could be encoded in the grammar and never be available for use as free variables, or they could be excluded from the grammar forcing the user to call them each time using the function escape character "<b>$</b>".
This was not very elegant so the workaround is as follows:
This is not a problem for "<b>beta</b>" and "<b>Lambda</b>" since they require multiple arguments and can be recognized as function calls from an implicit multiplication with a tuple of size 2, but the others can not be recognized this way.
</p><p>
These function names have been left out of the grammar but hidden lambda functions are created for them on startup so that they may be called using normal syntax.
These lambda functions do not appear in the normal list of functions shown by "<b>funcs()</b>" but their status can be checked by using the "<b>env()</b>" function.
When these functions are mapped they are treated exactly like variables mapped to a lambda for the purposes of calling them, but they are still available as free variables to use and even assign to.
To enable or disable environment mapping of these functions like "<b>gamma()</b>" enter "<b>env (nogamma)</b>" or "<b>env (gamma=False)</b>" to disable and "<b>env (gamma)</b>" or "<b>env (gamma=True)</b>" to enable.
Note that objects like "<b>S.Half</b>" or "<b>S.ComplexInfinity</b>" are always available because they are special cased, even if "<b>S()</b>" is not mapped, though if it is assigned to something else then these attributes are lost.
Also remember that these functions are always available for calling using the "<b>$</b>" function call escape character regardless of if they are mapped in the environment or not.
</p>

<h2>Plotting</h2>

<p>
Basic plotting functionality is available if you have the matplotlib Python module installed on your system.
These functions work more like statements in that they only work at the top level of the parse tree, which means you can not use them in other lambdas or tuples or assignments.
</p>

<h4>plotf() - Plot Function</h4>

<p><b>Examples</b></p>

<p>
plotf (x**2)<br>
plotf (2pi, sin x, cos x, sinc x, tanh x)<br>
plotf (2, lambda x: 1 / x, '--r')<br>
plotf (-2, 5, (x**2 - 6x + 9) / (x**2 - 9), ':#green')<br>
plotf (4, (x**2 + x - 2) / (x - 1), 'b=line', (1, 3), 'o#red=point')<br>
plotf (-1, 2, -3, 4, (0, 0), 'xr', [1, 1, 1.9, 1], 'vb', [(0.5, 2), (1.5, 3), (1.5, 0), (-0.5, -2)], ':g')<br>
plotf (pi, -20, 20, tan x, '#c08040=tan x', fs = (12, 4.8), linewidth = 1)<br>
plotf (2pi, sin x, 'r', {'linewidth': 1}, cos x, 'g', {'linewidth': 3}, fs = 12)<br>
plotf (1.5, -1.5, 1.5, sqrt (1 - x**2), 'r', -sqrt (1 - x**2), 'r', fs = -8, res = 32)<br>
plotf (\sum_{n=0}**oo x**n / n!, 'd-#chocolate=e^x', res = 1, linewidth=0.5)<br>
plotf (4pi, d / dx (sin x / x), sin x / x, \int sin x / x dx)<br>
</p>

<p><b>Usage</b></p>

<p>
SymPad provides the "<b>plotf()</b>" function which can be used to plot one or more expressions or lambdas of one free variable or lists of points or lines.
This function works by sampling a given expression at regular intervals to build up a list of x, y coordinates to pass on to matplotlib for rendering, the size of this sampling interval can be adjusted with a keyword argument.
The format of this plot function is as follows: "<b>plotf(['+',] [limits,] [*plots,] fs=None, res=12, style=None, **kwargs)</b>".
</p><p>
The initial optional "<b>'+'</b>" string signifies that the plot should build upon the previous plot which allows you to build up complex plots one function at a time.
The limits are an optional zero to four numbers which specify the boundaries of the requested plot, if no limit numbers are present then the plot will range from 0 to 1 on the x axis and the y axis will be determined automatically.
If one limit number is present then the plot will range from -x to +x of this number and the y is automatic, two numbers are interpreted as x0 and x1 and y is automatic, three is -x, x, y0 and y1 and four numbers let you specify the full range x0, x1, y0, y1 of the axes.
</p><p>
The "<b>fs</b>" keyword argument is a matplotlib "<b>figsize</b>" value which lets you specify the size of the plot. This can be either a single number in which case this specifies the x size and the y size is computed from this, or it can be a tuple specifying both the x and y sizes of the plot - the default is (6.4, 4.8).
If a single number is provided and it is positive then the y size is computed as x*3/4 of this number to give a plot area with a 4:3 aspect ratio.
It the single number is negative then the y size is set equal to the positive x size and the plot area will have a square aspect ratio.
</p><p>
The "<b>res</b>" keyword argument allows you to set the sampling resolution for the plot, the default is roughly 12 samples per 50 pixels of the plot.
This is useful to increase if the function is intricate and the default resolution does not capture some point of interest correctly.
</p><p>
The "<b>style</b>" keyword allows you to change to any of the default matplotlib styles for drawing the plots.
Some available styles are: "<b>bmh</b>", "<b>classic</b>", "<b>dark_background</b>", "<b>fast</b>", "<b>fivethirtyeight</b>", "<b>ggplot</b>", "<b>grayscale</b>", see the matplotlib documentation for a full list of styles.
If you pass the name of the style starting with a '-' minus sign such as "<b>-bmh</b>" then the plot will be rendered with a transparent background, otherwise the color of the background comes from the style.
The style which is set will persist for all future plots until it is changed.
</p><p>
Other keyword arguments from "<b>kwargs</b>" are passed through on to the "<b>matplotlib.pyplot.plot()</b>" function for each expression plotted.
In addition each expression or function to be plotted can also specify its own dictionary of matplotlib keyword arguments to use for that specific expression.
</p>

<p><b>Individual Plots</b></p>

<p>
The "<b>plotf()</b>" function can take any number of expressions to plot at once with their own formatting options.
The actual source of the data to be plotted can be an expression, a lambda function or a list of coordinate points which will be rendered as either a line of a certain style or just disconnected markers.
The format of each individual plot specification to the plotting function is as follows: "<b>expression [,'format'] [,{'kwarg': value, ...}]</b>".
As mentioned the expression can be just an expression like "<b>x**2</b>", a lambda of one variable "<b>lambda x: x**2</b>" or a list of paired "<b>[(x0, y0), (x1, y1), ...]</b>" or unpaired "<b>[x0, y0, x1, y1, ...]</b>" coordinates.
</p><p>
Following the expression is an optional string specifying the color, line or marker style and optional legend text for the expression.
The format of this string is an extension of the matplotlib format string to its "<b>plot()</b>" function and is as follows: "<b>[marker][line][color][#extended color][=legend text]</b>".
The "<b>marker</b>" option specifies which type of marker (if any) to place at each computed x, y coordinate, the possible options are: '.', ',', 'o', 'v', '^', '&lt;', '&gt;', '1', '2', '3', '4', 's', 'p', '*', 'h', 'H', '+', 'x', 'D', 'd', '|' and '_'.
The "<b>line</b>" option specifies which type of line (if any) connects the various x, y coordinates, the possible options are: '-', '--', '-.' and ':'.
The options for the simple color specifier "<b>color</b>" are 'b', 'g', 'r', 'c', 'm', 'y', 'k' and 'w', which is a quick one letter way to pick different colors.
If you need more control over color then use the extended color specifier which allows you to pick from the whole list of matplotlib named colors such as 'red', 'teal', 'mediumorchid' and 'salmon'.
You can also directly specify the RGB values of the color by entering an HTML RGB color specifier like '#ff8040'.
The last specifier is optional legend text for the expression, the presence of which is signalled by the '=' character immediately preceding it.
</p><p>
Following the format specifier is an optional dictionary of keyword argument and value pairs to be passed on to the matplotlib "<b>plot()</b>" function only for this given expression.
These arguments will override any global matplotlib keyword arguments specified in the call to the "<b>plotf()</b>" function.
</p><p>
Note that the presence of any plots at all in a call to "<b>plotf()</b>" is optional, you can call "<b>plotf()</b>" with the continue option '+' without any plots in order to resize the previous plot or change the axes.
Keep in mind that this does not re-plot any previously plotted functions so that data remains at whatever resolution it was plotted.
</p>

<h4>plotv() - Plot Vector Field (2D)</h4>

<p><b>Examples</b></p>

<p>
plotv ((-y, x))<br>
plotv (2, y - 2 x, '#green')<br>
plotv (lambda x, y: (y, -x), 'dir')<br>
plotv (2, -2, 2, y / x, '#red=dy/dx', fs = -6, width = 0.005)<br>
plotv (4, -4, 4, (lambda a, b: a + b**2, lambda a, b: a**2 - b), lambda x, y, u, v: y, res = 31, fs = -8, width = 0.003)<br>
plotv (-2, 2, -2, 2, (v (sign (Max (u, 0)) * 2 - 1), -u (sign (Max (u, 0)) * 2 - 1)), 'dir', width = 0.003, pivot = 'mid', fs = -8)<br>
plotv (-6, 6, -2, 2, lambda x, y: (re (sin (x + i y)), im (sin (x + i y))), 'mag', '=sin (x + iy)', fs=-12, res=33)<br>
</p>

<p><b>Usage</b></p>

<p>
This function allows you to plot a 2-dimensional vector field specified by one or two functions or expressions via the matplotlib "<b>Quiver()</b>" function.
The format of this function is as follows: "<b>plotv (['+',] [limits,] func(s), [color,] [fmt,] [*walks,] fs = None, res = 13, style = None, resw = 1, kww = {}, **kw)</b>".
The initial optional "<b>'+'</b>" and "<b>limits</b>" fields work exactly as in the "<b>plotf()</b>" function, as do the keyword arguments "<b>fs</b>" and "<b>style</b>".
</p><p>
The actual vector field to be plotted comes from either one or two functions or expressions which provide either the u and v coordinates of the vectors or a v/u slope for the vector - in which case the vector will not have a direction arrowhead by default.
These function(s) are specified in the "<b>func(s)</b>" parameter and must be either a tuple of two functions or expressions or a single function or expression.
</p><p>
If there are two functions then they are called for each point sampled in the vector field with an x and y coordinate (the names of the symbols don't matter, the first argument is the x and the second is a y).
These functions must each return a single real value, the first function returns the u component of the vector field and the second returns the v component.
If instead of functions there is a tuple of two expressions, then the expressions together must have exactly two free variables which will be replaced with the x and y values of the vector field in alphabetical order, which means that expressions with free variables (a, b), (u, v) and (x, y) will recieve the x and y coordinates in that order.
</p><p>
If there is a single function or expression present then the interpretation of that function depends on what it returns.
If the return value is a single real number then it is interpreted as a slope at that point in the vector field and rendered as such a sloped line, this is useful for plotting things like differential functions.
If the return value has two components like a tuple or list of real values then those are treated as the u and v components of the vector field at that point directly and actually have a direction and magnitude unlike the single value slope.
</p><p>
The optional "<b>color</b>" parameter following the field functions(s) is either a function of four arguments "<b>lambda x, y, u, v: expr</b>" which will be called for each point of the vector field and should return a scalar, which scalar will be used to determine the relative color of the arrow at that point.
Or it can be a string specifying one of the pre-defined color functions: 'dir' for a direcitonal color function and 'mag' for a magnitude color function, note 'mag' option doesn't make much sense for a field function or expression which only returns a slope.
</p><p>
Following this is an optional format string which works much like the format strings from the "<b>plotf()</b>" function except omitting the "<b>[marker][line][color]</b>" prefix and using only "<b>[#extended color][=legend text]</b>".
If a color function is not specified before this string and a color is present then that color is used for the entire vector field.
A label can also be present for this particular vector field which can be useful if plotting more than one field.
</p><p>
Finally the "<b>res</b>" argument specifies a resolution - or rather the number of arrows you want horizontally in the plot.
If this argument is a single number then the number of arrows vertically across the plot is calculated from the aspect ratio of the plot as specified or not by the "<b>fs</b>" figsize argument.
If rather the "<b>res</b>" argument is a tuple of two numbers then these are used directly for the number of arrows horizontally and vertically in the plot.
</p><p>
Any keyword arguments are passed through on to the matplotlib "<b>Quiver()</b>" function which allows you to tweak certain display properties of the plot like line thicknesses and arrowheads, for a full list of these options see the matplotlib documentation.
Also notice that unlike the "<b>plotf()</b>" function, "<b>plotv()</b>" only plots one vector field at a time.
</p><p>
If any non-keyword arguments are present after the "<b>func(s)</b>", "<b>color</b>" and "<b>fmt</b>" parameters but before any keyword arguments then they are interpreted as parameters to the function "<b>plotw()</b>" which will be called after the vector field is plotted and will plot one or more walks over that vector field.
The "<b>resw</b>" parameter is passed on to "<b>plotw()</b>" as a keyword argument as well as the contents of the "<b>kww</b>" dictionary.
See the documentation for that function for usage and formatting of these parameters.
</p>

<h4>plotw() - Plot Walk Over Vector Field</h4>

<p><b>WARNING!</b> This plotting function can be very slow due to the fact it calls very frequently into SymPy Lambda functions as it adapts the walk to minimize potential error.</p>

<p><b>Examples</b></p>

<p>
plotw (3, -3, 3, y - 2x, (1, 1))<br>
plotw (3, -3, 3, y - 2x, (1, 1), (1, 2), (1, 0))<br>
plotw (6, -6, 6, lambda x, y: (2x + sec**2x) / 2y, (0, -5), 'r=u(0) = -5', fs = -7)<br>
plotw (2.5, -2.5, 2.5, (-y, x), (0.5, 0), '=(0.5,0)', (1, 0), '=(1,0)', (1.5, 0), '=(1.5,0)', (2, 0), '=(2,0)', fs = -6)<br>
plotw (pi, -pi, pi, sin x - sin y, (0, 0), (1, 1), (2, 2), (-1, -1), (-2, -2), fs = -8, linewidth = 5)<br>
</p><p>
These will make more sense if they are put in the context of their respective vector fields:
</p><p>
plotv (3, -3, 3, y - 2x, (1, 1))<br>
plotv (3, -3, 3, y - 2x, (1, 1), (1, 2), (1, 0))<br>
plotv (6, -6, 6, lambda x, y: (2x + sec**2x) / 2y, (0, -5), 'r=u(0) = -5', fs = -7, res = 33)<br>
plotv (2.5, -2.5, 2.5, (-y, x), (0.5, 0), '=(0.5,0)', (1, 0), '=(1,0)', (1.5, 0), '=(1.5,0)', (2, 0), '=(2,0)', fs = -6, pivot = 'mid')<br>
plotv (pi, -pi, pi, sin x - sin y, (0, 0), (1, 1), (2, 2), (-1, -1), (-2, -2), fs = -8, kww = {'linewidth': 5})<br>
</p>

<p><b>Usage</b></p>

<p>
This function is normally intended to be called implicitly from the "<b>plotv()</b>" function for plotting a walk over a plotted vector field but can be called on its own to plot one or more walks without the vectory field in the background.
The format is as follows: "<b>plotw (['+',] [limits,] func(s), *points, fs = None, resw = 1, style = None, **kw)</b>"
The "<b>'+'</b>", "<b>limits</b>", "<b>fs</b>" and "<b>style</b>" fields work in the same manner as the previous two functions.
The "<b>func(s)</b>" is interpreted as a vector field function or pair of functions or expressions like in "<b>plotv()</b>".
"<b>resw</b>" is a resolution parameter - maximum pixel steps to allow walk step to deviate before drawing, smaller = better quality.
</p><p>
What this function does is take an x, y point (or points if multiple starting positions provided) and starts walking the vector field according to its value at that point - following the gradient.
It adapts the steps it takes according to how much curvature the vector field exhibits at that point and tries to reach either the edge of the graph or its own starting point to complete a loop.
The "<b>*points</b>" parameters specified in the function is either one or more tuples of x, y values optionally followed by "#color=label" formatting and dictionary keywords for the line corresponding to the walk for that point, similar to the previous functions.
An example of "<b>*points</b>": "<b>plotw(..., (0, 0), '#red=0,0', {'linewidth': 2}, (1, 1), '#green=1,1', {'linewidth': 3}, (2, 2), ...)</b>".
</p><p>
Due to numerical errors accumulating during the walk this is by no means a perfect plotting function and should be considered experimental.
Also due to the fact that the points of the vector field are gotten from SymPy operations and the number of times they are requested this function can be very slow.
It may also never finish if a complex circular vector field introduces enough errors so that the walk gets back to the starting point but not quite close enough to consider it a full loop then the walk will keep going around and around in circles and the function will not return, you have been warned.
</p>

<h2>Appendix</h2>

<h4>Special Characters</h4>

<p>"<b>_</b>" - Underscore represents the last successfully evaluated expression, assignment to variables is not considered a successful evaluation for this purpose.
Even if the object resulting from the expression is not natively known to SymPad it is stored on the server and so is available exactly as it was returned from the previous calculation by using underscore.</p>
<p>"<b>$</b>" - "<b>$name</b>" - Dollar is a function name escape character which can be used to call functions which are not normally available at the top level of SymPad.</p>
<p>"<b>@</b>" - "<b>@(expr)</b>" - Ampersand technically turns off variable remapping for any expression it encapsulates which means that if it wraps a global variable then the variable reference will be user and not its value.
<p>"<b>%</b>" - "<b>%(expr)</b>" - Percent prevents evaluation for the expression it encapsulates for one round. An optional second argument is a count of the number of rounds to prevent evaluations, it can be infinity.</p>
<p><b>Unicode Greek Letters</b> - α, β, γ, δ, ε, ζ, η, θ, ι, κ, λ, μ, ν, ξ, π, ρ, σ, τ, υ, φ, χ, ψ, ω, Γ, Δ, Θ, Λ, Ξ, Π, Σ, Υ, Φ, Ψ, Ω.</p>
<p><b>Unicode Symbols</b> - ∞, ≠, ≤, ≥, ∂, ∑, ∫, ∈, ∉, ∩, ∪, ⊖.</p>

<h4>Admin Functions</h4>

<p>"<b>vars()</b>" - Show all currently mapped non-lambda user variables.</p>
<p>"<b>funcs()</b>" - Show all currently mapped lambda user variables (callable functions).</p>
<p>"<b>del(var1, var2, ...)</b>" - Delete variable assignments, lambda or non-lambda.</p>
<p>"<b>del(vars())</b>" - Delete all non-lambda variables.</p>
<p>"<b>del(funcs())</b>" - Delete all lambda functions.</p>
<p>"<b>delall()</b>" - Delete ALL variables, lambda and non-lambda.</p>
<p>"<b>env()</b>" - Show or change current SymPad runtime environment.
Called without any arguments it will show the current state of the environment.
If arguments are present they specify turning on or off a certain aspect of SymPad functionality.
For example the quick input functionality "<b>quick</b>" may be turned on by specifying "<b>env(quick)</b>", "<b>env('quick')</b>" or "<b>env(quick=True)</b>", to turn it off specify "<b>env(noquick)</b>" or "<b>env(quick=False)</b>".</p>
<p>"<b>envreset()</b>" - Reset environment to what it was at startup.</p>

<h4>Environment Settings for env()</h4>

<p>In quick input mode you should always use parentheses and in the case of the "<b>simplify</b>" option you need to use the quoted version "<b>env('simplify')</b>" due to that being a function name and how letters are parsed in quick mode.</p>

<p>"<b>EI</b>" - Use variables "<b>E</b>" and "<b>I</b>" as Euler's constant and imaginary unit as opposed to "<b>e</b>" and "<b>i</b>".
This allows the Python code copied from SymPad to work directly with SymPy where the uppercase constants are used.</p>
<p>"<b>quick</b>" - Quick single letter variable name input mode.</p>
<p>"<b>simplify</b>" - Post-evaluation simplification, this can sometimes cause problems if the expressions are somewhat complex since simplification can take some time, in that case simply turn this off.</p>
<p>"<b>matsimp</b>" - Matrix simplification, this turns on a patch to SymPy which does a basic simplification step on intermediate matrix multiplication products which prevents matrix operations from blowing up.</p>
<p>"<b>pyS</b>" - Python representation number escaping with the "<b>S()</b>" function where potentially necessary, e.g. "<b>S(2)/3</b>".</p>
<p>"<b>eval</b>" - Expression evaluation. Normally when you enter "<b>1 + 2</b>" it is evaluated for an answer of "<b>3</b>". If you turn this option off then this evaluation will not happen and the expression will stay as "<b>1 + 2</b>". The option technically controls whether an "<b>evaluate=False</b>" flag is passed to SymPy objects.</p>
<p>"<b>doit</b>" - Expression final SymPy doit() call. Normally after an expression is converted to an internal SymPy object that object's "<b>doit</b>" member is called to fully evaluate the expression, this can be surpressed by turning this option off. Note that turning off the previous option "<b>eval</b>" implies turning off "<b>doit</b>".</p>
<p>"<b>N</b>" - Mapping access to the SymPy "<b>N()</b>" function via the "<b>N</b>" variable.</p>
<p>"<b>O</b>" - Mapping access to the SymPy "<b>O()</b>" function via the "<b>O</b>" variable.</p>
<p>"<b>S</b>" - Mapping access to the SymPy "<b>S()</b>" function via the "<b>S</b>" variable.</p>
<p>"<b>gamma</b>" - Mapping access to the SymPy "<b>gamma()</b>" function via the "<b>gamma</b>" variable.</p>
<p>"<b>Gamma</b>" - Mapping access to the SymPy "<b>Gamma()</b>" function via the "<b>Gamma</b>" variable.</p>
<p>"<b>zeta</b>" - Mapping access to the SymPy "<b>zeta()</b>" function via the "<b>zeta</b>" variable.</p>

</b></p>

<h4>More Examples</h4>

<p>
Calculating eigenvalues and eigenvectors of a matrix by "hand":
</p><p>
m = \[[1, 2], [3, 4]]<br>
l = m - lambda eye 2<br>
l.det ()<br>
solve _<i>&emsp;this will give the eigenvalues</i><br>
a, b = _<i>&emsp;assign to vars</i><br>
m.eigenvals ()<i>&emsp;verify eigenvalues</i><br>
Subs (l, lambda, a) \[x, y]<br>
solve (_ [0], _ [1], x, y)<i>&emsp;relation between x and y</i><br>
\[_ [0] [x], y].subs (y, 1)<i>&emsp;first eigenvector for eigenvalue a</i><br>
Subs (l, lambda, b) \[x, y]<br>
solve (_ [0], _ [1], x, y)<i>&emsp;relation between x and y</i><br>
\[_ [0] [x], y].subs (y, 1)<i>&emsp;second eigenvector for eigenvalue b</i><br>
m.eigenvects ()<i>&emsp;verify eigenvectors</i><br>
</p>

<h4>Notes</h4>

<p>
<b>WARNING!</b> This http server implementation is nowhere near secure, this as well as the posibility of execution of arbitrary Python functions means you should never leave this server open to the internet by serving on an IP address visible to the external world.
</p><p>
Due to mixing operators from Python and LaTeX the grammar may be a little wonky in places so if something doesn't seem to work as it should try wrapping it in parentheses or putting a space between the problematic elements.
</p><p>
After filling up the browser with many pretty mathematical expressions you may note that it starts to get slower, simply reload the page, all your variables and history will be preserved.
Or try adding "<b>--ugly</b>" to the command line, this will use a quicker draft rendering for the math.
</p><p>
You can always tell whether SymPad will treat an identifier as a function or a variable by looking at the font which is used for the name, it is different for functions vs. variables.
Also, SymPad will give you an empty set of parentheses as an autocomplete option when it recognizes a function name (this only works for top-level functions).
</p><p>
If you are getting results which are just plain wrong, check to see if you have any variables or lambdas mapped which would be changing the evaluation.
</p><p>
If you are unable to use a keyword argument identifier in a function call because it is a reserved name then you can wrap it in quotes, Python strings are allowed as keyword identifiers specifically for this purpose.
</p><p>
Usually SymPad should be smart enough to figure out when a function argument is and equation and when it is a keyword assignment like in this function "<b>solve(x**2 = i)</b>".
However some room for ambiguity remains like in this function "<b>solve(i = x**2)</b>".
In cases like these you need to pass the equation followed by an explicit non-keyword argument like "<b>solve(i = x**2, x)</b>" or by using the strict comparison double equals "<b>solve(i == x**2)</b>".
</p><p>
The LaTeX parsing is not really comprehensive, it is geared towards being able to read back the LaTeX emitted by SymPad correctly.
</p><p>
SymPad inserts the current working directory at the beginning of the Python module search path which means that for example if you run SymPad in the SymPy development directory then the SymPy module used will be the development version.
</p><p>
The server runs a single thread for consistency and keeps a single global state (variables), this means that if have two browser windows open the results of calculations in one will be reflected in the other.
If you want a completely separate context then you can run another SymPad on a different port.
</p><p>
Keep in mind that if you copy to Python code and want it to run in SymPy you must be in uppercase "<b>EI</b>" mode or have the variables "<b>e</b>" and "<b>i</b>" in Python assigned to "<b>E</b>" and "<b>I</b>".
</p><p>
There are many SymPy objects which SymPad does not understand natively yet.
In any case where such an object is the result of an evalutation then the SymPy LaTeX representation will be used for the displayed answer and the SymPy str version of the element will be used in the native representation string.
This should allow you to continue working with the calculation.
</p>

<br><br>
<div align="center">
Copyright (c) 2019 Tomasz Pytel, All rights reserved.

SymPad on GitHub: <a target="_blank" href="https://github.com/Pristine-Cat/SymPad">https://github.com/Pristine-Cat/SymPad</a>
</div>

</body>
</html>""".encode ("utf8"),
}

# Parser for PLY generated LALR1 grammar.

import re
import types

#...............................................................................................
class Incomplete (Exception):
	def __init__ (self, red):
		self.red = red

class Token (str):
	def __new__ (cls, str_, text = None, pos = None, grps = None):
		self      = str.__new__ (cls, str_)
		self.text = text or ''
		self.pos  = pos
		self.grp  = () if not grps else grps

		return self

class State (tuple): # easier on the eyes
	def __new__ (cls, *args):
		return tuple.__new__ (cls, args)

	def __init__ (self, *args): # idx = state index, sym = symbol (TOKEN or 'expression'), red = reduction (if present)
		if len (self) == 2:
			self.idx, self.sym = self
		else: # must be 3
			self.idx, self.sym, self.red = self

class LALR1:
	_rec_SYMBOL_NUMTAIL = re.compile (r'(.*[^_\d])_?(\d+)?') # symbol names in code have extra digits at end for uniqueness which are discarded

	def set_tokens (self, tokens):
		self.tokgrps = {} # {'token': (groups pos start, groups pos end), ...}
		tokpats      = list (tokens.items ())
		pos          = 0

		for tok, pat in tokpats:
			l                   = re.compile (pat).groups + 1
			self.tokgrps [tok]  = (pos, pos + l)
			pos                += l

		self.tokre   = '|'.join (f'(?P<{tok}>{pat})' for tok, pat in tokpats)
		self.tokrec  = re.compile (self.tokre)

	def __init__ (self):
		if isinstance (self._PARSER_TABLES, bytes):
			import ast, base64, zlib
			symbols, rules, strules, terms, nterms = ast.literal_eval (zlib.decompress (base64.b64decode (self._PARSER_TABLES)).decode ('utf8'))
		else:
			symbols, rules, strules, terms, nterms = self._PARSER_TABLES

		self.set_tokens (self.TOKENS)

		self.rules   = [(0, (symbols [-1]))] + [(symbols [r [0]], tuple (symbols [s] for s in (r [1] if isinstance (r [1], tuple) else (r [1],)))) for r in rules]
		self.strules = [[t if isinstance (t, tuple) else (t, 0) for t in (sr if isinstance (sr, list) else [sr])] for sr in strules]
		states       = max (max (max (t [1]) for t in terms), max (max (t [1]) for t in nterms)) + 1
		self.terms   = [{} for _ in range (states)] # [{'symbol': [+shift or -reduce, conflict +shift or -reduce or None], ...}] - index by state num then terminal
		self.nterms  = [{} for _ in range (states)] # [{'symbol': +shift or -reduce, ...}] - index by state num then non-terminal
		self.rfuncs  = [None] # first rule is always None

		for t in terms:
			sym, sts, acts, confs = t if len (t) == 4 else t + (None,)
			sym                   = symbols [sym]

			for st, act in zip (sts, acts):
				self.terms [st] [sym] = (act, None)

			if confs:
				for st, act in confs.items ():
					self.terms [st] [sym] = (self.terms [st] [sym] [0], act)

		for sym, sts, acts in nterms:
			for st, act in zip (sts, acts):
				self.nterms [st] [symbols [sym]] = act

		prods = {} # {('production', ('symbol', ...)): func, ...}

		for name in dir (self):
			obj = getattr (self, name)

			if name [0] != '_' and type (obj) is types.MethodType and obj.__code__.co_argcount >= 1: # 2: allow empty productions
				m = LALR1._rec_SYMBOL_NUMTAIL.match (name)

				if m:
					parms = tuple (p if p in self.TOKENS else LALR1._rec_SYMBOL_NUMTAIL.match (p).group (1) \
							for p in obj.__code__.co_varnames [1 : obj.__code__.co_argcount])
					prods [(m.group (1), parms)] = obj

		for irule in range (1, len (self.rules)):
			func = prods.get (self.rules [irule] [:2])

			if not func:
				raise NameError (f"no method for rule '{self.rules [irule] [0]} -> {''' '''.join (self.rules [irule] [1])}'")

			self.rfuncs.append (func)

	def tokenize (self, text):
		tokens = []
		end    = len (text)
		pos    = 0

		while pos < end:
			m = self.tokrec.match (text, pos)

			if m is None:
				tokens.append (Token ('$err', text [pos], pos))

				break

			else:
				if m.lastgroup != 'ignore':
					tok  = m.lastgroup
					s, e = self.tokgrps [tok]
					grps = m.groups () [s : e]

					tokens.append (Token (tok, grps [0], pos, grps [1:]))

				pos += len (m.group (0))

		tokens.append (Token ('$end', '', pos))

		return tokens

	#...............................................................................................
	def parse_getextrastate (self):
		return None

	def parse_setextrastate (self, state):
		pass

	def parse_error (self):
		return False # True if state fixed to continue parsing, False to fail

	def parse_success (self, red):
		'NO PARSE_SUCCESS'
		return None # True to contunue checking conflict backtracks, False to stop and return

	def parse (self, src):
		has_parse_success = (self.parse_success.__doc__ != 'NO PARSE_SUCCESS')

		rules, terms, nterms, rfuncs = self.rules, self.terms, self.nterms, self.rfuncs

		tokens = self.tokenize (src)
		tokidx = 0
		cstack = [] # [(action, tokidx, stack, stidx, extra state), ...] # conflict backtrack stack
		stack  = [State (0, None, None)] # [(stidx, symbol, reduction) or (stidx, token), ...]
		stidx  = 0
		rederr = None # reduction function raised exception (SyntaxError or Incomplete)

		while 1:
			if not rederr:
				tok       = tokens [tokidx]
				act, conf = terms [stidx].get (tok, (None, None))

			if rederr or act is None:
				self.tokens, self.tokidx, self.cstack, self.stack, self.stidx, self.tok, self.rederr = \
						tokens, tokidx, cstack, stack, stidx, tok, rederr

				rederr = None

				if tok == '$end' and stidx == 1 and len (stack) == 2 and stack [1] [1] == rules [0] [1]:
					if not has_parse_success:
						return stack [1].red

					if not self.parse_success (stack [1].red) or not cstack:
						return None

				elif self.parse_error ():
					tokidx, stidx = self.tokidx, self.stidx

					continue

				elif not cstack:
					if has_parse_success: # do not raise SyntaxError if parser relies on parse_success
						return None

					# if self.rederr is not None: # THIS IS COMMENTED OUT BECAUSE IS NOT USED HERE AND PYLINT DOESN'T LIKE IT!
					# 	raise self.rederr # re-raise exception from last reduction function if present

					raise SyntaxError ( \
						'unexpected end of input' if tok == '$end' else \
						f'invalid token {tok.text!r}' if tok == '$err' else \
						f'invalid syntax {src [tok.pos : tok.pos + 16]!r}')

				act, tokens, tokidx, stack, stidx, estate = cstack.pop ()
				tok                                       = tokens [tokidx]

				self.parse_setextrastate (estate)

			elif conf is not None:
				cstack.append ((conf, tokens [:], tokidx, stack [:], stidx, self.parse_getextrastate ()))

			if act > 0:
				tokidx += 1
				stidx   = act

				stack.append (State (stidx, tok))

			else:
				rule  = rules [-act]
				rnlen = -len (rule [1])
				prod  = rule [0]

				try:
					red = rfuncs [-act] (*((t [-1] for t in stack [rnlen:]) if rnlen else ()))

				except SyntaxError as e:
					rederr = e or True # why did I do this?

					continue

				except Incomplete as e:
					rederr = e
					red    = e.red

				if rnlen:
					del stack [rnlen:]

				stidx = nterms [stack [-1].idx] [prod]

				stack.append (State (stidx, prod, red))

class lalr1: # for single script
	Incomplete = Incomplete
	Token      = Token
	State      = State
	LALR1      = LALR1
# Base classes for abstract math syntax tree, tuple based.
#
# ('=', 'rel', lhs, rhs)                           - equality of type 'rel' relating Left-Hand-Side and Right-Hand-Side
# ('#', 'num')                                     - real numbers represented as strings to pass on maximum precision to sympy
# ('@', 'var')                                     - variable name, can take forms: 'x', "x'", 'dx', '\partial x', 'something'
# ('.', expr, 'name')                              - data member reference
# ('.', expr, 'name', (a1, a2, ...))               - method member call
# ('"', 'str')                                     - string
# (',', (expr1, expr2, ...))                       - comma expression (tuple)
# ('{', expr)                                      - invisible implicit parentheses for grouping and isolation during parsing
# ('(', expr)                                      - explicit parentheses (not tuple)
# ('[', (expr1, expr2, ...))                       - brackets (list, not index)
# ('|', expr)                                      - absolute value
# ('-', expr)                                      - negative of expression, negative numbers are represented with this at least initially
# ('!', expr)                                      - factorial
# ('+', (expr1, expr2, ...))                       - addition
# ('*', (expr1, expr2, ...))                       - multiplication
# ('/', numer, denom)                              - fraction numer(ator) / denom(inator)
# ('^', base, exp)                                 - power base ^ exp(onent)
# ('log', expr)                                    - natural logarithm of expr
# ('log', expr, base)                              - logarithm of expr in base
# ('sqrt', expr)                                   - square root of expr
# ('sqrt', expr, n)                                - nth root of expr
# ('func', 'name', (a1, a2, ...))                  - sympy or regular Python function 'name', will be called with expressions a1, a2, ...
# ('lim', expr, var, to)                           - limit of expr when variable var approaches to from both positive and negative directions
# ('lim', expr, var, to, 'dir')                    - limit of expr when variable var approaches to from specified direction dir which may be '+' or '-'
# ('sum', expr, var, from, to)                     - summation of expr over variable var from from to to
# ('diff', expr, (var1, ...))                      - differentiation of expr with respect to var1 and optional other vars
# ('intg', expr, var)                              - anti-derivative of expr (or 1 if expr is None) with respect to differential var ('dx', 'dy', etc ...)
# ('intg', expr, var, from, to)                    - definite integral of expr (or 1 if expr is None) with respect to differential var ('dx', 'dy', etc ...)
# ('vec', (e1, e2, ...))                           - vector
# ('mat', ((e11, e12, ...), (e21, e22, ...), ...)) - matrix
# ('piece', ((v1, c1), ..., (vn, True?)))          - piecewise expression: v = AST, c = condition AST, last condition may be True to catch all other cases
# ('lamb', expr, (v1, v2, ...))                    - lambda expression: v? = ('@', 'var')
# ('idx', expr, (i0, i1, ...))                     - indexing: expr [i0, i1, ...]
# ('slice', start, stop, step)                     - indexing slice object: obj [start : stop : step], None or False indicates not specified
# ('set', (expr1, expr2, ...))                     - set
# ('dict', ((k1, v1), (k2, v2), ...))              - python dict
# ('||', (expr1, expr2, ...))                      - bitwise or, set union
# ('^^', (expr1, expr2, ...))                      - bitwise xor, set symmetric difference
# ('&&', (expr1, expr2, ...))                      - bitwise and, set intersection

import re
import types

import sympy as sp

#...............................................................................................
class AST (tuple):
	op      = None

	OPS     = set () # these will be filled in after all classes defined
	CONSTS  = set ()

	_OP2CLS = {}
	_CLS2OP = {}

	_rec_identifier = re.compile (r'^[a-zA-Z_]\w*$')
	_rec_int        = re.compile (r'^-?\d+$')

	def __new__ (cls, *args):
		op       = AST._CLS2OP.get (cls)
		cls_args = tuple (AST (*arg) if arg.__class__ is tuple else arg for arg in args)

		if op:
			args = (op,) + cls_args

		elif args:
			args = cls_args

			try:
				cls2 = AST._OP2CLS.get (args [0])
			except TypeError: # for unhashable types
				cls2 = None

			if cls2:
				cls      = cls2
				cls_args = cls_args [1:]

		self = tuple.__new__ (cls, args)

		if self.op:
			self._init (*cls_args)

		return self

	def __getattr__ (self, name): # calculate value for nonexistent self.name by calling self._name () and store
		func                 = getattr (self, f'_{name}') if name [0] != '_' else None
		val                  = func and func ()
		self.__dict__ [name] = val

		return val

	def _is_single_unit (self): # is single positive digit, fraction or single non-differential non-subscripted non-primed variable?
		if self.op == '/':
			return True
		elif self.op == '#':
			return len (self.num) == 1
		else:
			return self.is_single_var

	def _len (self):
		return len (self)

	def _no_curlys (self):
		if self.is_curly:
			return self.curly.no_curlys
		else:
			return AST (*tuple (a.no_curlys if isinstance (a, AST) else a for a in self))

	def flat (self, op = None, seq = None): # flatten trees of '+' or '*' into single AST
		if self.is_add or self.is_mul:
			if self.op == op:
				for e in self [1]:
					e.flat (op, seq)

				return

			seq2 = []

			for e in self [1]:
				e.flat (self.op, seq2)

			ast = AST (self.op, tuple (seq2))

		else:
			ast = AST (*tuple (a.flat () if isinstance (a, AST) else a for a in self))

		if op:
			seq.append (ast)
		else:
			return ast

	def neg (self, stack = False): # stack means stack negatives ('-', ('-', ('#', '-1')))
		if stack:
			if not self.is_pos_num:
				return AST ('-', self)
			else:
				return AST ('#', f'-{self.num}')

		else:
			if self.is_minus:
				return self.minus
			elif not self.is_num:
				return AST ('-', self)
			elif self.num [0] == '-':
				return AST ('#', self.num [1:])
			else:
				return AST ('#', f'-{self.num}')

	def strip (self, count = None, ops = {'{', '('}, idx = 1, keeptuple = False):
		count = -1 if count is None else count

		while count and self.op in ops and not (keeptuple and self [idx].is_comma):
			self   = self [idx]
			count -= 1

		return self

	strip_attr   = lambda self, count = None: self.strip (count, ('.',))
	strip_curlys = lambda self, count = None: self.strip (count, ('{',))
	strip_paren  = lambda self, count = None, keeptuple = False: self.strip (count, ('(',), keeptuple = keeptuple)

	def strip_minus (self, count = None, retneg = False):
		count       = -1 if count is None else count
		neg         = lambda ast: ast
		neg.has_neg = False
		neg.is_neg  = False

		while self.is_minus and count:
			self         = self.minus
			count       -= 1
			is_neg       = neg.is_neg
			neg          = lambda ast, neg = neg: neg (ast.neg (stack = True))
			neg.has_neg  = True
			neg.is_neg   = not is_neg

		return (self, neg) if retneg else self

	def strip_mls (self, count = None): # mls = mul, lim, sum
		count = -1 if count is None else count

		while self.op in {'*', 'lim', 'sum'} and count:
			self   = self.mul [-1] if self.is_mul else self [1]
			count -= 1

		return self

	def as_identifier (self, top = True):
		if self.op in {'#', '@', '"'}:
			name = self [1]
		elif not self.is_mul:
			return None

		else:
			try:
				name = ''.join (m.as_identifier () for m in self.mul)
			except TypeError:
				return None

		return name if AST._rec_identifier.match (name) else None

	def free_vars (self): # return set of unique unbound variables found in tree
		def _free_vars (ast, vars):
			if isinstance (ast, AST):
				if ast.is_const_var is False and ast.var:
					vars.add (ast)

				for e in ast:
					_free_vars (e, vars)

		vars = set ()

		_free_vars (self, vars)

		return vars

	@staticmethod
	def tuple2ast (args, paren = False):
		return args [0] if len (args) == 1 else AST ('(', (',', args)) if paren else AST (',', args)

	@staticmethod
	def args2kwargs (args, func = None):
		func  = (lambda x: x) if func is None else func
		rargs = []
		kw    = {}
		itr   = reversed (args)

		for arg in itr:
			if arg.is_ass:
				ident = arg.lhs.as_identifier ()

				if ident is not None:
					kw [ident] = func (arg.rhs)

					continue

			rargs = [func (arg)] + [func (arg) for arg in itr]

		return rargs [::-1], kw

	@staticmethod
	def is_int_text (text):
		return AST._rec_int.match (text)

	@staticmethod
	def flatcat (op, ast0, ast1): # ,,,/O.o\,,,~~
		if ast0.op == op:
			if ast1.op == op:
				return AST (op, ast0 [-1] + ast1 [-1])
			else:
				return AST (op, ast0 [-1] + (ast1,))

		else: # ast0.op != op
			if ast1.op == op:
				return AST (op, (ast0,) + ast1 [-1])
			else:
				return AST (op, (ast0, ast1))

	@staticmethod
	def register_AST (cls):
		AST._CLS2OP [cls]    = cls.op
		AST._OP2CLS [cls.op] = cls

		AST.OPS.add (cls.op)

		setattr (AST, cls.__name__ [4:], cls)

	@staticmethod
	def EI (state = True):
		AST.CONSTS.difference_update ((AST.E, AST.I))

		AST.E, AST.I = (AST ('@', 'E'), AST ('@', 'I')) if state else (AST ('@', 'e'), AST ('@', 'i'))

		AST.CONSTS.update ((AST.E, AST.I))

#...............................................................................................
class AST_Eq (AST):
	op, is_eq  = '=', True

	TEX2PY = {'\\ne': '!=', '\\le': '<=', '\\ge': '>=', '\\lt': '<', '\\gt': '>', '\\neq': '!=', '\\in': 'in', '\\notin': 'notin'}
	UNI2PY = {'\u2260': '!=', '\u2264': '<=', '\u2265': '>=', '\u2208': 'in', '\u2209': 'notin'}
	ANY2PY = {**UNI2PY, **TEX2PY}
	PY2TEX = {'!=': '\\ne', '<=': '\\le', '>=': '\\ge', 'in': '\\in', 'notin': '\\notin'}
	PYFMT  = {'notin': 'not in'}

	def _init (self, rel, lhs, rhs):
		self.rel, self.lhs, self.rhs = rel, lhs, rhs # should be py form

	_is_ass = lambda self: self.rel == '='

class AST_Num (AST):
	op, is_num = '#', True

	_rec_num   = re.compile (r'^(-?)(\d*[^0.e])?(0*)(?:(\.)(0*)(\d*[^0e])?(0*))?(?:([eE])([+-]?)(\d+))?$') # -101000.000101000e+123 -> (-) (101) (000) (.) (000) (101) (000) (e) (+) (123)

	def _init (self, num):
		self.num = num

	_grp              = lambda self: [g or '' for g in AST_Num._rec_num.match (self.num).groups ()]
	_is_pos_num       = lambda self: not self.grp [0]
	_is_neg_num       = lambda self: bool (self.grp [0])
	_is_int_num       = lambda self: not self.grp [3] and not self.grp [7] # self.num_exp_val >= -len (self.grp [2])
	_is_pos_int_num   = lambda self: self.is_int_num and not self.is_neg_num
	_num_exp          = lambda self: self.grp [8] + self.grp [9]
	_num_mant_and_exp = lambda self: (''.join (self.grp [:7]), self.num_exp)
	_num_exp_val      = lambda self: int (self.num_exp) if self.num_exp else 0
	_as_int           = lambda self: int (self.num)

class AST_Var (AST):
	op, is_var  = '@', True

	GREEK       = ('alpha', 'beta', 'gamma', 'delta', 'epsilon', 'zeta', 'eta', 'theta', 'iota', 'kappa', 'lambda', 'mu', 'nu', 'xi', 'pi', 'rho', 'sigma',
		'tau', 'upsilon', 'phi', 'chi', 'psi', 'omega', 'Gamma', 'Delta', 'Theta', 'Lambda', 'Xi', 'Pi', 'Sigma', 'Upsilon', 'Phi', 'Psi', 'Omega')
	GREEKUNI    = ('\u03b1', '\u03b2', '\u03b3', '\u03b4', '\u03b5', '\u03b6', '\u03b7', '\u03b8', '\u03b9', '\u03ba', '\u03bb', '\u03bc', '\u03bd', '\u03be', '\u03c0', '\u03c1', '\u03c3',
		'\u03c4', '\u03c5', '\u03c6', '\u03c7', '\u03c8', '\u03c9', '\u0393', '\u0394', '\u0398', '\u039b', '\u039e', '\u03a0', '\u03a3', '\u03a5', '\u03a6', '\u03a8', '\u03a9')

	PY2TEXMULTI = {
		'partial'  : ('\\partial',),
		'oo'       : ('\\infty',),
		'zoo'      : ('\\widetilde\\infty', '\\tilde\\infty', '\\overline\\infty', '\\bar\\infty'),
		'Reals'    : ('\\mathbb{R}',),
		'Complexes': ('\\mathbb{C}',),
		'Naturals' : ('\\mathbb{N}', '\\mathbb{N}^*', '\\mathbb{N}^+', '\\mathbb{N}_1', '\\mathbb{N}_{>0}', '\\mathbb{Z}^+'),
		'Naturals0': ('\\mathbb{N}_0', '\\mathbb{N}^0', '\\mathbb{Z}^{\\ge0}'),
		'Integers' : ('\\mathbb{Z}',),
	}

	PY2TEX      = {**dict ((g, f'\\{g}') for g in GREEK), **dict ((p, ts [0]) for p, ts in PY2TEXMULTI.items ())}
	TEX2PY      = {**dict ((f'\\{g}', g) for g in GREEK), **dict ((t, p) for p, ts in PY2TEXMULTI.items () for t in ts)}
	UNI2PY      = {**dict (zip (GREEKUNI, GREEK)), '\u2202': 'partial', '\u221e': 'oo'}
	ANY2PY      = {**UNI2PY, **TEX2PY}

	_rec_groups = re.compile (r"^(?:(?:(d(?!elta|partial))|(partial))(?!['\d]))?(.*)$")

	def _init (self, var):
		self.var = var

		if AST._rec_identifier.match (var):
			self.__dict__ [f'is_var_{var}'] = True

	_grp                  = lambda self: [g or '' for g in AST_Var._rec_groups.match (self.var).groups ()]
	_is_null_var          = lambda self: not self.var
	_is_long_var          = lambda self: len (self.var) > 1 and self.var not in AST_Var.PY2TEX
	_is_const_var         = lambda self: self in AST.CONSTS
	_is_nonconst_var      = lambda self: self not in AST.CONSTS
	_is_differential      = lambda self: self.grp [0] and self.grp [2]
	_is_diff_solo         = lambda self: self.grp [0] and not self.grp [2]
	_is_diff_any          = lambda self: self.grp [0]
	_is_partial           = lambda self: self.grp [1] and self.grp [2]
	_is_part_solo         = lambda self: self.grp [1] and not self.grp [2]
	_is_part_any          = lambda self: self.grp [1]
	_is_diff_or_part      = lambda self: (self.grp [0] or self.grp [1]) and self.grp [2]
	_is_diff_or_part_solo = lambda self: (self.grp [0] or self.grp [1]) and not self.grp [2]
	_is_diff_or_part_any  = lambda self: self.grp [0] or self.grp [1]
	_diff_or_part_type    = lambda self: self.grp [0] or self.grp [1] or '' # 'dx' -> 'd', 'partialx' -> 'partial', else ''
	_is_single_var        = lambda self: len (self.var) == 1 or self.var in AST_Var.PY2TEX # is single atomic variable (non-differential, non-subscripted, non-primed)?
	_as_var               = lambda self: AST ('@', self.grp [2]) if self.var else self # 'x', dx', 'partialx' -> 'x'
	_as_diff              = lambda self: AST ('@', f'd{self.grp [2]}') if self.var else self # 'x', 'dx', 'partialx' -> 'dx'

class AST_Attr (AST):
	op, is_attr = '.', True

	def _init (self, obj, attr, args = None):
		self.obj, self.attr, self.args = obj, attr, args

class AST_Str (AST):
	op, is_str = '"', True

	def _init (self, str_):
		self.str_ = str_

class AST_Comma (AST):
	op, is_comma = ',', True

	def _init (self, comma):
		self.comma = comma

	_is_empty_comma = lambda self: not (len (self.comma))

class AST_Curly (AST):
	op, is_curly = '{', True

	def _init (self, curly):
		self.curly = curly

class AST_Paren (AST):
	op, is_paren = '(', True

	def _init (self, paren):
		self.paren = paren

class AST_Brack (AST):
	op, is_brack = '[', True

	def _init (self, brack):
		self.brack = brack

class AST_Abs (AST):
	op, is_abs = '|', True

	def _init (self, abs):
		self.abs = abs

class AST_Minus (AST):
	op, is_minus = '-', True

	def _init (self, minus):
		self.minus = minus

class AST_Fact (AST):
	op, is_fact = '!', True

	def _init (self, fact):
		self.fact = fact

class AST_Add (AST):
	op, is_add = '+', True

	def _init (self, add):
		self.add = add

class AST_Mul (AST):
	op, is_mul = '*', True

	def _init (self, mul):
		self.mul = mul

	def _is_mul_has_abs (self):
		for m in self.mul:
			if m.is_abs:
				return True

class AST_Div (AST):
	op, is_div = '/', True

	def _init (self, numer, denom):
		self.numer, self.denom = numer, denom

class AST_Pow (AST):
	op, is_pow = '^', True

	def _init (self, base, exp):
		self.base, self.exp = base, exp

class AST_Log (AST):
	op, is_log = 'log', True

	def _init (self, log, base = None):
		self.log, self.base = log, base

class AST_Sqrt (AST):
	op, is_sqrt = 'sqrt', True

	def _init (self, rad, idx = None):
		self.rad, self.idx = rad, idx

class AST_Func (AST):
	op, is_func = 'func', True

	_SYMPY_OBJECTS  = dict ((name, obj) for name, obj in filter (lambda no: no [0] [0] != '_', sp.__dict__.items ()))
	_SYMPY_FUNCS    = set (no [0] for no in filter (lambda no: len (no [0]) > 1 and callable (no [1]), _SYMPY_OBJECTS.items ()))

	ESCAPE          = '$'
	NOREMAP         = '@'
	NOEVAL          = '%'

	ADMIN           = {'vars', 'funcs', 'del', 'delall', 'env', 'envreset', 'plotf', 'plotv', 'plotw'}
	PSEUDO          = {NOREMAP, NOEVAL}
	BUILTINS        = {'max', 'min', 'abs', 'pow', 'set', 'sum'}
	TEXNATIVE       = {'max', 'min', 'arg', 'deg', 'exp', 'gcd', 'Re', 'Im'}
	TRIGH           = {'sin', 'cos', 'tan', 'cot', 'sec', 'csc', 'sinh', 'cosh', 'tanh', 'coth', 'sech', 'csch'}

	PY_TRIGHINV     = {f'a{f}' for f in TRIGH}
	TEX_TRIGHINV    = {f'arc{f}' for f in TRIGH}
	TEX2PY_TRIGHINV = {f'arc{f}': f'a{f}' for f in TRIGH}

	PY              = ADMIN | BUILTINS | PY_TRIGHINV | TRIGH | _SYMPY_FUNCS - {'sqrt', 'log', 'ln', 'evaluate', 'beta', 'gamma', 'zeta', 'Lambda'}
	TEX             = TEXNATIVE | TEX_TRIGHINV | (TRIGH - {'sech', 'csch'})

	_rec_trigh        = re.compile (r'^a?(?:sin|cos|tan|csc|sec|cot)h?$')
	_rec_trigh_inv    = re.compile (r'^a(?:sin|cos|tan|csc|sec|cot)h?$')
	_rec_trigh_noninv = re.compile (r'^(?:sin|cos|tan|csc|sec|cot)h?$')

	def _init (self, func, args):
		self.func, self.args = func, args

		if AST._rec_identifier.match (func):
			self.__dict__ [f'is_func_{func}'] = True

	_is_trigh_func        = lambda self: AST_Func._rec_trigh.match (self.func)
	_is_trigh_func_inv    = lambda self: AST_Func._rec_trigh_inv.match (self.func)
	_is_trigh_func_noninv = lambda self: AST_Func._rec_trigh_noninv.match (self.func)
	_is_escaped           = lambda self: self.func [:1] == self.ESCAPE
	_unescaped            = lambda self: self.func.lstrip (self.ESCAPE)

class AST_Lim (AST):
	op, is_lim = 'lim', True

	def _init (self, lim, lvar, to, dir = None):
		self.lim, self.lvar, self.to, self.dir = lim, lvar, to, dir

class AST_Sum (AST):
	op, is_sum = 'sum', True

	def _init (self, sum, svar, from_, to):
		self.sum, self.svar, self.from_, self.to = sum, svar, from_, to

class AST_Diff (AST):
	op, is_diff = 'diff', True

	def _init (self, diff, dvs):
		self.diff, self.dvs = diff, dvs

	_diff_type = lambda self: '' if not self.dvs else self.dvs [0].diff_or_part_type if self.dvs [0].is_var else self.dvs [0].base.diff_or_part_type

class AST_Intg (AST):
	op, is_intg = 'intg', True

	def _init (self, intg, dv, from_ = None, to = None):
		self.intg, self.dv, self.from_, self.to = intg, dv, from_, to

class AST_Vec (AST):
	op, is_vec = 'vec', True

	def _init (self, vec):
		self.vec = vec

class AST_Mat (AST):
	op, is_mat = 'mat', True

	def _init (self, mat):
		self.mat = mat

	_rows = lambda self: len (self.mat)
	_cols = lambda self: len (self.mat [0]) if self.mat else 0

class AST_Piece (AST):
	op, is_piece = 'piece', True

	def _init (self, piece):
		self.piece = piece

class AST_Lamb (AST):
	op, is_lamb = 'lamb', True

	def _init (self, lamb, vars):
		self.lamb, self.vars = lamb, vars

class AST_Idx (AST):
	op, is_idx = 'idx', True

	def _init (self, obj, idx):
		self.obj, self.idx = obj, idx

class AST_Slice (AST):
	op, is_slice = 'slice', True

	def _init (self, start, stop, step):
		self.start, self.stop, self.step = start, stop, step

class AST_Set (AST):
	op, is_set = 'set', True

	def _init (self, set):
		self.set = set

class AST_Dict (AST):
	op, is_dict = 'dict', True

	def _init (self, dict):
		self.dict = dict

class AST_Union (AST):
	op, is_bor = '||', True

	def _init (self, union):
		self.union = union

class AST_Sdiff (AST): # symmetric difference
	op, is_bxor = '^^', True

	def _init (self, sdiff):
		self.sdiff = sdiff

class AST_Xsect (AST): # intersection
	op, is_band = '&&', True

	def _init (self, xsect):
		self.xsect = xsect

#...............................................................................................
_AST_CLASSES = [AST_Eq, AST_Num, AST_Var, AST_Attr, AST_Str, AST_Comma, AST_Curly, AST_Paren, AST_Brack,
	AST_Abs, AST_Minus, AST_Fact, AST_Add, AST_Mul, AST_Div, AST_Pow, AST_Log, AST_Sqrt, AST_Func, AST_Lim, AST_Sum,
	AST_Diff, AST_Intg, AST_Vec, AST_Mat, AST_Piece, AST_Lamb, AST_Idx, AST_Slice, AST_Set, AST_Dict,
	AST_Union, AST_Sdiff, AST_Xsect]

for _cls in _AST_CLASSES:
	AST.register_AST (_cls)

_AST_CONSTS = (('E', 'e'), ('I', 'i'), ('Pi', 'pi'), ('Infty', 'oo'), ('CInfty', 'zoo'), ('None_', 'None'), ('True_', 'True'), ('False_', 'False'), ('NaN', 'nan'),
	('Naturals', 'Naturals'), ('Naturals0', 'Naturals0'), ('Integers', 'Integers'), ('Reals', 'Reals'), ('Complexes', 'Complexes'))

for _vp, _vv in _AST_CONSTS:
	ast = AST ('@', _vv)

	AST.CONSTS.add (ast)
	setattr (AST, _vp, ast)

AST.Zero       = AST ('#', '0')
AST.One        = AST ('#', '1')
AST.NegOne     = AST ('#', '-1')
AST.VarNull    = AST ('@', '')
AST.CommaEmpty = AST (',', ())
AST.MatEmpty   = AST ('mat', ())
AST.SetEmpty   = AST ('set', ())
AST.DictEmpty  = AST ('dict', ())

# if __name__ == '__main__' and not _RUNNING_AS_SINGLE_SCRIPT: ## DEBUG!
# 	ast = AST ('*', (('*', (('@', 'x'), ('@', 'd'))), ('@', 'y')))
# 	res = ast.flat ()
# 	print (res)
# AST translations for display or S escaping.


#...............................................................................................
def _xlat_func2ast_Derivative (ast = AST.VarNull, *dvs):
	ds = []

	if not dvs:
		vars = ast.free_vars ()

		if len (vars) == 1:
			ds = [AST ('@', f'd{vars.pop ().var}')]

	else:
		dvs = list (dvs [::-1])

		while dvs:
			v = dvs.pop ()

			if not v.is_var:
				return None
			elif dvs and dvs [-1].is_pos_int_num:
				ds.append (AST ('^', ('@', f'd{v.var}'), dvs.pop ()))
			else:
				ds.append (AST ('@', f'd{v.var}'))

	return AST ('diff', ast, tuple (ds))

def _xlat_func2ast_Integral (ast = None, dvab = None, *args):
	if ast is None:
		return AST ('intg', AST.VarNull, AST.VarNull)

	if dvab is None:
		vars = ast.free_vars ()

		if len (vars) == 1:
			return AST ('intg', ast, ('@', f'd{vars.pop ().var}'))

		return AST ('intg', AST.VarNull, AST.VarNull)

	dvab = dvab.strip_paren ()
	ast2 = None

	if dvab.is_comma:
		if dvab.comma and dvab.comma [0].is_nonconst_var:
			if dvab.comma.len == 1:
				ast2 = AST ('intg', ast, ('@', f'd{dvab.comma [0].var}'))
			elif dvab.comma.len == 2:
				ast2 = AST ('intg', ast, ('@', f'd{dvab.comma [0].var}'), AST.Zero, dvab.comma [1])
			elif dvab.comma.len == 3:
				ast2 = AST ('intg', ast, ('@', f'd{dvab.comma [0].var}'), dvab.comma [1], dvab.comma [2])

	elif dvab.is_var:
		ast2 = AST ('intg', ast, ('@', f'd{dvab.var}'))

	if ast2 is None:
		return None

	return _xlat_func2ast_Integral (ast2, *args) if args else ast2

_xlat_func2ast_Limit_dirs = {AST ('"', '+'): ('+',), AST ('"', '-'): ('-',), AST ('"', '+-'): ()}

def _xlat_func2ast_Lambda (args, expr):
	args = args.strip_paren ()
	args = args.comma if args.is_comma else (args,)

	return AST ('lamb', expr, args)

def _xlat_func2ast_Limit (ast = AST.VarNull, var = AST.VarNull, to = AST.VarNull, dir = AST ('"', '+')):
	return AST ('lim', ast, var, to, *_xlat_func2ast_Limit_dirs [dir])

def _xlat_func2ast_Pow (ast = AST.VarNull, exp = AST.VarNull):
	return AST ('^', ast, exp)

def _xlat_func2ast_Matrix (ast = AST.VarNull):
	if ast.is_null_var:
		return AST ('vec', ())

	if ast.is_brack and ast.brack:
		if not ast.brack [0].is_brack: # single layer or brackets, column matrix?
			return AST ('vec', ast.brack)

		elif ast.brack [0].brack:
			rows = [ast.brack [0].brack]
			cols = len (rows [0])

			for row in ast.brack [1 : -1]:
				if len (row.brack) != cols:
					break

				rows.append (row.brack)

			else:
				l = len (ast.brack [-1].brack)

				if l <= cols:
					if len (ast.brack) > 1:
						rows.append (ast.brack [-1].brack + (AST.VarNull,) * (cols - l))

					if l != cols:
						return AST ('mat', tuple (rows))
					elif cols > 1:
						return AST ('mat', tuple (rows))
					else:
						return AST ('vec', tuple (r [0] for r in rows))

	return None

def _xlat_func2ast_Piecewise (*args):
	pcs = []

	if not args or args [0].is_null_var:
		return AST ('piece', ((AST.VarNull, AST.VarNull),))

	if len (args) > 1:
		for c in args [:-1]:
			c = c.strip ()

			if not c.is_comma or len (c.comma) != 2:
				return None

			pcs.append (c.comma)

	ast = args [-1]

	if not ast.is_paren:
		return None

	ast = ast.strip ()
	pcs = tuple (pcs)

	if not ast.is_comma:
		return AST ('piece', pcs + ((ast, AST.VarNull),))
	elif len (ast.comma) == 0:
		return AST ('piece', pcs + ())

	if not ast.comma [0].is_comma:
		if len (ast.comma) == 1:
			return AST ('piece', pcs + ((ast.comma [0], AST.VarNull),))
		elif len (ast.comma) == 2:
			return AST ('piece', pcs + ((ast.comma [0], True if ast.comma [1] == AST.True_ else ast.comma [1]),))

	return None

def _xlat_func2ast_set (*args):
	if not args:
		return AST.SetEmpty

	arg = args [0].strip_paren ()

	if arg.op in {',', '[', 'vec', 'set'}:
		return AST ('set', tuple (arg [1]))

	return None

def _xlat_func2ast_Sum (ast = AST.VarNull, ab = None):
	if ab is None:
		return AST ('sum', ast, AST.VarNull, AST.VarNull, AST.VarNull)

	ab = ab.strip_paren ()

	if ab.is_var:
		return AST ('sum', ast, ab, AST.VarNull, AST.VarNull)
	elif ab.is_comma and ab.comma and ab.comma.len <= 3 and ab.comma [0].is_var:
		return AST ('sum', ast, *ab.comma, *((AST.VarNull,) * (3 - ab.comma.len)))

	return None

_XLAT_FUNC2AST_BASE = {
	'abs'                  : lambda ast: AST ('|', ast),
	'Abs'                  : lambda ast: AST ('|', ast),
	'Complement'           : lambda *args: AST ('+', (args [0], ('-', args [1]))),
	'Derivative'           : _xlat_func2ast_Derivative,
	'diff'                 : _xlat_func2ast_Derivative,
	'EmptySet'             : lambda *args: AST.SetEmpty,
	'exp'                  : lambda ast: AST ('^', AST.E, ast),
	'factorial'            : lambda ast: AST ('!', ast),
	'FiniteSet'            : lambda *args: AST ('set', tuple (args)),
	'Integral'             : _xlat_func2ast_Integral,
	'integrate'            : _xlat_func2ast_Integral,
	'Intersection'         : lambda *args: AST ('&&', tuple (args)),
	'Lambda'               : _xlat_func2ast_Lambda,
	'Limit'                : _xlat_func2ast_Limit,
	'limit'                : _xlat_func2ast_Limit,
	'Matrix'               : _xlat_func2ast_Matrix,
	'MutableDenseMatrix'   : _xlat_func2ast_Matrix,
	'Piecewise'            : _xlat_func2ast_Piecewise,
	'Pow'                  : _xlat_func2ast_Pow,
	'pow'                  : _xlat_func2ast_Pow,
	'Sum'                  : _xlat_func2ast_Sum,
	'Tuple'                : lambda *args: AST ('(', (',', args)),
	'Union'                : lambda *args: AST ('||', tuple (args)),
}

_XLAT_FUNC2AST_REIM = {
	'Re'                   : lambda *args: AST ('func', 're', tuple (args)),
	'Im'                   : lambda *args: AST ('func', 'im', tuple (args)),
}

XLAT_FUNC2AST_TEX = {**_XLAT_FUNC2AST_BASE,
	'SparseMatrix'         : _xlat_func2ast_Matrix,
	'MutableSparseMatrix'  : _xlat_func2ast_Matrix,
	'ImmutableDenseMatrix' : _xlat_func2ast_Matrix,
	'ImmutableSparseMatrix': _xlat_func2ast_Matrix,
	'diag'                 : True,
	'eye'                  : True,
	'ones'                 : True,
	'zeros'                : True,
}

XLAT_FUNC2AST_NAT = {**_XLAT_FUNC2AST_REIM, **_XLAT_FUNC2AST_BASE}

XLAT_FUNC2AST_PY  = {**_XLAT_FUNC2AST_REIM,
	'Gamma'                : lambda *args: AST ('func', 'gamma', tuple (args)),
}

def xlat_funcs2asts (ast, xlat, func_call = None): # translate eligible functions in tree to other AST representations
	if not isinstance (ast, AST):
		return ast

	if ast.is_func:
		xact = xlat.get (ast.func)

		if xact is not None:
			args = AST (*(xlat_funcs2asts (arg, xlat, func_call = func_call) for arg in ast.args))

			try:
				if xact is True: # True means execute function and use return value for ast
					return func_call (ast.func, args)

				xargs, xkw = AST.args2kwargs (args)
				ast2       = xact (*xargs, **xkw)

				if ast2 is not None:
					return ast2

			except:
				pass

			return AST ('func', ast.func, args)

	return AST (*(xlat_funcs2asts (e, xlat, func_call = func_call) for e in ast))

#...............................................................................................
def _xlat_func2tex_Subs (ast2tex, ast, vars, subs):
	vars = vars.strip_paren ()
	subs = subs.strip_paren ()

	if vars.is_comma and subs.is_comma and vars.comma.len == subs.comma.len:
		asss = ' \\\\ '.join (f'{ast2tex (v)}={ast2tex (s)}' for v, s in zip (vars.comma, subs.comma))

		return f'\\left. {ast2tex (ast)} \\right|_{{\\substack{{{asss}}}}}'

	return f'\\left. {ast2tex (ast)} \\right|_{{{ast2tex (vars)}={ast2tex (subs)}}}'

_XLAT_FUNC2TEX = {
	'beta'    : lambda ast2tex, *args: f'\\beta\\left({ast2tex (AST.tuple2ast (args))} \\right)',
	'gamma'   : lambda ast2tex, *args: f'\\Gamma\\left({ast2tex (AST.tuple2ast (args))} \\right)',
	'Gamma'   : lambda ast2tex, *args: f'\\Gamma\\left({ast2tex (AST.tuple2ast (args))} \\right)',
	'Lambda'  : lambda ast2tex, *args: f'\\Lambda\\left({ast2tex (AST.tuple2ast (args))} \\right)',
	'zeta'    : lambda ast2tex, *args: f'\\zeta\\left({ast2tex (AST.tuple2ast (args))} \\right)',

	'binomial': lambda ast2tex, *args: f'\\binom{{{ast2tex (args [0])}}}{{{ast2tex (args [1])}}}' if len (args) == 2 else None,
	're'      : lambda ast2tex, *args: f'\\Re\\left({ast2tex (AST.tuple2ast (args))} \\right)',
	'im'      : lambda ast2tex, *args: f'\\Im\\left({ast2tex (AST.tuple2ast (args))} \\right)',
	'Subs'    : _xlat_func2tex_Subs,
}

_XLAT_ATTRFUNC2TEX = {
	'subs'    : _xlat_func2tex_Subs,
}

def xlat_func2tex (ast, ast2tex):
	xact = _XLAT_FUNC2TEX.get (ast.func)

	if xact:
		try:
			return xact (ast2tex, *ast.args)
		except:
			pass

	return None

def xlat_attr2tex (ast, ast2tex):
	if ast.args is None:
		return None

	xact = _XLAT_ATTRFUNC2TEX.get (ast.attr)

	if xact:
		try:
			return xact (ast2tex, ast.obj, *ast.args)
		except:
			pass

	return None

#...............................................................................................
def _xlat_pyS (ast, need = False): # Python S(1)/2 escaping where necessary
	if not isinstance (ast, AST):
		return ast, False

	if ast.is_num:
		if need:
			return AST ('func', 'S', (ast,)), True
		else:
			return ast, False

	if ast.is_comma or ast.is_brack:
		return AST (ast.op, tuple (_xlat_pyS (a) [0] for a in ast [1])), False

	if ast.is_curly or ast.is_paren or ast.is_minus:
		expr, has = _xlat_pyS (ast [1], need)

		return AST (ast.op, expr), has

	if ast.is_add or ast.is_mul:
		es  = [_xlat_pyS (a) for a in ast [1] [1:]]
		has = any (e [1] for e in es)
		e0  = _xlat_pyS (ast [1] [0], need and not has)

		return AST (ast.op, (e0 [0],) + tuple (e [0] for e in es)), has or e0 [1]

	if ast.is_div:
		denom, has = _xlat_pyS (ast.denom)
		numer      = _xlat_pyS (ast.numer, not has) [0]

		return AST ('/', numer, denom), True

	if ast.is_pow:
		exp, has = _xlat_pyS (ast.exp)
		base     = _xlat_pyS (ast.base, not (has or exp.is_pos_num)) [0]

		return AST ('^', base, exp), True

	es = [_xlat_pyS (a) for a in ast]

	return AST (*tuple (e [0] for e in es)), \
			ast.op in {'=', '@', '.', '|', '!', 'log', 'sqrt', 'func', 'lim', 'sum', 'diff', 'intg', 'vec', 'mat', 'piece', 'lamb'} or any (e [1] for e in es)

xlat_pyS = lambda ast: _xlat_pyS (ast) [0]

#...............................................................................................
class sxlat: # for single script
	XLAT_FUNC2AST_TEX = XLAT_FUNC2AST_TEX
	XLAT_FUNC2AST_NAT = XLAT_FUNC2AST_NAT
	XLAT_FUNC2AST_PY  = XLAT_FUNC2AST_PY
	xlat_funcs2asts   = xlat_funcs2asts
	xlat_func2tex     = xlat_func2tex
	xlat_attr2tex     = xlat_attr2tex
	xlat_pyS          = xlat_pyS

# if __name__ == '__main__' and not _RUNNING_AS_SINGLE_SCRIPT: ## DEBUG!
# 	ast = AST ('(', (',', (('#', '1'), ('#', '2'))))
# 	res = XLAT_FUNC2AST_NAT ['set'] (ast)
# 	print (res)
# Convert between internal AST and SymPy expressions and write out LaTeX, native shorthand and Python code.
# Here be dragons!

from ast import literal_eval
from functools import reduce
import re
import sympy as sp


_SYMPY_FLOAT_PRECISION = None
_USER_FUNCS            = {} # dict user funcs {name: AST, ...}
_POST_SIMPLIFY         = True # post-evaluation simplification
_PYS                   = True # Python S() escaping
_EVAL                  = True # expression evaluation via 'evaluate' flag
_DOIT                  = True # expression doit()

class AST_Text (AST): # for displaying elements we do not know how to handle, only returned from SymPy processing, not passed in
	op = 'text'

	def _init (self, tex = None, nat = None, py = None, spt = None):
		self.tex, self.nat, self.py, self.spt = tex, nat, py, spt

AST.register_AST (AST_Text)

class EqAss (sp.Eq): # assignment instead of equality comparison
	pass

class ExprNoEval (sp.Expr): # prevent any kind of evaluation on AST on instantiation or doit, args = (str (AST), sp.S.One)
	is_number  = False
	SYMPAD_ast = lambda self: AST (*literal_eval (self.args [0]))

	def SYMPAD_eval (self):
		return self.SYMPAD_ast () if self.args [1] == 1 else AST ('func', AST.Func.NOEVAL, (self.SYMPAD_ast (), spt2ast (self.args [1] - 1)))

def _fltoint (num):
	return int (num) if isinstance (num, int) or num.is_integer () else num

def _Mul (*args, evaluate = True):
	if not evaluate:
		return sp.Mul (*args, evaluate = False)

	itr = iter (args)
	res = next (itr)

	for arg in itr:
		try:
			res = res * arg
		except:
			res = sp.sympify (res) * sp.sympify (arg)

	return res

def _Pow (base, exp, evaluate = True): # fix inconsistent sympy Pow (..., evaluate = True)
	return base**exp if evaluate else sp.Pow (base, exp, evaluate = False)

def _simplify (spt):
	if isinstance (spt, (bool, int, float, complex, str, slice)):
		return spt

	if isinstance (spt, (tuple, list, set, frozenset)):
		return spt.__class__ (_simplify (a) for a in spt)

	if isinstance (spt, dict):
		return dict ((_simplify (k), _simplify (v)) for k, v in spt.items ())

	try:
		spt = sp.simplify (spt)
	except:
		pass

	return spt

def _trail_comma (obj):
	return ',' if len (obj) == 1 else ''

def _ast_slice_bounds (ast, None_ = AST.VarNull):
	return tuple (a or None_ for a in ((ast.start, ast.stop) if ast.step is None else (ast.start, ast.stop, ast.step)))

def _ast_is_neg (ast):
	return ast.is_minus or ast.is_neg_num or (ast.is_mul and _ast_is_neg (ast.mul [0]))

def _ast_followed_by_slice (ast, seq):
	try:
		return seq [seq.index (ast) + 1].is_slice
	except:
		pass

	return False

_ast_func_call_spobjs = set (id (o) for o in sp.__dict__.values ()) # for testing to see if obj belongs to SymPy

def _ast_func_call (func, args, _ast2spt = None, is_escaped = False):
	if _ast2spt is None:
		_ast2spt = ast2spt

	pyargs, pykw = AST.args2kwargs (args, _ast2spt)
	spt          = None

	if id (func) in _ast_func_call_spobjs: # if SymPy object try applying 'evaluate' flag
		try:
			spt = func (*pyargs, **{'evaluate': _EVAL, **pykw})
		except: # (ValueError, TypeError, NameError, AttributeError, sp.OptionError): # maybe 'evaluate' keyword not supported?
			pass

	if spt is None:
		spt = func (*pyargs, **pykw)

	if type (spt) is func: # try to pass func name escaped status through SymPy object
		try:
			spt.SYMPAD_ESCAPED = is_escaped
		except (AttributeError, TypeError): # couldn't assign to Python object (probably because is built-in type or otherwise has no __dict__)
			pass

	return spt

#...............................................................................................
class ast2tex: # abstract syntax tree -> LaTeX text
	def __init__ (self): self.parent = self.ast = None # pylint medication
	def __new__ (cls, ast, xlat = True):
		def func_call (func, args):
			return spt2ast (_ast_func_call (getattr (sp, func), args))

		self         = super ().__new__ (cls)
		self.parents = [None]
		self.parent  = self.ast = AST ()

		if xlat:
			ast = sxlat.xlat_funcs2asts (ast, sxlat.XLAT_FUNC2AST_TEX, func_call = func_call)

		return self._ast2tex (ast)

	def _ast2tex (self, ast):
		self.parents.append (self.ast)

		self.parent = self.ast
		self.ast    = ast

		ast         = self._ast2tex_funcs [ast.op] (self, ast)

		del self.parents [-1]

		self.ast    = self.parent
		self.parent = self.parents [-1]

		return ast

	def _ast2tex_wrap (self, obj, curly = None, paren = None):
		s = self._ast2tex (obj) if isinstance (obj, AST) else str (obj)

		if (obj.op in paren) if isinstance (paren, set) else paren:
			return f'\\left({s} \\right)'

		if (obj.op in curly) if isinstance (curly, set) else curly:
			return f'{{{s}}}'

		return s

	def _ast2tex_curly (self, ast):
		return \
				f'{self._ast2tex (ast)}'     if ast.is_single_unit else \
				f'{{{self._ast2tex (ast)}}}' if not ast.is_comma else \
				f'{{\\left({self._ast2tex (ast)}\\right)}}'

	def _ast2tex_paren (self, ast, ops = {}):
		return self._ast2tex_wrap (ast, 0, not (ast.is_paren or (ops and ast.op not in ops)))

	def _ast2tex_paren_mul_exp (self, ast, ret_has = False, also = {'=', '+'}):
		if ast.is_mul:
			s, has = self._ast2tex_mul (ast, True)
		else:
			s, has = self._ast2tex (ast), ast.op in also

		s = self._ast2tex_wrap (s, 0, has)

		return (s, has) if ret_has else s

	def _ast2tex_eq_hs (self, ast, hs, lhs = True):
		return self._ast2tex_wrap (hs, 0, (hs.is_ass or (lhs and hs.op in {',', 'piece'})) if ast.is_ass else {'=', 'piece'})

	def _ast2tex_num (self, ast):
		m, e = ast.num_mant_and_exp

		return f'{m}{{e}}{{{e}}}' if e else m

	def _ast2tex_var (self, ast):
		if not ast.var:
			return '{}' # Null var

		v = ast.as_var.var
		p = ''

		while v [-6:] == '_prime':
			v, p = v [:-6], p + "'"

		n = v.replace ('_', '\\_')
		t = AST.Var.PY2TEX.get (n)

		return \
				f'{t or n}{p}'      if not ast.diff_or_part_type else \
				f'd{t or n}{p}'		  if ast.is_diff_any else \
				f'\\partial{p}'     if ast.is_part_solo else \
				f'\\partial{t}{p}'  if t else \
				f'\\partial {n}{p}' if n else \
				f'\\partial{p}'

	def _ast2tex_attr (self, ast):
		tex = sxlat.xlat_attr2tex (ast, self._ast2tex)

		if tex is not None:
			return tex

		a = ast.attr.replace ('_', '\\_')

		if ast.args is not None:
			a = f'\\operatorname{{{a}}}{self._ast2tex_paren (AST.tuple2ast (ast.args))}'

		return f'{self._ast2tex_paren (ast.obj, {"=", "#", ",", "-", "+", "*", "/", "lim", "sum", "intg", "piece", "||", "^^", "&&"})}.{a}'

	def _ast2tex_add (self, ast):
		return ' + '.join (self._ast2tex_wrap (n, \
				((n.strip_mls ().is_intg or (n.is_mul and n.mul [-1].strip_mls ().is_intg)) and n is not ast.add [-1]), \
				(n.op in ("piece") and n is not ast.add [-1]) or n.op in {'=', '||', '^^', '&&'})
				for n in ast.add).replace (' + -', ' - ')#.replace (' + {-', ' - {')

	def _ast2tex_mul (self, ast, ret_has = False):
		t   = []
		p   = None
		has = False

		for n in ast.mul:
			s = self._ast2tex_wrap (n, \
					(p and _ast_is_neg (n)) or (n.strip_mls ().is_intg and n is not ast.mul [-1]), \
					n.op in {'=', '+', '||', '^^', '&&'} or (n.is_piece and n is not ast.mul [-1]))

			if p and p.is_attr and s [:6] == '\\left(':
				s = self._ast2tex_wrap (s, 1)

			if p and (n.op in {'#', '[', '!', 'mat'} or n.is_null_var or p.op in {'lim', 'sum', 'diff', 'intg', 'mat'} or \
					_ast_is_neg (n) or \
					n.strip_paren ().is_comma or \
					(p.is_var_lambda and (self.parent.is_slice or (self.parent.is_comma and _ast_followed_by_slice (ast, self.parent.comma)))) or \
					(n.op in {'/', 'diff'} and p.op in {'#', '/'}) or \
					(n.is_paren and p.is_var and p.var in _USER_FUNCS) or \
					(n.is_attr and n.strip_attr ().strip_paren ().is_comma) or \
					(p.is_div and (p.numer.is_diff_or_part_solo or (p.numer.is_pow and p.numer.base.is_diff_or_part_solo))) or \
					(n.is_pow and (n.base.is_pos_num or n.base.strip_paren ().is_comma or n.base.is_brack)) or \
					(n.is_idx and (n.obj.op in {'[', 'idx'} or n.obj.strip_paren ().is_comma))):
				t.append (f' \\cdot {s}')
				has = True

			elif p and (p.op in {'sqrt'} or p.num_exp or \
					p.strip_minus ().is_diff_or_part_any or n.is_diff_or_part_any or \
					(p.is_long_var and n.op not in {'(', '['}) or (n.is_long_var and p.op not in {'(', '['})):
				t.append (f'\\ {s}')

			else:
				t.append (f'{"" if not p else " "}{s}')

			p = n

		return (''.join (t), has) if ret_has else ''.join (t)

	def _ast2tex_pow (self, ast, trighpow = True):
		b = self._ast2tex_wrap (ast.base, {'mat'}, not (ast.base.op in {'@', '"', '(', '[', '|', 'func', 'mat', 'lamb', 'set', 'dict'} or ast.base.is_pos_num))
		p = self._ast2tex_curly (ast.exp)

		if ast.base.is_trigh_func_noninv and ast.exp.is_single_unit and trighpow:
			i = len (ast.base.func) + (15 if ast.base.func in {'sech', 'csch'} else 1)

			return f'{b [:i]}^{p}{b [i:]}'

		return f'{b}^{p}'

	def _ast2tex_log (self, ast):
		return \
				f'\\ln{self._ast2tex_paren (ast.log)}' \
				if ast.base is None else \
				f'\\log_{self._ast2tex_curly (ast.base)}{self._ast2tex_paren (ast.log)}'

	def _ast2tex_func (self, ast):
		if ast.is_trigh_func:
			n = (f'\\operatorname{{{ast.func [1:]}}}^{{-1}}' \
					if ast.func in {'asech', 'acsch'} else \
					f'\\{ast.func [1:]}^{{-1}}') \
					if ast.func [0] == 'a' else \
					(f'\\operatorname{{{ast.func}}}' if ast.func in {'sech', 'csch'} else f'\\{ast.func}')

			return f'{n}\\left({self._ast2tex (AST.tuple2ast (ast.args))} \\right)'

		tex = sxlat.xlat_func2tex (ast, self._ast2tex)

		if tex is not None:
			return tex

		if ast.func in AST.Func.TEX:
			return f'\\{ast.func}\\left({self._ast2tex (AST.tuple2ast (ast.args))} \\right)'
		else:
			return '\\operatorname{' + ast.func.replace ('_', '\\_').replace (AST.Func.NOEVAL, '\\%') + f'}}\\left({self._ast2tex (AST.tuple2ast (ast.args))} \\right)'

	def _ast2tex_lim (self, ast):
		s = self._ast2tex (ast.to) if ast.dir is None else (self._ast2tex_pow (AST ('^', ast.to, AST.Zero), trighpow = False) [:-1] + ast.dir)

		return f'\\lim_{{{self._ast2tex (ast.lvar)} \\to {s}}} {self._ast2tex_paren_mul_exp (ast.lim)}'

	def _ast2tex_sum (self, ast):
		return f'\\sum_{{{self._ast2tex (ast.svar)} = {self._ast2tex (ast.from_)}}}^{self._ast2tex_curly (ast.to)} {self._ast2tex_paren_mul_exp (ast.sum)}' \

	_rec_diff_var_single_start = re.compile (r'^d(?=[^_])')

	def _ast2tex_diff (self, ast):
		ds = set ()
		p  = 0

		for n in ast.dvs:
			if n.is_var:
				p += 1

				if n.var:
					ds.add (n)

			else: # n = ('^', ('@', 'diff or part'), ('#', 'int'))
				p += n.exp.as_int
				ds.add (n.base)

		if not ds:
			return f'\\frac{{d}}{{}}{self._ast2tex_paren (ast.diff)}'

		dv = next (iter (ds))

		if len (ds) == 1 and not dv.is_partial:
			return f'\\frac{{d{"" if p == 1 else f"^{p}"}}}{{{" ".join (self._ast2tex (n) for n in ast.dvs)}}}{self._ast2tex_paren (ast.diff)}'

		else:
			s = ''.join (self._rec_diff_var_single_start.sub (r'\\partial ', self._ast2tex (n)) for n in ast.dvs)

			return f'\\frac{{\\partial{"" if p == 1 else f"^{p}"}}}{{{s}}}{self._ast2tex_paren (ast.diff)}'

	def _ast2tex_intg (self, ast):
		if ast.from_ is None:
			return \
					f'\\int \\ {self._ast2tex (ast.dv)}' \
					if ast.intg is None else \
					f'\\int {self._ast2tex_wrap (ast.intg, {"diff"}, {"="})} \\ {self._ast2tex (ast.dv)}'
		else:
			return \
					f'\\int_{self._ast2tex_curly (ast.from_)}^{self._ast2tex_curly (ast.to)} \\ {self._ast2tex (ast.dv)}' \
					if ast.intg is None else \
					f'\\int_{self._ast2tex_curly (ast.from_)}^{self._ast2tex_curly (ast.to)} {self._ast2tex_wrap (ast.intg, {"diff"}, {"="})} \\ {self._ast2tex (ast.dv)}'

	_ast2tex_funcs = {
		'='    : lambda self, ast: f'{self._ast2tex_eq_hs (ast, ast.lhs)} {AST.Eq.PY2TEX.get (ast.rel, ast.rel)} {self._ast2tex_eq_hs (ast, ast.rhs, False)}',
		'#'    : _ast2tex_num,
		'@'    : _ast2tex_var,
		'.'    : _ast2tex_attr,
		'"'    : lambda self, ast: f'\\text{{{repr (ast.str_)}}}',
		','    : lambda self, ast: f'{", ".join (self._ast2tex (c) for c in ast.comma)}{_trail_comma (ast.comma)}',
		'('    : lambda self, ast: self._ast2tex_wrap (ast.paren, 0, not ast.paren.is_lamb),
		'['    : lambda self, ast: f'\\left[{", ".join (self._ast2tex (b) for b in ast.brack)} \\right]',
		'|'    : lambda self, ast: f'\\left|{self._ast2tex (ast.abs)} \\right|',
		'-'    : lambda self, ast: f'-{self._ast2tex_wrap (ast.minus, ast.minus.is_pos_num or ast.minus.is_mul, {"=", "+", "||", "^^", "&&"})}',
		'!'    : lambda self, ast: self._ast2tex_wrap (ast.fact, {'^'}, (ast.fact.op not in {'#', '@', '"', '(', '|', '!', '^', 'vec', 'mat'} or ast.fact.is_neg_num)) + '!',
		'+'    : _ast2tex_add,
		'*'    : _ast2tex_mul,
		'/'    : lambda self, ast: f'\\frac{{{self._ast2tex_wrap (ast.numer, 0, (ast.numer.base.is_diff_or_part_solo and ast.numer.exp.is_pos_int_num) if ast.numer.is_pow else ast.numer.is_diff_or_part_solo)}}}{{{self._ast2tex (ast.denom)}}}',
		'^'    : _ast2tex_pow,
		'log'  : _ast2tex_log,
		'sqrt' : lambda self, ast: f'\\sqrt{{{self._ast2tex_wrap (ast.rad, 0, {","})}}}' if ast.idx is None else f'\\sqrt[{self._ast2tex (ast.idx)}]{{{self._ast2tex_wrap (ast.rad, 0, {","})}}}',
		'func' : _ast2tex_func,
		'lim'  : _ast2tex_lim,
		'sum'  : _ast2tex_sum,
		'diff' : _ast2tex_diff,
		'intg' : _ast2tex_intg,
		'vec'  : lambda self, ast: '\\begin{bmatrix} ' + r' \\ '.join (self._ast2tex (e) for e in ast.vec) + ' \\end{bmatrix}',
		'mat'  : lambda self, ast: '\\begin{bmatrix} ' + r' \\ '.join (' & '.join (self._ast2tex (e) for e in row) for row in ast.mat) + f'{" " if ast.mat else ""}\\end{{bmatrix}}',
		'piece': lambda self, ast: '\\begin{cases} ' + r' \\ '.join (f'{self._ast2tex_wrap (p [0], 0, {"=", ","})} & \\text{{otherwise}}' if p [1] is True else f'{self._ast2tex_wrap (p [0], 0, {"=", ","})} & \\text{{for}}\\: {self._ast2tex (p [1])}' for p in ast.piece) + ' \\end{cases}',
		'lamb' : lambda self, ast: f'\\left({self._ast2tex (ast.vars [0] if len (ast.vars) == 1 else AST ("(", (",", ast.vars)))} \\mapsto {self._ast2tex_wrap (ast.lamb, 0, ast.lamb.is_ass)} \\right)',
		'idx'  : lambda self, ast: f'{self._ast2tex_wrap (ast.obj, {"^"}, ast.obj.is_neg_num or ast.obj.op in {"=", ",", "-", "+", "*", "/", "lim", "sum", "diff", "intg", "piece", "lamb", "||", "^^", "&&"})}\\left[{self._ast2tex (AST.tuple2ast (ast.idx))} \\right]',
		'slice': lambda self, ast: '{:}'.join (self._ast2tex_wrap (a, a and _ast_is_neg (a), a and (a.is_ass or a.op in {',', 'lamb', 'slice'})) for a in _ast_slice_bounds (ast, '')),
		'set'  : lambda self, ast: f'\\left\\{{{", ".join (self._ast2tex (c) for c in ast.set)} \\right\\}}' if ast.set else '\\emptyset',
		'dict' : lambda self, ast: f'\\left\\{{{", ".join (f"{self._ast2tex (k)}{{:}} {self._ast2tex (v)}" for k, v in ast.dict)} \\right\\}}',
		'||'   : lambda self, ast: ' \\cup '.join (self._ast2tex_wrap (a, 0, a.op in {'=', ','} or (a.is_piece and a is not ast.union [-1])) for a in ast.union),
		'^^'   : lambda self, ast: ' \\ominus '.join (self._ast2tex_wrap (a, 0, a.op in {'=', ',', '||'} or (a.is_piece and a is not ast.sdiff [-1])) for a in ast.sdiff),
		'&&'   : lambda self, ast: ' \\cap '.join (self._ast2tex_wrap (a, 0, a.op in {'=', ',', '||', '^^'} or (a.is_piece and a is not ast.xsect [-1])) for a in ast.xsect),

		'text' : lambda self, ast: ast.tex,
	}

#...............................................................................................
class ast2nat: # abstract syntax tree -> native text
	def __init__ (self): self.parent = self.ast = None # pylint droppings
	def __new__ (cls, ast, xlat = True):
		self         = super ().__new__ (cls)
		self.parents = [None]
		self.parent  = self.ast = AST ()

		if xlat:
			ast = sxlat.xlat_funcs2asts (ast, sxlat.XLAT_FUNC2AST_NAT)

		return self._ast2nat (ast)

	def _ast2nat (self, ast):
		self.parents.append (self.ast)

		self.parent = self.ast
		self.ast    = ast

		ast         = self._ast2nat_funcs [ast.op] (self, ast)

		del self.parents [-1]

		self.ast    = self.parent
		self.parent = self.parents [-1]

		return ast

	def _ast2nat_wrap (self, obj, curly = None, paren = None):
		s = self._ast2nat (obj) if isinstance (obj, AST) else str (obj)

		if (obj.op in paren) if isinstance (paren, set) else paren:
			return f'({s})'

		if (obj.op in curly) if isinstance (curly, set) else curly:
			return f'{{{s}}}'

		return s

	def _ast2nat_curly (self, ast, ops = {}):
		return self._ast2nat_wrap (ast, ops if ops else (ast.is_div or not ast.is_single_unit or (ast.is_var and ast.var in AST.Var.PY2TEX)))

	def _ast2nat_paren (self, ast, ops = {}):
		return self._ast2nat_wrap (ast, 0, not (ast.is_paren or (ops and ast.op not in ops)))

	def _ast2nat_curly_mul_exp (self, ast, ret_has = False, also = {}):
		if ast.is_mul:
			s, has = self._ast2nat_mul (ast, True)
		else:
			s, has = self._ast2nat (ast), False

		has = has or ((ast.op in also) if isinstance (also, set) else also)
		s   = self._ast2nat_wrap (s, has)

		return (s, has) if ret_has else s

	def _ast2nat_eq_hs (self, ast, hs, lhs = True):
		return self._ast2nat_wrap (hs, 0, (hs.is_ass or (lhs and hs.op in {',', 'piece', 'lamb'})) if ast.is_ass else {'=', 'piece', 'lamb'})

	def _ast2nat_add (self, ast):
		return ' + '.join (self._ast2nat_wrap (n, \
				n.is_piece or ((n.strip_mls ().is_intg or (n.is_mul and n.mul [-1].strip_mls ().is_intg)) and n is not ast.add [-1]), \
				(n.op in ('piece', 'lamb') and n is not ast.add [-1]) or n.op in {'=', 'lamb', '||', '^^', '&&'} \
				) for n in ast.add).replace (' + -', ' - ')#.replace (' + {-', ' - {')

	def _ast2nat_mul (self, ast, ret_has = False):
		t   = []
		p   = None
		has = False

		for n in ast.mul:
			s = self._ast2nat_wrap (n, \
					(p and _ast_is_neg (n)) or n.is_piece or (n.strip_mls ().is_intg and n is not ast.mul [-1]), \
					n.op in {'=', '+', 'lamb', '||', '^^', '&&'} or (n.is_piece and n is not ast.mul [-1]))

			if p and (n.op in {'#', '[', '!', 'lim', 'sum', 'intg'} or n.is_null_var or p.op in {'lim', 'sum', 'diff', 'intg'} or \
					n.op in {'/', 'diff'} or p.strip_minus ().op in {'/', 'diff'} or \
					n.strip_paren ().is_comma or (n.is_pow and n.base.strip_paren ().is_comma) or \
					(p.is_var_lambda and (self.parent.is_slice or (self.parent.is_comma and _ast_followed_by_slice (ast, self.parent.comma)))) or \
					(n.is_paren and p.is_var and p.var in _USER_FUNCS) or \
					(n.is_pow and (n.base.is_pos_num or n.base.is_brack)) or \
					(n.is_attr and n.strip_attr ().strip_paren ().is_comma) or \
					(n.is_idx and (n.obj.op in {'[', 'idx'} or n.obj.strip_paren ().is_comma))):
				t.append (f' * {s}')
				has = True

			elif p and (p.is_diff_or_part_solo or \
					(n.op not in {'#', '(', '|', '^'} or p.op not in {'#', '(', '|'})):
				t.append (f' {s}')

			else:
				t.append (s)

			p = n

		return (''.join (t), has) if ret_has else ''.join (t)

	def _ast2nat_div (self, ast):
		n, ns = (self._ast2nat_wrap (ast.numer, 1), True) if _ast_is_neg (ast.numer) else \
			(self._ast2nat_wrap (ast.numer, 0, 1), True) if ((ast.numer.base.is_diff_or_part_solo and ast.numer.exp.is_pos_int_num) if ast.numer.is_pow else ast.numer.is_diff_or_part_solo) else \
			self._ast2nat_curly_mul_exp (ast.numer, True, {'=', '+', '/', 'lim', 'sum', 'diff', 'intg', 'piece', 'lamb', '||', '^^', '&&'})

		d, ds = (self._ast2nat_wrap (ast.denom, 1), True) if _ast_is_neg (ast.denom) else self._ast2nat_curly_mul_exp (ast.denom, True, {'=', '+', '/', 'lim', 'sum', 'diff', 'intg', 'piece', 'lamb', '||', '^^', '&&'})
		s     = ns or ds or ast.numer.strip_minus ().op not in {'#', '@', '*'} or ast.denom.strip_minus ().op not in {'#', '@', '*'}

		return f'{n}{" / " if s else "/"}{d}'

	def _ast2nat_pow (self, ast, trighpow = True):
		b = self._ast2nat_wrap (ast.base, 0, not (ast.base.op in {'@', '"', '(', '[', '|', 'func', 'mat', 'set', 'dict'} or ast.base.is_pos_num))
		p = self._ast2nat_wrap (ast.exp, ast.exp.strip_minus ().op in {'=', '+', '*', '/', 'lim', 'sum', 'diff', 'intg', 'piece', 'lamb', '||', '^^', '&&'}, {","})

		if ast.base.is_trigh_func_noninv and ast.exp.is_single_unit and trighpow:
			i = len (ast.base.func)

			return f'{b [:i]}**{p}{b [i:]}'

		return f'{b}**{p}'

	def _ast2nat_log (self, ast):
		return \
				f'ln{self._ast2nat_paren (ast.log)}' \
				if ast.base is None else \
				f'\\log_{self._ast2nat_curly (ast.base)}{self._ast2nat_paren (ast.log)}'

	def _ast2nat_lim (self, ast):
		s = self._ast2nat_wrap (ast.to, {'piece'}) if ast.dir is None else (self._ast2nat_pow (AST ('^', ast.to, AST.Zero), trighpow = False) [:-1] + ast.dir)

		return f'\\lim_{{{self._ast2nat (ast.lvar)} \\to {s}}} {self._ast2nat_curly_mul_exp (ast.lim, False, ast.lim.op in {"=", "+", "piece", "lamb", "||", "^^", "&&"} or ast.lim.is_mul_has_abs)}'

	def _ast2nat_sum (self, ast):
		return f'\\sum_{{{self._ast2nat (ast.svar)}={self._ast2nat_curly (ast.from_, {"piece"})}}}^{self._ast2nat_curly (ast.to)} {self._ast2nat_curly_mul_exp (ast.sum, False, ast.sum.op in {"=", "+", "piece", "lamb", "||", "^^", "&&"} or ast.sum.is_mul_has_abs)}'

	def _ast2nat_diff (self, ast):
		p = 0
		d = ''

		for n in ast.dvs:
			if n.is_var:
				d  = n.diff_or_part_type
				p += 1
			else: # n = ('^', ('@', 'differential'), ('#', 'int'))
				d  = n.base.diff_or_part_type
				p += n.exp.as_int

		return f'{d.strip () if d else "d"}{"" if p == 1 else f"^{p}"} / {" ".join (self._ast2nat (n) for n in ast.dvs)} {self._ast2nat_paren (ast.diff)}'

	def _ast2nat_intg (self, ast):
		if ast.from_ is None:
			if ast.intg is None:
				return f'\\int {self._ast2nat (ast.dv)}'
			else:
				return f'\\int {self._ast2nat_wrap (ast.intg, ast.intg.op in {"diff", "piece"} or ast.intg.is_mul_has_abs, {"=", "lamb", "||", "^^", "&&"})} {self._ast2nat (ast.dv)}'
		else:
			if ast.intg is None:
				return f'\\int_{self._ast2nat_curly (ast.from_)}^{self._ast2nat_curly (ast.to)} {self._ast2nat (ast.dv)}'
			else:
				return f'\\int_{self._ast2nat_curly (ast.from_)}^{self._ast2nat_curly (ast.to)} {self._ast2nat_wrap (ast.intg, ast.intg.op in {"diff", "piece"} or ast.intg.is_mul_has_abs, {"=", "lamb", "||", "^^", "&&"})} {self._ast2nat (ast.dv)}'

	_ast2nat_funcs = {
		'='    : lambda self, ast: f'{self._ast2nat_eq_hs (ast, ast.lhs)} {AST.Eq.PYFMT.get (ast.rel, ast.rel)} {self._ast2nat_eq_hs (ast, ast.rhs, False)}',
		'#'    : lambda self, ast: ast.num,
		'@'    : lambda self, ast: ast.var,
		'.'    : lambda self, ast: f'{self._ast2nat_paren (ast.obj, {"=", "#", ",", "-", "+", "*", "/", "lim", "sum", "intg", "piece", "lamb", "||", "^^", "&&"})}.{ast.attr}' \
				if ast.args is None else f'{self._ast2nat (ast.obj)}.{ast.attr}{self._ast2nat_paren (AST.tuple2ast (ast.args))}',
		'"'    : lambda self, ast: repr (ast.str_),
		','    : lambda self, ast: f'{", ".join (self._ast2nat (c) for c in ast.comma)}{_trail_comma (ast.comma)}',
		'('    : lambda self, ast: f'({self._ast2nat (ast.paren)})',
		'['    : lambda self, ast: f'[{", ".join (self._ast2nat (b) for b in ast.brack)}]',
		'|'    : lambda self, ast: f'{{|{self._ast2nat (ast.abs)}|}}',
		'-'    : lambda self, ast: f'-{self._ast2nat_wrap (ast.minus, ast.minus.is_pos_num or ast.minus.op in {"*", "piece"}, {"=", "+", "lamb", "||", "^^", "&&"})}',
		'!'    : lambda self, ast: self._ast2nat_wrap (ast.fact, {'^'}, ast.fact.op not in {'#', '@', '"', '(', '|', '!', '^', 'vec', 'mat'} or ast.fact.is_neg_num) + '!',
		'+'    : _ast2nat_add,
		'*'    : _ast2nat_mul,
		'/'    : _ast2nat_div,
		'^'    : _ast2nat_pow,
		'log'  : _ast2nat_log,
		'sqrt' : lambda self, ast: f'sqrt{self._ast2nat_paren (ast.rad)}' if ast.idx is None else f'\\sqrt[{self._ast2nat (ast.idx)}]{{{self._ast2nat_wrap (ast.rad, 0, {","})}}}',
		'func' : lambda self, ast: f'{ast.func}({self._ast2nat (AST.tuple2ast (ast.args))})',
		'lim'  : _ast2nat_lim,
		'sum'  : _ast2nat_sum,
		'diff' : _ast2nat_diff,
		'intg' : _ast2nat_intg,
		'vec'  : lambda self, ast: f'\\[{", ".join (self._ast2nat (e) for e in ast.vec)}{_trail_comma (ast.vec)}]',
		'mat'  : lambda self, ast: ('\\[' + ', '.join (f'[{", ".join (self._ast2nat (e) for e in row)}{_trail_comma (row)}]' for row in ast.mat) + f'{_trail_comma (ast.mat)}]') if ast.mat else 'Matrix([])',
		'piece': lambda self, ast: ' else '.join (f'{self._ast2nat_wrap (p [0], p [0].is_ass or p [0].op in {"piece", "lamb"}, {","})}' if p [1] is True else \
				f'{self._ast2nat_wrap (p [0], p [0].is_ass or p [0].op in {"piece", "lamb"}, {","})} if {self._ast2nat_wrap (p [1], p [1].is_ass or p [1].op in {"piece", "lamb"}, {","})}' for p in ast.piece),
		'lamb' : lambda self, ast: f'lambda{" " + ", ".join (v.var for v in ast.vars) if ast.vars else ""}: {self._ast2nat_wrap (ast.lamb, 0, ast.lamb.is_eq)}',
		'idx'  : lambda self, ast: f'{self._ast2nat_wrap (ast.obj, {"^"}, ast.obj.is_neg_num or ast.obj.op in {"=", ",", "+", "*", "/", "-", "lim", "sum", "diff", "intg", "piece", "lamb", "||", "^^", "&&"})}[{self._ast2nat (AST.tuple2ast (ast.idx))}]',
		'slice': lambda self, ast: ':'.join (self._ast2nat_wrap (a, 0, a.is_ass or a.op in {',', 'lamb', 'slice'}) for a in _ast_slice_bounds (ast)),
		'set'  : lambda self, ast: f'{{{", ".join (self._ast2nat (c) for c in ast.set)}{_trail_comma (ast.set)}}}' if ast.set else '\\{}',
		'dict' : lambda self, ast: f'{{{", ".join (f"{self._ast2nat (k)}: {self._ast2nat (v)}" for k, v in ast.dict)}}}',
		'||'   : lambda self, ast: ' || '.join (self._ast2nat_wrap (a, 0, a.op in {'=', ',', 'piece', 'lamb'}) for a in ast.union),
		'^^'   : lambda self, ast: ' ^^ '.join (self._ast2nat_wrap (a, 0, a.op in {'=', ',', 'piece', 'lamb', '||'}) for a in ast.sdiff),
		'&&'   : lambda self, ast: ' && '.join (self._ast2nat_wrap (a, 0, a.op in {'=', ',', 'piece', 'lamb', '||', '^^'}) for a in ast.xsect),

		'text' : lambda self, ast: ast.nat,
	}

#...............................................................................................
class ast2py: # abstract syntax tree -> Python code text
	def __new__ (cls, ast, xlat = True):
		self = super ().__new__ (cls)

		if xlat:
			ast = sxlat.xlat_funcs2asts (ast, sxlat.XLAT_FUNC2AST_PY)

		if _PYS:
			ast = sxlat.xlat_pyS (ast)

		return self._ast2py (ast)

	def _ast2py (self, ast):
		return self._ast2py_funcs [ast.op] (self, ast)

	def _ast2py_curly (self, ast):
		return \
				self._ast2py_paren (ast) \
				if ast.strip_minus ().op in {',', '+', '*', '/', '||', '^^', '&&'} or (ast.is_log and ast.base is not None) else \
				self._ast2py (ast)

	def _ast2py_paren (self, ast, paren = None):
		if paren is None:
			return self._ast2py (ast) if ast.is_paren else f'({self._ast2py (ast)})'

		if (ast.op in paren) if isinstance (paren, set) else paren:
			return f'({self._ast2py (ast)})'

		return self._ast2py (ast)

	def _ast2py_div (self, ast):
		n = self._ast2py_curly (ast.numer)
		d = self._ast2py_curly (ast.denom)

		return f'{n}{" / " if ast.numer.strip_minus ().op not in {"#", "@"} or ast.denom.strip_minus ().op not in {"#", "@"} else "/"}{d}'

	def _ast2py_pow (self, ast):
		b = self._ast2py_paren (ast.base) if _ast_is_neg (ast.base) or ast.base.is_lamb else self._ast2py_curly (ast.base)
		e = self._ast2py_curly (ast.exp)

		return f'{b}**{e}'

	def _ast2py_log (self, ast):
		if ast.base is None:
			return f'ln{self._ast2py_paren (ast.log)}'
		else:
			return f'log{self._ast2py_paren (ast.log)} / log{self._ast2py_paren (ast.base)}'

	def _ast2py_lim (self, ast):
		return \
				f'''Limit({self._ast2py (ast.lim)}, {self._ast2py (ast.lvar)}, {self._ast2py (ast.to)}''' \
				f'''{", dir='+-'" if ast.dir is None else ", dir='-'" if ast.dir == '-' else ""})'''

	def _ast2py_diff (self, ast):
		args = sum ((
				(self._ast2py (n.as_var),)
				if n.is_var else
				(self._ast2py (n.base.as_var), str (n.exp.as_int))
				for n in ast.dvs), ())

		return f'Derivative({self._ast2py (ast.diff.strip_paren (keeptuple = True))}, {", ".join (args)})'

	def _ast2py_intg (self, ast):
		if ast.intg is not None and ast.intg.is_intg:
			intg = self._ast2py_intg (ast.intg)
		else:
			intg = f'Integral({1 if ast.intg is None else self._ast2py (ast.intg)})'

		if ast.from_ is None:
			intg = intg [:-1] + f', {self._ast2py (ast.dv.as_var)})'
		else:
			intg = intg [:-1] + f', ({self._ast2py (ast.dv.as_var)}, {self._ast2py (ast.from_)}, {self._ast2py (ast.to)}))'

		return intg

	def _ast2py_sdiff (self, ast):
		sdiff = self._ast2py (ast.sdiff [0])

		for a in ast.sdiff [1:]:
			a     = self._ast2py (a)
			sdiff = f'Union(Complement({sdiff}, {a}), Complement({a}, {sdiff}))'

		return sdiff

	_ast2py_funcs = {
		'='    : lambda self, ast: f'{self._ast2py_paren (ast.lhs) if (ast.is_eq and ast.lhs.is_lamb) else self._ast2py (ast.lhs)} {AST.Eq.PYFMT.get (ast.rel, ast.rel)} {self._ast2py (ast.rhs)}',
		'#'    : lambda self, ast: ast.num,
		'@'    : lambda self, ast: ast.var,
		'.'    : lambda self, ast: f'{self._ast2py (ast.obj)}.{ast.attr}' if ast.args is None else f'{self._ast2py (ast.obj)}.{ast.attr}{self._ast2py_paren (AST.tuple2ast (ast.args))}',
		'"'    : lambda self, ast: repr (ast.str_),
		','    : lambda self, ast: f'{", ".join (self._ast2py (parm) for parm in ast.comma)}{_trail_comma (ast.comma)}',
		'('    : lambda self, ast: f'({self._ast2py (ast.paren)})',
		'['    : lambda self, ast: f'[{", ".join (self._ast2py (b) for b in ast.brack)}]',
		'|'    : lambda self, ast: f'abs({self._ast2py (ast.abs)})',
		'-'    : lambda self, ast: f'-{self._ast2py_paren (ast.minus, ast.minus.op in {"+", "lamb"})}',
		'!'    : lambda self, ast: f'factorial({self._ast2py (ast.fact)})',
		'+'    : lambda self, ast: ' + '.join (self._ast2py_paren (n) if n.op in {'||', '^^', '&&'} else self._ast2py (n) for n in ast.add).replace (' + -', ' - ').replace (' + -', ' - '),
		'*'    : lambda self, ast: '*'.join (self._ast2py_paren (n) if n.op in {'+', '||', '^^', '&&'} else self._ast2py (n) for n in ast.mul),
		'/'    : _ast2py_div,
		'^'    : _ast2py_pow,
		'log'  : _ast2py_log,
		'sqrt' : lambda self, ast: f'sqrt{self._ast2py_paren (ast.rad)}' if ast.idx is None else self._ast2py (AST ('^', ast.rad.strip_paren (1), ('/', AST.One, ast.idx))),
		'func' : lambda self, ast: f'{ast.unescaped}({self._ast2py (AST.tuple2ast (ast.args))})',
		'lim'  : _ast2py_lim,
		'sum'  : lambda self, ast: f'Sum({self._ast2py (ast.sum)}, ({self._ast2py (ast.svar)}, {self._ast2py (ast.from_)}, {self._ast2py (ast.to)}))',
		'diff' : _ast2py_diff,
		'intg' : _ast2py_intg,
		'vec'  : lambda self, ast: 'Matrix([' + ', '.join (f'{self._ast2py (e)}' for e in ast.vec) + '])',
		'mat'  : lambda self, ast: 'Matrix([' + ', '.join (f'[{", ".join (self._ast2py (e) for e in row)}]' for row in ast.mat) + '])',
		'piece': lambda self, ast: 'Piecewise(' + ', '.join (f'({self._ast2py (p [0])}, {True if p [1] is True else self._ast2py (p [1])})' for p in ast.piece) + ')',
		'lamb' : lambda self, ast: f'Lambda({self._ast2py (AST.tuple2ast (ast.vars, paren = True))}, {self._ast2py (ast.lamb)})',
		'idx'  : lambda self, ast: f'{self._ast2py_paren (ast.obj) if ast.obj.is_neg_num or ast.obj.op in {"=", ",", "+", "*", "/", "^", "-", "lim", "sum", "diff", "intg", "piece", "lamb"} else self._ast2py (ast.obj)}[{self._ast2py (AST.tuple2ast (ast.idx))}]',
		'slice': lambda self, ast: ':'.join (self._ast2py_paren (a, a.is_ass or a.op in {',', 'lamb', 'slice'}) for a in _ast_slice_bounds (ast)),
		'set'  : lambda self, ast: f'FiniteSet({", ".join (self._ast2py (c) for c in ast.set)})',
		'dict' : lambda self, ast: f'{{{", ".join (f"{self._ast2py (k)}: {self._ast2py (v)}" for k, v in ast.dict)}}}',
		'||'   : lambda self, ast: f'Union({", ".join (self._ast2py (a) for a in ast.union)})',
		'^^'   : _ast2py_sdiff,
		'&&'   : lambda self, ast: f'Intersection({", ".join (self._ast2py (a) for a in ast.xsect)})',

		'text' : lambda self, ast: ast.py,
	}

#...............................................................................................
# Potentially bad __builtins__: eval, exec, globals, locals, vars, setattr, delattr, exit, help, input, license, open, quit, __import__
_builtins_dict         = __builtins__ if isinstance (__builtins__, dict) else __builtins__.__dict__
_builtins_names        = ['abs', 'all', 'any', 'ascii', 'bin', 'callable', 'chr', 'dir', 'divmod', 'format', 'getattr', 'hasattr', 'hash', 'hex', 'id',
	'isinstance', 'issubclass', 'iter', 'len', 'max', 'min', 'next', 'oct', 'ord', 'pow', 'print', 'repr', 'round', 'sorted', 'sum', 'bool',
	'bytearray', 'bytes', 'complex', 'dict', 'enumerate', 'filter', 'float', 'frozenset', 'property', 'int', 'list', 'map', 'object', 'range',
	'reversed', 'set', 'slice', 'str', 'tuple', 'type', 'zip']

_ast2spt_func_builtins = dict (no for no in filter (lambda no: no [1], ((n, _builtins_dict.get (n)) for n in _builtins_names)))
_ast2spt_funcs         = {**_ast2spt_func_builtins, **sp.__dict__}

class ast2spt: # abstract syntax tree -> sympy tree (expression)
	def __init__ (self): self.vars = self.eval = [] # pylint kibble
	def __new__ (cls, ast, vars = {}, xlat = True):
		self      = super ().__new__ (cls)
		self.vars = [vars]
		self.eval = True

		if xlat:
			ast = sxlat.xlat_funcs2asts (ast, sxlat.XLAT_FUNC2AST_PY)

		spt = self._ast2spt (ast)

		if _POST_SIMPLIFY:
			spt = _simplify (spt)

		return spt

	def _ast2spt (self, ast):
		spt = self._ast2spt_funcs [ast.op] (self, ast)

		if _DOIT and _EVAL and self.eval:
			try:
				spt = spt.doit (deep = False)
			except:
				pass

		return spt

	_ast2spt_consts = { # 'e' and 'i' dynamically set on use from AST.E or AST.I
		'pi'   : sp.pi,
		'oo'   : sp.oo,
		'zoo'  : sp.zoo,
		'None' : None,
		'True' : True,
		'False': False,
		'nan'  : sp.nan,
	}

	def _ast2spt_var (self, ast):
		spt = {**self._ast2spt_consts, AST.E.var: sp.E, AST.I.var: sp.I}.get (ast.var, self) # 'self' being used for as unique None

		if spt is self:
			if len (ast.var) > 1 and ast.var not in AST.Var.GREEK:
				spt = getattr (sp, ast.var, self)

			if spt is self:
				spt = sp.Symbol (ast.var)

		return spt

	def _ast2spt_attr (self, ast):
		obj = ast.obj
		spt = None

		while obj.is_func and obj.args and (obj.func == AST.Func.NOEVAL or obj.func == AST.Func.NOREMAP):
			obj = obj.args [0]

		if obj.is_var and obj.var not in self.vars: # always support S.Half and the like unless base object redefined by assignment
			spt = getattr (sp, obj.var, None)

		if spt is None:
			spt = self._ast2spt (ast.obj)

		try:
			attr = getattr (spt, ast.attr)

			return attr if ast.args is None else _ast_func_call (attr, ast.args, self._ast2spt)

		except AttributeError: # unresolved attributes of expressions with free vars remaining should not raise
			if not obj.free_vars ():
				raise

		return ExprNoEval (str (AST ('.', spt2ast (spt), *ast [2:])), 1)

	def _ast2spt_add (self, ast): # specifically try to subtract negated objects (because of sets)
		if not _EVAL:
			return sp.Add (*(self._ast2spt (n) for n in ast.add), evaluate = False)

		itr = iter (ast.add)
		res = self._ast2spt (next (itr))

		for arg in itr:
			arg, neg    = arg.strip_minus (retneg = True)
			arg, is_neg = self._ast2spt (arg), neg.is_neg

			try:
				res = res - arg if is_neg else res + arg
			except:
				res = sp.sympify (res) - sp.sympify (arg) if is_neg else sp.sympify (res) + sp.sympify (arg)

		return res

	def _ast2spt_func (self, ast):
		if ast.func == AST.Func.NOREMAP: # special reference meta-function
			return self._ast2spt (ast.args [0])

		if ast.func == AST.Func.NOEVAL: # special no-evaluate meta-function
			return ExprNoEval (str (ast.args [0]), 1 if len (ast.args) == 1 else self._ast2spt (ast.args [1]))

		func = _ast2spt_funcs.get (ast.unescaped) # getattr (sp, ast.unescaped, None) or _ast2spt_func_builtins.get (ast.unescaped) #

		if func is not None:
			return _ast_func_call (func, ast.args, self._ast2spt, is_escaped = ast.is_escaped)

		if ast.unescaped in _USER_FUNCS: # user lambda, within other lambda if it got here
			return ExprNoEval (str (ast), 1)

		raise NameError (f'function {ast.unescaped!r} is not defined')

	def _ast2spt_diff (self, ast):
		args = sum (( \
				(self._ast2spt (n.as_var),) \
				if n.is_var else \
				(self._ast2spt (n.base.as_var), sp.Integer (n.exp.as_int)) \
				for n in ast.dvs \
				), ())

		return sp.Derivative (self._ast2spt (ast [1]), *args, evaluate = _EVAL)

	def _ast2spt_intg (self, ast):
		if ast.from_ is None:
			if ast.intg is None:
				return sp.Integral (1, sp.Symbol (ast.dv.as_var.var))
			else:
				return sp.Integral (self._ast2spt (ast.intg), sp.Symbol (ast.dv.as_var.var))

		else:
			if ast.intg is None:
				return sp.Integral (1, (sp.Symbol (ast.dv.as_var.var), self._ast2spt (ast.from_), self._ast2spt (ast.to)))
			else:
				return sp.Integral (self._ast2spt (ast [1]), (sp.Symbol (ast.dv.as_var.var), self._ast2spt (ast.from_), self._ast2spt (ast.to)))

	def _ast2spt_lamb (self, ast):
		oldeval   = self.eval
		self.eval = False
		spt       = sp.Lambda (tuple (sp.Symbol (v.var) for v in ast.vars), self._ast2spt (ast.lamb))
		self.eval = oldeval

		return spt

	def _ast2spt_idx (self, ast):
		spt = self._ast2spt (ast.obj)
		idx = self._ast2spt (ast.idx [0]) if len (ast.idx) == 1 else tuple (self._ast2spt (i) for i in ast.idx)

		try:
			return spt [idx]
		except TypeError: # invalid indexing of expressions with free vars remaining should not raise
			if not ast.free_vars ():
				raise

		return ExprNoEval (str (AST ('idx', spt2ast (spt), ast.idx)), 1)

	def _ast2spt_sdiff (self, ast):
		sdiff = self._ast2spt (ast.sdiff [0])

		for a in ast.sdiff [1:]:
			a     = self._ast2spt (a)
			sdiff = sp.Union (sp.Complement (sdiff, a), sp.Complement (a, sdiff))

		return sdiff

	_ast2spt_eq = {
		'='    : EqAss,
		'=='   : sp.Eq,
		'!='   : sp.Ne,
		'<'    : sp.Lt,
		'<='   : sp.Le,
		'>'    : sp.Gt,
		'>='   : sp.Ge,
		'in'   : lambda a, b: a in b,
		'notin': lambda a, b: a not in b,
	}

	_ast2spt_funcs = {
		'='    : lambda self, ast: self._ast2spt_eq [ast.rel] (self._ast2spt (ast.lhs), self._ast2spt (ast.rhs)),
		'#'    : lambda self, ast: sp.Integer (ast.num) if ast.is_int_num else sp.Float (ast.num, _SYMPY_FLOAT_PRECISION),
		'@'    : _ast2spt_var,
		'.'    : _ast2spt_attr,
		'"'    : lambda self, ast: ast.str_,
		','    : lambda self, ast: tuple (self._ast2spt (p) for p in ast.comma),
		'('    : lambda self, ast: self._ast2spt (ast.paren),
		'['    : lambda self, ast: [self._ast2spt (b) for b in ast.brack],
		'|'    : lambda self, ast: sp.Abs (self._ast2spt (ast.abs), evaluate = _EVAL),
		'-'    : lambda self, ast: -self._ast2spt (ast.minus),
		'!'    : lambda self, ast: sp.factorial (self._ast2spt (ast.fact), evaluate = _EVAL),
		'+'    : _ast2spt_add,
		'*'    : lambda self, ast: _Mul (*(self._ast2spt (n) for n in ast.mul), evaluate = _EVAL),
		'/'    : lambda self, ast: _Mul (self._ast2spt (ast.numer), _Pow (self._ast2spt (ast.denom), -1, evaluate = _EVAL), evaluate = _EVAL),
		'^'    : lambda self, ast: _Pow (self._ast2spt (ast.base), self._ast2spt (ast.exp), evaluate = _EVAL),
		'log'  : lambda self, ast: sp.log (self._ast2spt (ast.log), evaluate = _EVAL) if ast.base is None else sp.log (self._ast2spt (ast.log), self._ast2spt (ast.base), evaluate = _EVAL),
		'sqrt' : lambda self, ast: _Pow (self._ast2spt (ast.rad), _Pow (sp.S (2), -1, evaluate = _EVAL), evaluate = _EVAL) if ast.idx is None else _Pow (self._ast2spt (ast.rad), _Pow (self._ast2spt (ast.idx), -1, evaluate = _EVAL), evaluate = _EVAL),
		'func' : _ast2spt_func,
		'lim'  : lambda self, ast: (sp.Limit if ast.dir else sp.limit) (self._ast2spt (ast.lim), self._ast2spt (ast.lvar), self._ast2spt (ast.to), dir = ast.dir or '+-'),
		'sum'  : lambda self, ast: sp.Sum (self._ast2spt (ast.sum), (self._ast2spt (ast.svar), self._ast2spt (ast.from_), self._ast2spt (ast.to))),
		'diff' : _ast2spt_diff,
		'intg' : _ast2spt_intg,
		'vec'  : lambda self, ast: sp.Matrix ([[self._ast2spt (e)] for e in ast.vec], evaluate = _EVAL),
		'mat'  : lambda self, ast: sp.Matrix ([[self._ast2spt (e) for e in row] for row in ast.mat], evaluate = _EVAL),
		'piece': lambda self, ast: sp.Piecewise (*((self._ast2spt (p [0]), True if p [1] is True else self._ast2spt (p [1])) for p in ast.piece), evaluate = _EVAL),
		'lamb' : _ast2spt_lamb,
		'idx'  : _ast2spt_idx,
		'slice': lambda self, ast: slice (*(self._ast2spt (a) if a else a for a in _ast_slice_bounds (ast, None))),
		'set'  : lambda self, ast: sp.FiniteSet (*(self._ast2spt (a) for a in ast.set)),
		'dict' : lambda self, ast: dict ((self._ast2spt (k), self._ast2spt (v)) for k, v in ast.dict),
		'||'   : lambda self, ast: sp.Union (*(self._ast2spt (a) for a in ast.union)),
		'^^'   : _ast2spt_sdiff,
		'&&'   : lambda self, ast: sp.Intersection (*(self._ast2spt (a) for a in ast.xsect)),

		'text' : lambda self, ast: ast.spt,
	}

#...............................................................................................
def spt2ast (spt): # sympy tree (expression) -> abstract syntax tree
	for cls in spt.__class__.__mro__:
		func = _spt2ast_funcs.get (cls)

		if func:
			return func (spt)

	tex = sp.latex (spt)

	if tex == str (spt): # no native latex representation?
		tex = tex.replace ('_', '\\_')

	if tex [0] == '<' and tex [-1] == '>': # for Python repr style of objects <class something> TODO: Move this to Javascript.
		tex = '\\text{' + tex.replace ("<", "&lt;").replace (">", "&gt;").replace ("\n", "") + '}'

	return AST ('text', tex, str (spt), str (spt), spt)

def _spt2ast_num (spt):
	num = AST ('#', str (spt))

	if num.grp [5]:
		return AST ('#', ''.join (num.grp [:6] + num.grp [7:]))

	e = len (num.grp [2]) + num.num_exp_val

	return AST ('#', \
			f'{num.grp [0]}{num.grp [1]}e+{e}'     if e >= 16 else \
			f'{num.grp [0]}{num.grp [1]}{"0" * e}' if e >= 0 else \
			f'{num.grp [0]}{num.grp [1]}e{e}')

def _spt2ast_Union (spt): # convert union of complements to symmetric difference if present
	if len (spt.args) == 2 and spt.args [0].is_Complement and spt.args [1].is_Complement and \
			spt.args [0].args [0] == spt.args [1].args [1] and spt.args [0].args [1] == spt.args [1].args [0]:
		return AST ('^^', (spt2ast (spt.args [0].args [0]), spt2ast (spt.args [0].args [1])))

	return spt2ast (spt.args [0]) if len (spt.args) == 1 else AST ('||', tuple (spt2ast (a) for a in spt.args))

def _spt2ast_MatrixBase (spt):
	if not spt.cols or not spt.rows:
		return AST ('vec', ())
	if spt.cols > 1:
		return AST ('mat', tuple (tuple (spt2ast (e) for e in spt [row, :]) for row in range (spt.rows)))
	elif spt.rows > 1:
		return AST ('vec', tuple (spt2ast (e) for e in spt))
	else:
		return spt2ast (spt [0])

def _spt2ast_Add (spt):
	args = spt.args

	for arg in args:
		if isinstance (arg, sp.Order):
			break
	else:
		if args [0].is_number:
			args = spt.args [1:] + (spt.args [0],)

	return AST ('+', tuple (spt2ast (arg) for arg in args))

def _spt2ast_Mul (spt):
	if spt.args [0] == -1:
		return AST ('-', spt2ast (sp.Mul (*spt.args [1:], evaluate = _EVAL)))

	if spt.args [0].is_negative and isinstance (spt, sp.Number):
		return AST ('-', spt2ast (sp.Mul (-spt.args [0], *spt.args [1:], evaluate = _EVAL)))

	args = spt.args [1:] if spt.args [0] == 1 else spt.args # sometimes we get Mul (1, ...), strip the 1

	if len (spt.args) == 1:
		return spt2ast (args [0])

	numer = []
	denom = []

	for arg in args:
		if isinstance (arg, sp.Pow) and arg.args [1].is_negative:
			denom.append (spt2ast (arg.args [0] if arg.args [1] is sp.S.NegativeOne else _Pow (arg.args [0], -arg.args [1], evaluate = _EVAL)))
		else:
			numer.append (spt2ast (arg))

	if not denom:
		return AST ('*', tuple (numer)) if len (numer) > 1 else numer [0]

	if not numer:
		return AST ('/', AST.One, AST ('*', tuple (denom)) if len (denom) > 1 else denom [0])

	return AST ('/', AST ('*', tuple (numer)) if len (numer) > 1 else numer [0], \
			AST ('*', tuple (denom)) if len (denom) > 1 else denom [0])

def _spt2ast_Pow (spt):
	if spt.args [1].is_negative:
		return AST ('/', AST.One, spt2ast (spt.args [0] if spt.args [1] is sp.S.NegativeOne else _Pow (spt.args [0], -spt.args [1], evaluate = _EVAL)))

	if spt.args [1] == 0.5:
		return AST ('sqrt', spt2ast (spt.args [0]))

	return AST ('^', spt2ast (spt.args [0]), spt2ast (spt.args [1]))

def _spt2ast_MatPow (spt):
	try: # compensate for some MatPow.doit() != mat**pow
		return spt2ast (spt.args [0]**spt.args [1])
	except:
		return AST ('^', spt2ast (spt.args [0]), spt2ast (spt.args [1]))

def _spt2ast_Function (spt, name = None, args = None, kws = None):
	if name is None:
		name = spt.__class__.__name__

	if getattr (spt, 'SYMPAD_ESCAPED', None):
		name = f'{AST.Func.ESCAPE}{name}'

	if args is None:
		args = spt.args

	if kws:
		return AST ('func', name, tuple (spt2ast (arg) for arg in spt.args) + tuple (AST ('=', '=', ('@', kw), a) for kw, a in kws))
	else:
		return AST ('func', name, tuple (spt2ast (arg) for arg in spt.args))

def _spt2ast_Derivative (spt):
	return AST ('diff', spt2ast (spt.args [0]), tuple ( \
			('@', f'd{s.name}') if p == 1 else ('^', ('@', f'd{s.name}'), ('#', str (p))) \
			for s, p in spt.args [1:]))

def _spt2ast_Integral (spt):
	return \
			AST ('intg', spt2ast (spt.args [0]), AST ('@', f'd{spt2ast (spt.args [1] [0]) [1]}'), spt2ast (spt.args [1] [1]), spt2ast (spt.args [1] [2])) \
			if len (spt.args [1]) == 3 else \
			AST ('intg', spt2ast (spt.args [0]), AST ('@', f'd{spt2ast (spt.args [1] [0]) [1]}'))

_spt2ast_Limit_dirs = {'+': ('+',), '-': ('-',), '+-': ()}

dict_keys   = {}.keys ().__class__
dict_values = {}.values ().__class__
dict_items  = {}.items ().__class__

_spt2ast_funcs = {
	ExprNoEval: lambda spt: spt.SYMPAD_eval (),

	None.__class__: lambda spt: AST.None_,
	bool: lambda spt: AST.True_ if spt else AST.False_,
	int: lambda spt: AST ('#', str (spt)),
	float: lambda spt: AST ('#', str (_fltoint (spt))),
	complex: lambda spt: AST ('#', str (_fltoint (spt.real))) if not spt.imag else AST ('+', (('#', str (_fltoint (spt.real))), AST.I if spt.imag == 1 else ('*', (('#', str (_fltoint (spt.imag))), AST.I)))),
	str: lambda spt: AST ('"', spt),
	tuple: lambda spt: AST ('(', (',', tuple (spt2ast (e) for e in spt))),
	list: lambda spt: AST ('[', tuple (spt2ast (e) for e in spt)),
	set: lambda spt: AST ('set', tuple (spt2ast (e) for e in spt)),
	frozenset: lambda spt: AST ('set', tuple (spt2ast (e) for e in spt)),
	dict: lambda spt: AST ('dict', tuple ((spt2ast (k), spt2ast (v)) for k, v in spt.items ())),
	slice: lambda spt: AST ('slice', False if spt.start is None else spt2ast (spt.start), False if spt.stop is None else spt2ast (spt.stop), None if spt.step is None else spt2ast (spt.step)),
	dict_keys: lambda spt: AST ('[', tuple (spt2ast (e) for e in spt)),
	dict_values: lambda spt: AST ('[', tuple (spt2ast (e) for e in spt)),
	dict_items: lambda spt: AST ('[', tuple (spt2ast (e) for e in spt)),
	sp.Tuple: lambda spt: spt2ast (spt.args),

	sp.Integer: _spt2ast_num,
	sp.Float: _spt2ast_num,
	sp.Rational: lambda spt: AST ('/', ('#', str (spt.p)), ('#', str (spt.q))) if spt.p >= 0 else AST ('-', ('/', ('#', str (-spt.p)), ('#', str (spt.q)))),
	sp.numbers.ImaginaryUnit: lambda ast: AST.I,
	sp.numbers.Pi: lambda spt: AST.Pi,
	sp.numbers.Exp1: lambda spt: AST.E,
	sp.numbers.Infinity: lambda spt: AST.Infty,
	sp.numbers.NegativeInfinity: lambda spt: AST ('-', AST.Infty),
	sp.numbers.ComplexInfinity: lambda spt: AST.CInfty,
	sp.numbers.NaN: lambda spt: AST.NaN,

	sp.Symbol: lambda spt: AST ('@', spt.name),

	sp.boolalg.BooleanTrue: lambda spt: AST.True_,
	sp.boolalg.BooleanFalse: lambda spt: AST.False_,
	EqAss: lambda spt: AST ('=', '=', spt2ast (spt.args [0]), spt2ast (spt.args [1])),
	sp.Eq: lambda spt: AST ('=', '==', spt2ast (spt.args [0]), spt2ast (spt.args [1])),
	sp.Ne: lambda spt: AST ('=', '!=', spt2ast (spt.args [0]), spt2ast (spt.args [1])),
	sp.Lt: lambda spt: AST ('=', '<', spt2ast (spt.args [0]), spt2ast (spt.args [1])),
	sp.Le: lambda spt: AST ('=', '<=', spt2ast (spt.args [0]), spt2ast (spt.args [1])),
	sp.Gt: lambda spt: AST ('=', '>', spt2ast (spt.args [0]), spt2ast (spt.args [1])),
	sp.Ge: lambda spt: AST ('=', '>=', spt2ast (spt.args [0]), spt2ast (spt.args [1])),

	sp.EmptySet: lambda spt: AST.SetEmpty,
	sp.fancysets.Complexes: lambda spt: AST.Complexes,
	sp.FiniteSet: lambda spt: AST ('set', tuple (spt2ast (arg) for arg in spt.args)),
	sp.Union: _spt2ast_Union,
	sp.Intersection: lambda spt: spt2ast (spt.args [0]) if len (spt.args) == 1 else AST.flatcat ('&&', spt2ast (spt.args [0]), spt2ast (spt.args [1])),
	sp.Complement: lambda spt: AST ('+', (spt2ast (spt.args [0]), ('-', spt2ast (spt.args [1])))),

	sp.matrices.MatrixBase: _spt2ast_MatrixBase,

	sp.Poly: lambda spt: _spt2ast_Function (spt, args = spt.args + spt.gens, kws = (('domain', AST ('"', str (spt.domain))),)),

	sp.Add: _spt2ast_Add,
	sp.Mul: _spt2ast_Mul,
	sp.Pow: _spt2ast_Pow,
	sp.MatPow: _spt2ast_MatPow,

	sp.Abs: lambda spt: AST ('|', spt2ast (spt.args [0])),
	sp.arg: lambda spt: AST ('func', 'arg', (spt2ast (spt.args [0]),)),
	sp.exp: lambda spt: AST ('^', AST.E, spt2ast (spt.args [0])),
	sp.factorial: lambda spt: AST ('!', spt2ast (spt.args [0])),
	sp.Function: _spt2ast_Function,
	sp.functions.elementary.trigonometric.TrigonometricFunction: _spt2ast_Function,
	sp.functions.elementary.hyperbolic.HyperbolicFunction: _spt2ast_Function,
	sp.functions.elementary.trigonometric.InverseTrigonometricFunction: _spt2ast_Function,
	sp.functions.elementary.hyperbolic.InverseHyperbolicFunction: _spt2ast_Function,
	sp.log: lambda spt: AST ('log', spt2ast (spt.args [0])) if len (spt.args) == 1 else AST ('log', spt2ast (spt.args [0]), spt2ast (spt.args [1])),
	sp.Min: lambda spt: AST ('func', 'Min', tuple (spt2ast (arg) for arg in spt.args)),
	sp.Max: lambda spt: AST ('func', 'Max', tuple (spt2ast (arg) for arg in spt.args)),

	sp.Limit: lambda spt: AST (*(('lim', spt2ast (spt.args [0]), spt2ast (spt.args [1]), spt2ast (spt.args [2])) + _spt2ast_Limit_dirs [spt.args [3].name])),
	sp.Sum: lambda spt: AST ('sum', spt2ast (spt.args [0]), spt2ast (spt.args [1] [0]), spt2ast (spt.args [1] [1]), spt2ast (spt.args [1] [2])),
	sp.Derivative: _spt2ast_Derivative,
	sp.Integral: _spt2ast_Integral,

	sp.Order: lambda spt: AST ('func', 'O', ((spt2ast (spt.args [0]) if spt.args [1] [1] == 0 else spt2ast (spt.args)),)),
	sp.Piecewise: lambda spt: AST ('piece', tuple ((spt2ast (t [0]), True if isinstance (t [1], sp.boolalg.BooleanTrue) else spt2ast (t [1])) for t in spt.args)),
	sp.Lambda: lambda spt: AST ('lamb', spt2ast (spt.args [1]), tuple (spt2ast (v) for v in spt.args [0])),
}

#...............................................................................................
def set_precision (ast): # recurse through ast to set sympy float precision according to longest string of digits found
	global _SYMPY_FLOAT_PRECISION

	prec  = 15
	stack = [ast]

	while stack:
		ast = stack.pop ()

		if not isinstance (ast, AST):
			pass # nop
		elif ast.is_num:
			prec = max (prec, len (ast.num)) # will be a little more than number of digits to compensate for falling precision with some calculations
		else:
			stack.extend (ast [1:])

	_SYMPY_FLOAT_PRECISION = prec if prec > 15 else None

def set_user_funcs (user_funcs):
	global _USER_FUNCS
	_USER_FUNCS = user_funcs

def set_pyS (state):
	global _PYS
	_PYS = state

def set_simplify (state):
	global _POST_SIMPLIFY
	_POST_SIMPLIFY = state

def set_eval (state):
	global _EVAL
	_EVAL = state

def set_doit (state):
	global _DOIT
	_DOIT = state

class sym: # for single script
	set_precision  = set_precision
	set_user_funcs = set_user_funcs
	set_pyS        = set_pyS
	set_simplify   = set_simplify
	set_eval       = set_eval
	set_doit       = set_doit
	ast2tex        = ast2tex
	ast2nat        = ast2nat
	ast2py         = ast2py
	ast2spt        = ast2spt
	spt2ast        = spt2ast

# if __name__ == '__main__' and not _RUNNING_AS_SINGLE_SCRIPT: # DEBUG!
# 	# vars = {'f': AST ('lamb', ('^', ('@', 'x'), ('#', '2')), (('@', 'x'),))}
# 	# vars = {'f': AST ('lamb', ('intg', ('@', 'x'), ('@', 'dx')), (('@', 'x'),))}
# 	# vars = {'theq': AST ('=', '=', ('+', (('@', 'c1'), ('^', ('@', 'x'), ('#', '2')), ('-', ('@', 'c2')), ('*', (('#', '2'), ('@', 'x'))))), ('+', (('@', 'x'), ('@', 'y'), ('-', ('*', (('@', 'c5'), ('@', 'c6')))))))}
# 	# vars = {'S': AST ('lamb', ('func', '$S', (('@', 'x'),)), (('@', 'x'),))}
# 	# ast = AST ('.', ('@', 'S'), 'Half')
# 	# res = ast2spt (ast, vars)

# 	ast = AST ('func', 'Lambda', (('^', ('@', 'x'), ('#', '2')), ('@', 'x')))
# 	res = ast2nat (ast)
# 	# res = spt2ast (res)

# 	print (res)
# Builds expression tree from text, nodes are nested AST tuples.

import ast as py_ast
from collections import OrderedDict
import os
import re
import sys


def _FUNC_name (FUNC):
	return AST.Func.TEX2PY_TRIGHINV.get (FUNC.grp [1], FUNC.grp [1]) if FUNC.grp [1] else \
			FUNC.grp [0] or FUNC.grp [2] or FUNC.grp [3].replace ('\\', '') or FUNC.text

def _ast_from_tok_digit_or_var (tok, i = 0, noerr = False):
	return AST ('#', tok.grp [i]) if tok.grp [i] else \
			AST ('@', AST.Var.ANY2PY.get (tok.grp [i + 2].replace (' ', ''), tok.grp [i + 1]) if tok.grp [i + 2] else tok.grp [i + 1])

def _ast_func_tuple_args (ast):
	ast = ast.strip (1)

	return ast.comma if ast.is_comma else (ast,)

def _ast_func_reorder (ast):
	wrap2 = None

	if ast.is_fact:
		ast2, wrap2 = ast.fact, lambda a: AST ('!', a)
	elif ast.is_pow:
		ast2, wrap2 = ast.base, lambda a: AST ('^', a, ast.exp)
	elif ast.is_attr:
		ast2, wrap2 = ast.obj, lambda a: AST ('.', a, *ast [2:])

	if wrap2:
		ast3, wrap3 = _ast_func_reorder (ast2)

		if ast3.is_paren or ast3.is_brack:
			return ast3, lambda a: wrap2 (wrap3 (a))

	return ast, lambda a: a

def _ast_pre_slice (pre, post):
	if not post.is_slice:
		return AST ('slice', pre, post, None)
	elif post.step is None:
		return AST ('slice', pre, post.start, post.stop)

	raise SyntaxError ('invalid slice')

#...............................................................................................
def _expr_comma (lhs, rhs):
	if not rhs.is_slice or rhs.step is not None or not rhs.stop or not rhs.start or not rhs.start.is_var:
		return AST.flatcat (',', lhs, rhs)

	if lhs.is_mul:
		if lhs.mul.len == 2 and lhs.mul [0].is_var_lambda and lhs.mul [1].is_var:
			return AST ('lamb', rhs.stop, (lhs.mul [1], rhs.start))

	elif lhs.is_ass:
		if lhs.rhs.is_mul and lhs.rhs.mul.len == 2 and lhs.rhs.mul [0].is_var_lambda and lhs.rhs.mul [1].is_var:
			return AST ('=', '=', lhs.lhs, ('lamb', rhs.stop, (lhs.rhs.mul [1], rhs.start)))

	elif lhs.is_comma:
		for i in range (lhs.comma.len - 1, -1, -1):
			if lhs.comma [i].is_mul:
				if lhs.comma [i].mul.len == 2 and lhs.comma [i].mul [0].is_var_lambda and lhs.comma [i].mul [1].is_var:
					ast = AST ('lamb', rhs.stop, (lhs.comma [i].mul [1], *lhs.comma [i + 1:], rhs.start))

					return AST (',', lhs.comma [:i] + (ast,)) if i else ast

			elif lhs.comma [i].is_ass:
				if lhs.comma [i].rhs.is_mul and lhs.comma [i].rhs.mul.len == 2 and lhs.comma [i].rhs.mul [0].is_var_lambda and lhs.comma [i].rhs.mul [1].is_var:
					ast = AST ('=', '=', lhs.comma [i].lhs, ('lamb', rhs.stop, (lhs.comma [i].rhs.mul [1], *lhs.comma [i + 1:], rhs.start)))

					return AST (',', lhs.comma [:i] + (ast,)) if i else ast

			if not lhs.comma [i].is_var:
				break

	return AST.flatcat (',', lhs, rhs)

def _expr_colon (lhs, rhs):
	if lhs.is_ass:
		l, wrap_ass = lhs.rhs, lambda rhs, lhs = lhs.lhs: AST ('=', '=', lhs, rhs)
	else:
		l, wrap_ass = lhs, lambda rhs: rhs

	if l.is_var:
		if l.is_var_lambda:
			return wrap_ass (AST ('lamb', rhs, ()))

	elif l.is_mul:
		if l.mul.len == 2 and l.mul [0].is_var_lambda and l.mul [1].is_var:
			return wrap_ass (AST ('lamb', rhs, (l.mul [1],)))

	return _ast_pre_slice (lhs, rhs)

def _expr_mapsto (args, lamb):
	if args.is_var:
		return AST ('lamb', lamb, (args,))

	elif args.is_comma:
		for var in args.comma:
			if not var.is_var:
				break
		else:
			return AST ('lamb', lamb, args.comma)

	raise SyntaxError ('invalid lambda function')

def _expr_piece (expr, expr_if, expr_else):
	if expr_else.is_piece:
		return AST ('piece', ((expr, expr_if),) + expr_else.piece)
	else:
		return AST ('piece', ((expr, expr_if), (expr_else, True)))

def _expr_mul_exp (lhs, rhs): # isolate explicit multiplication so it doesn't trigger imp mul grammar rewriting
	if lhs.is_curly:
		lhs = lhs.curly

	return AST ('{', AST.flatcat ('*', lhs, rhs))

def _expr_neg (expr):
	if expr.is_mul:
		return AST ('*', (expr.mul [0].neg (stack = True),) + expr.mul [1:])
	else:
		return expr.neg (stack = True)

def _expr_mul_imp (lhs, rhs, user_funcs = {}): # rewrite certain cases of adjacent terms not handled by grammar
	ast         = None
	arg, wrap   = _ast_func_reorder (rhs)
	last, wrapl = lhs, lambda ast: ast

	while 1:
		if last.is_mul:
			last, wrapl = last.mul [-1], lambda ast, last = last: AST ('*', last.mul [:-1] + (ast,))
		elif last.is_pow:
			last, wrapl = last.exp, lambda ast, last = last, wrapl = wrapl: wrapl (AST ('^', last.base, ast))

		elif last.is_minus:
			last, neg = last.strip_minus (retneg = True)
			wrapl     = lambda ast, last = last, wrapl = wrapl, neg = neg: wrapl (neg (ast))

		else:
			break

	if last.is_attr: # {x.y} *imp* () -> x.y(), x.{y.z} -> {x.y}.z
		if last.args is None:
			if arg.is_paren:
				ast = wrap (AST ('.', last.obj, last.attr, _ast_func_tuple_args (arg)))
			elif rhs.is_attr:
				ast = AST ('.', _expr_mul_imp (last, rhs.obj), rhs.attr)

	elif last.is_pow: # {x^y.z} *imp* () -> x^{y.z()}
		if last.exp.is_attr and last.exp.args is None:
			if arg.is_paren:
				ast = AST ('^', last.base, wrap (AST ('.', last.exp.obj, last.exp.attr, _ast_func_tuple_args (arg))))
			elif rhs.is_attr:
				ast = AST ('^', last.base, ('.', _expr_mul_imp (last.exp, rhs.obj), rhs.attr))

	elif last.is_var: # user_func *imp* () -> user_func (), var (tuple) -> func ()
		if last.var in user_funcs or arg.strip_paren ().is_comma:
			if arg.is_paren:
				ast = wrap (AST ('func', last.var, _ast_func_tuple_args (arg)))
			else:
				ast = wrap (AST ('func', last.var, (arg,)))

	if arg.is_brack: # x * [y] -> x [y]
		if not arg.brack:
			raise SyntaxError ('missing index')

		ast = wrap (AST ('idx', last, arg.brack))

	if ast:
		return wrapl (ast)

	return AST.flatcat ('*', lhs, rhs)

def _expr_diff (ast): # convert possible cases of derivatives in ast: ('*', ('/', 'd', 'dx'), expr) -> ('diff', expr, 'dx')
	def _interpret_divide (ast):
		if ast.numer.is_diff_or_part_solo:
			p = 1
			v = ast.numer

		elif ast.numer.is_pow and ast.numer.base.is_diff_or_part_solo and ast.numer.exp.no_curlys.is_pos_int_num:
			p = ast.numer.exp.no_curlys.as_int
			v = ast.numer.base

		else:
			return None

		ast_dv_check = (lambda n: n.is_differential) if v.is_diff_solo else (lambda n: n.is_partial)

		ns = ast.denom.mul if ast.denom.is_mul else (ast.denom,)
		ds = []
		cp = p

		for i in range (len (ns)):
			n = ns [i]

			if ast_dv_check (n):
				dec = 1
			elif n.is_pow and ast_dv_check (n.base) and n.exp.no_curlys.is_pos_int_num:
				dec = n.exp.no_curlys.as_int
			else:
				return None

			cp -= dec

			if cp < 0:
				return None # raise SyntaxError?

			ds.append (n)

			if not cp:
				if i == len (ns) - 1:
					return AST ('diff', None, tuple (ds))
				elif i == len (ns) - 2:
					return AST ('diff', ns [-1], tuple (ds))
				else:
					return AST ('diff', AST ('*', ns [i + 1:]), tuple (ds))

		return None # raise SyntaxError?

	# start here
	if ast.is_div: # this part handles d/dx
		diff = _interpret_divide (ast)

		if diff and diff [1]:
			return diff

	elif ast.is_mul: # this part needed to handle \frac{d}{dx}
		tail = []
		end  = len (ast.mul)

		for i in range (end - 1, -1, -1):
			if ast.mul [i].is_div:
				diff = _interpret_divide (ast.mul [i])

				if diff:
					if diff.expr:
						if i < end - 1:
							tail [0 : 0] = ast.mul [i + 1 : end]

						tail.insert (0, diff)

					elif i < end - 1:
						tail.insert (0, AST ('diff', ast.mul [i + 1] if i == end - 2 else AST ('*', ast.mul [i + 1 : end]), diff.dvs))

					else:
						continue

					end = i

		if tail:
			tail = tail [0] if len (tail) == 1 else AST ('*', tuple (tail))

			return tail if end == 0 else AST.flatcat ('*', ast.mul [0], tail) if end == 1 else AST.flatcat ('*', AST ('*', ast.mul [:end]), tail)

	return ast

def _ast_strip_tail_differential (ast):
	if ast.is_differential or ast.is_null_var: # null_var is for autocomplete
		return None, ast

	if ast.is_intg:
		if ast.intg is not None:
			ast2, neg = ast.intg.strip_minus (retneg = True)
			ast2, dv  = _ast_strip_tail_differential (ast2)

			if dv:
				if ast2:
					return (AST ('intg', neg (ast2), dv, *ast [3:]), ast.dv)
				elif neg.has_neg:
					return (AST ('intg', neg (AST.One), dv, *ast [3:]), ast.dv)
				else:
					return (AST ('intg', None, dv, *ast [3:]), ast.dv)

	elif ast.is_diff:
		ast2, neg = ast.diff.strip_minus (retneg = True)
		ast2, dv  = _ast_strip_tail_differential (ast2)

		if dv:
			if ast2:
				return (AST ('diff', neg (ast2), ast.dvs), dv)
			elif len (ast.dvs) == 1:
				return (neg (AST ('/', ('@', ast.diff_type or 'd'), ast.dvs [0])), dv)
			else:
				return (neg (AST ('/', ('@', ast.diff_type or 'd'), ('*', ast.dvs))), dv)

	elif ast.is_div:
		ast2, neg = ast.denom.strip_minus (retneg = True)
		ast2, dv  = _ast_strip_tail_differential (ast2)

		if dv and ast2:
			return AST ('/', ast.numer, neg (ast2)), dv

		ast2, neg = ast.numer.strip_minus (retneg = True)

		if dv:
			return AST ('/', neg (ast2) if ast2 else neg (AST.One), ast.denom), dv

	elif ast.is_mul:
		ast2, neg = ast.mul [-1].strip_minus (retneg = True)
		ast2, dv  = _ast_strip_tail_differential (ast2)

		if dv:
			if ast2:
				return (AST ('*', ast.mul [:-1] + (neg (ast2),)), dv)
			elif len (ast.mul) > 2:
				return (neg (AST ('*', ast.mul [:-1])), dv)
			else:
				return (neg (ast.mul [0]), dv)

	elif ast.is_add:
		ast2, neg = ast.add [-1].strip_minus (retneg = True)
		ast2, dv  = _ast_strip_tail_differential (ast2)

		if dv and ast2:
			return AST ('+', ast.add [:-1] + (neg (ast2),)), dv

	return ast, None

def _expr_intg (ast, from_to = ()): # find differential for integration if present in ast and return integral ast
	ast, neg = ast.strip_minus (retneg = True)
	ast, dv  = _ast_strip_tail_differential (ast)

	if dv:
		if ast:
			return AST ('intg', neg (ast), dv, *from_to)
		elif neg.has_neg:
			return AST ('intg', neg (AST.One), dv, *from_to)
		else:
			return neg (AST ('intg', None, dv, *from_to))

	raise SyntaxError ('integration expecting a differential')

def _expr_func (iparm, *args, strip = 1): # rearrange ast tree for explicit parentheses like func (x)^y to give (func (x))^y instead of func((x)^y)
	ast, wrap = _ast_func_reorder (args [iparm])

	return wrap (AST (*(args [:iparm] + ((_ast_func_tuple_args (ast) if args [0] == 'func' else ast.strip (strip)),) + args [iparm + 1:])))

def _expr_func_func (FUNC, expr_neg_func, expr_super = None):
	func = _FUNC_name (FUNC) if isinstance (FUNC, lalr1.Token) else FUNC

	if expr_super is None:
		return _expr_func (2, 'func', func, expr_neg_func)
	elif expr_super.no_curlys != AST.NegOne or not AST ('func', func, ()).is_trigh_func_noninv:
		return AST ('^', _expr_func_func (FUNC, expr_neg_func), expr_super)
	else:
		return _expr_func_func (f'a{func}', expr_neg_func)

def _expr_subs (expr_commas, subsvars):
	if len (subsvars) == 1:
		return AST ('func', 'Subs', (expr_commas, subsvars [0] [0], subsvars [0] [1]))
	else:
		return AST ('func', 'Subs', (expr_commas, ('(', (',', tuple (sv [0] for sv in subsvars))), ('(', (',', tuple (sv [1] for sv in subsvars)))))

def _expr_mat (mat_rows):
	if not mat_rows:
		return AST.MatEmpty
	elif len (mat_rows [0]) > 1:
		return AST ('mat', mat_rows)
	else:
		return AST ('vec', tuple (c [0] for c in mat_rows))

def _expr_vec (ast):
	e = ast.comma if ast.is_comma else (ast,)

	if all (c.is_brack for c in e):
		if len (e) == 1 or len (set (len (c.brack) for c in e)) == 1:
			return AST ('mat', tuple (c.brack for c in e))
		elif e [-1].brack.len < e [0].brack.len:
			return AST ('mat', tuple (c.brack for c in e [:-1]) + (e [-1].brack + (AST.VarNull,) * (e [0].brack.len - e [-1].brack.len),))

	return AST ('vec', e)

def _expr_curly (ast, forceset = False):
	e   = ast.comma if ast.is_comma else (ast,)
	kvs = []

	for kv in e:
		if not kv.is_slice or kv.step is not None or kv.start is False or kv.stop is False:
			if ast.is_comma:
				return AST ('set', ast.comma)
			elif forceset:
				return AST ('set', e)
			else:
				return AST ('{', ast)

		kvs.append ((kv.start, kv.stop))

	return AST ('dict', tuple (kvs))

def _expr_num (NUM):
	num = NUM.grp [1] or (NUM.grp [0] if NUM.text [0] != '.' else f'0{NUM.grp [0]}')

	if not NUM.grp [2]:
		return AST ('#', num)

	g2  = NUM.grp [2].replace ('{', '').replace ('}', '')

	if g2 [1] in {'-', '+'}:
		return AST ('#', f'{num}{g2.lower ()}')
	else:
		return AST ('#', f'{num}{g2 [0].lower ()}+{g2 [1:]}')

def _expr_var (VAR):
	if VAR.grp [0]:
		var = 'partial' + AST.Var.ANY2PY.get (VAR.grp [2], VAR.grp [2].replace ('\\_', '_'))
	elif VAR.grp [1]:
		var = 'd' + AST.Var.ANY2PY.get (VAR.grp [2], VAR.grp [2].replace ('\\_', '_'))
	else:
		var = AST.Var.ANY2PY.get (VAR.grp [3].replace (' ', ''), VAR.grp [3].replace ('\\_', '_'))

	return AST ('@', var + '_prime' * len (VAR.grp [4]))

#...............................................................................................
class Parser (lalr1.LALR1):
	def __init__ (self):
		self.TOKENS_LONG.update ([(v, self.TOKENS [v]) for v in self.TOKENS_QUICK])

		lalr1.LALR1.__init__ (self)

	def set_quick (self, yes = True):
		self.TOKENS.update (self.TOKENS_QUICK if yes else self.TOKENS_LONG)

		self.set_tokens (self.TOKENS)

	_USER_FUNCS = set () # set or dict of names of user functions to map to AST ('func', ...)

	def set_user_funcs (self, user_funcs):
		self._USER_FUNCS = user_funcs

	_PARSER_TABLES = \
			b'eJztfW2P3LaS7p9Z4HgANSC+SvI3x/E5G6ydZGPn4C6MIHAcZxHcvK3tnN3Fwf3vt6qeIiWxJbV6pnvcMyOMpiWRFFksVj0qkkXq0eu//Mu73378S/WXp189/+pLOj9/9tdXdPr6yTfPvnxOF3/95slTPRk9Wzp/9sWXX71IZ5MurGbw+Vecx2fP/vb90ycv' \
			b'n73U6xdPUuhn/eXf+8uvcfny+ZOX//oZlfNvXH6+ePHFl9++TNFPv/3m+X9waL54+eob/v32M/p99uLrV//x8hln9uW3TOXfn3DkF1+++hsT+MULSSm///4Np3ouNf+KY//67Zdc38/kiadfvXjxJHGDA7754m//+ioV+00ijy+e/Tv9PHnxNf1+/tlzIZJD' \
			b'v/xcq81Xn/WXf+8vtdrPnr98piGJaZzRKxBCBHCiF0++fvnqKy7pldT32f95+jxFcyt8/sXfv/ics3mKJtDHv34O1j17lbhIWYPYp0+U5FTEVynJ01QZ5cW3fPvFX+lHKCBWm1FzKP+pyKf/Rpcf/vzhwz/evP/wj8H1B7p+++b9u4/f//7++x9/+OXDxzfv' \
			b'B9F0Sac3kuzd//zx/vsPf/7x7n26+e3df37/05+/ve0jf6DLX998/P7t77/o1fvf/7u/Qmkf3n348DZf/ZGvUjZvfugvP37Mpf305u3HdP2H5IrgEQG/pstffs6XP//28T/T9a9//vL9z7/+kW7/8aavTP/sjz//I11+fPd+EPzTT+n67Z/vf/nfAR/S5Q/v' \
			b'37z9v+8+Douji1zcu0zqmx9/zIne5PT/8+FdX0nhSq7asHRunnT9528///5bLv7n337P9L7t6/kTkZV59/O7t+/yDbX9bz0hf3z4+Hu6e/dfepXz+/2XvqS3v//665vRzYe/fFe9frTzXeXbqwoXHV+4ln/ozlzpLd1Jipp/Kjrt/NUoAAm79BzF5yC+lFS7' \
			b'ICFN9chWzlU7U7lIF1cpVMNywK7hC9PiJ1CARaYpiI4yKIyC+JLzivgJWp9I9UHepnpE2RouGMVySDu86/TMQXRlDVNvmkR9e5VCNSwH7Kw8YAJF0R0x0TdXGrIzKJ65Z2wVuXx7pUF8yVQKz/jJq8Ftuh6EG5yoRbhg+Xc+RVu+4Hw1HIUQcRqIRE4q1Wml' \
			b'YpdDNazpk9XjgJ2VRrVUoI1yFfETOEQz6oOkTXIoX9IVcWhHrKSi4hXud5KVC/gJYA1dUdPxFYkZ5S6NAoZQQBjcaCIO4OeY7E7azFcsyz5cDcJ3Pu4H9beu3kshQYNblna/HxT3gwa3dv929MDOSXtSWY+YU1IAnQ3kKwX3tzuHyrJ8NpW1FbeUbauIarPy' \
			b'KBunU7D2k4qtS0jNOE64cyJQ3NBNFeokfUShIItpVGsM19NU3g6UhyNzeB/iEOL6EI8Q34cEhIQUsjMiULbGTwiZxhwUh0F8yVcdfoiPV1f9JV+RPonM6iNEppV28QERWrZn2QRAEMckBWAu4QSSMchJSLrdCb0tFD8SbaHiVoYeDIM1gO6F4x4/JBJXek/q' \
			b'IUzw+ImsHIjMQXYYxJdMOEVyraCTdBfRYKz7dYboJAS+TaovkAk8JxaRcKQUECHfs5lFG6yhwEd+wDO+7XLRhA9gIDdak69avbImXdh0AWCziqFcJRWNFBSGQXzJDxKp4BQ1uokDzGasQykm4id0WcNSUKyHQXzJtDv8DN6LCY+9xY+8EiHL3solX5kUeaW3' \
			b'dJciEEQy0NTCWdIq5b3wUDgUWKqDSRmw4gWpQTApQpJqkD5FbSR8kHfz1RUZAa85b8ZGCiKY5TanEOKMvKhJuthEIOOganzVhKqzVeeqjoLpOlYdqbyl1mOAJ5VjDnf8NiGq6T1IgmFY8/l9TYGmDvQf6b+mf0P/JDixsowN9C6jF4mhtm1i1TRV01ZNV7V1' \
			b'1VI6iqQ4epiepWwN5dvS4arWkyiQ0lG7Vm1TtS23A0CG24QeMkwCPc8ZcA6UhRdFI050nBWVQM9GRrhIOEf1rKvGVI2tGnqsJtrqlqGDAJIMDBILEgPSsCivbpI8kjTS0q6tuo7Rj1jNNaYKUx05/++qRzW/p18/IjZzAxGr5UTEEP8fEcMRWyPY4OQl9jW/' \
			b'HeRe3vVby5y4ZTrw3qNJ+O0mTG+83DOF3ERNQLIObdFIiz2yML882o0zlWc7tNSmUudtOK9NIk3zqEOTdI02QpCWGjFNGQXmTDBEmZDrPqz1VJVRUyIlqHQEd4tlavUtBNd2kEHT6LlVPhiJOB8d1iod9ZnLMSjHGK1pnbTOpJrWYdO7s+sdt8DG5vPDmxQs' \
			b'bya7sfsW2F2rEcYVxpvf6TnZYVZSEMkV1aKiLDe235jttlGuW7zFjTJdra+QWO83HbgFZG+kNQz3Q7gTwh0PNi+YVSz8xICNyTdncrsx+fxM7jYmn53Jbb0x+dwvyDZ1e9C9bWGctE5fjK0gtpLve/LOS1ffksMGvJV+L5sKW//jNgxiq6IGU0zts7bVTsnW' \
			b'BrfQBt4pt9EGHm3gI8YkhUQZ61GjOVnNRrsyHmNBrTx2D7HgUWe0i4ahoFbrHVHvCEOr5mr6kSxkGXhAwPko6kh3A2Y14F2TBrhVhmodP6xV0QPeOwHBQVlKWUmVTNV2VVffUZZQ7TCWGOv7Va2Ito3Ah+hGenB/agm4iwJvqMqwcne2WjqRUaqazCxBXkOa' \
			b'aQoKgI2+Edo8zWgxv2i3GcPT93uIoxbztBt7T2/0ECutzsjSeePj9cdA/Caf5+BrJwK69X3OLb5RUJZJ3bh9dm77emPzbcydb2y+DdcgBxOiEwOYXYPotDH1hrIb5L13S72gCQ87dnrShrViG45bpW+NYTs89GGf1+ISxszaGDTLoHZj0CKDOvDnbK59NbSa' \
			b'W4AL2pg/ZH5tNqYUAsM5W5npkJPXEQODvsJDZ89r8VnbGCFr5EQw1IjAhAcsiTS9gSHk5EEs8vMQWfWaXe4ebt3DQ637IyAFe/4BQnUNktFFSOLQA91IKwxsmn6G7yb7s0kOYiSwT5Bk1AomPyBOvmannIdVZfY+UsMNU1azi6O+05VUlXjvyDvb6Cg/3uRe' \
			b'kPoecyqgulH7YqNZvQgNmvF9lonbq7wg4FNYWz57Dlh4Dlh4Dlhp2FqlIOiAraTu+kEuDLxgqAvDL+WA1zYac/QQV2iV6cL8uz2RL+pw5ysBEPwE6on1WPT+ufNcfNTpOunQ3XWpZp8iIL65+1XRUddo735VvFYl3PmqdLAaAl7KJrv88N4S/IK9ku02+EQv' \
			b'XQfzzF1haN3B5N+898+9vM2hHdAcBqfOoR06tFXHzcFvdG0ei0abWMlNIW565bNpJ2N45NalkVU3uaiRk07FyBgb6EAVlDqjVZozVq2fj+bxGIfxGDEg+XdbRnmauTnhqBjgGzdvPksPGS8X2xg/HRwmgh+pIjSN6o06DRqdutwg9mSNZTexP8nLqlFroYM4' \
			b'10mqHaTa6eiNw+iN09Ebd59XmLzmgSl3jwemZETKbVNFMspmdZDLYZDLYZCLuZPGKZRXXQoJMZnb5qrcuIuHZmCUdTpZiTdAi9sANYsoJ0LNYkiWuldL3afBeViTHtakhzXp1Yz0m5/0TXb+COCysD4kM1ct6n62Q21Xjza5x5BHlfLzFn4D6aPaeuiHT4PA' \
			b'eKjL68b8Xe9gU4mqhSFZctDCAC0M0EI+kb7hLugzCCYuBXApbBbKSdxnG+ZkMX/CQrdZgKeYVFBJj7yHMjZUi/y+o/z5pda/96joCPGOEG9OVuUmig9rGpQZ48C3RkFAzk4R1PXzZ82D4sxrlpAGEtLIawIzw3mpcWJXiy6yum+xhxspEG+WyjulJrFj/rWQ' \
			b'uhZ5tspl7WEHZXfUc1oV6dTZp5H93B8W/+0Dq7LIg0/yYFUO7NVQjBjQIUBy5gRObJu6ek0EyhZvPC7J27zxQ4LrQevIVQBdUd8iOpWNue6E58zpRl9IYNGQFczbVrhqpxuBe1+dVjAK+Mt+HPL2aTFYL4gcoSLsZMH7BDJz+GXCO0XwNhG8AwTvbMubhXIL' \
			b'8Gp+XsrP6/h57TsvfOfF4rxSnJdT81pqXn/MOyjw9gnMKmYTiwXviMvb4PL+Vby9Eu/+wy3F41486MUbhbBVzF4gvAMu78/Ke7Pyxqy8KysvaCZ5sey0STy1PGPBIiEMZaGgMN4+nVGAvUPYq9Nz2/N/oOaRr0nI1yj4Cw6857mreJ9/3kWcd/gm4nZU6I4K' \
			b'2/He7/gGQYVt2+VrAfJRAN4WvObNu2sO513jeafxVnZM5xsKbflJDuStth223zeyibhsfC77p3Niz1u484O8Q3fLO7dTCQ0nIf3Z8c7tVGHZeps3i+ed0bFZPoXxtxP4oQa0t/zVg1bJC3JBKcl23vGW4/yFCN7hnFgou3zzXvfyPQRsyr5rOI6ZwXvFW9mt' \
			b'f2dkQ3wuV6pd82O1wXcTeA9ylqWdwZcb9BsYXC3edJ3ODX9/g3OmZ1umk2mUB0yFncqZTi6hFqZyEq4qf8WBYnmzed5/XXazZyYxUcxIoYLu+WmKa6QdJBsKIQXYkcTtGvsdqyUr40gRzbwuCkYATEZK6ZJemrFqxhtpZ1MYfwvK2qxU2E+lrOZIhW2PVNrA' \
			b'LAulnq7QVEnE6jCpr73Ghn2dDSfUWinKWTnjb1F3V2vvJ9Xcxh6rvJzrUQpc/dM/ZpAOjxmmG0sn8//E9iOtJuMjaXPuLjUj+6BQaHUYE28xXTOZvcvq45W7Gej3wKCZ0HW/p+tGenReLShYVhjmIJlCXzOvIqpLWyWiezlCCN+jBHdJh/PxueM1YRELgpgx' \
			b'ivC+IIIeUdEioQQ9w9v/8NY/kyjB/G8OowVvsMQ7zvEuYIdQg5doZOSIM+hBrcxtLAhigCJsrY2QhNJSE/aIwkamfCZJTlQ8Szc1rJxwZy1OpkqJWchqAAmfmeH16EhwklMWmMJhC6Ai7+0hqEjAEFhgqPb/JdAU9AwPqZkbPd0Cg8pMp/4TTuEaWCWAIJsB' \
			b'CV4NcxV3MqlNrXSms9Oz1/gezqQhHBAMRhaQysbcAPsopTFLWDWqBmvTYdQyidpGqdwHLy04aCM1MeU/gLFcaoaz4B7zm4N09jHEqSVo8yLkdI6MbS5jW+oHwVJRM+WSIW2IZ2vBLBwBaBuYzYAZC7mop4ghzKJsEsEcSmmE4YphBhhmRkePYZppAWHmAISV' \
			b'CFYC2KCkErzM7AHkSje2XkzbylgA0KroFAlcGYUrZQjOAlSKUwpTilJjkDLzIKUZToAUYpZBKj+/DqGUg0rRBD4p39AEKhcFOiGqxKZ9SPKFuXWf8Wgzrk6AR9wXhQL6aTDSBCxJXsHIA4z86MhglHIswMgvg5EvwMgXYDQsqQQjP3sIGOUblpSFtMlu8hmJ' \
			b'UGPNaVAQoMgDijygyAOKPKBo3P0zfh6KNMMJKELMIhT1BK2DIuWfUjQBRVpXNEATNe8hFClVR5hJYcOkDZOOwSSuHFQxTmOSJsBIAjApApPi6MiYlHIsMCkuY1IsMKkYOhqVVGJSnD0Ek/INS8pC2oRJscekqJgUgUl97YwByTUI0pPDCQ8MMSnOY5JmOIFJ' \
			b'iFnEpP75dZik/FOKJjBJuaZFp7yHmKRRR2BS3DBpw6RjMIkJhSo205ikCSBJwKQGmDQ+MialHAtMapYxqRjL5vsRJg1LKjFpj5Y+KWNSvmFJWUjb9oxImNQoJjXApJxUMKkBJjXApAaY1ACTmjEmNfOYpBlOYBJiFjGpJ2gdJin/lKIJTFKuoQGaqHkPMUmp' \
			b'OgKTmvmh8juATHYDp08GTuLZJjrZCTjxCQ4YI4jSZAYxAlEdIKobHRmiUr4FRHXLENUVENUVEDUsqYSobukQlMo3LDILaRNKdT1KdYpSHVAqJxWU6oBSHVCqA0p1QKlujFLdPEpphhMohZhFlOoJWodSykKlaAKllGtogyZq3kOUUqqOQKl2Q6kNpa6DUvwg' \
			b'hr4txr35xK65ZoRSKZlBjDiNYfQ7R2oSRamc7xil7PLoty1Gv20x+j0qqUCpgpCSLt60NN/oDPdcWkUp249+o9LKnUFZglIWw98Ww98Ww98Ww992PPxt54e/U4b7KKUxSyg1IGgVSiUWKkX7KJW4hjZoouY9QKlE1REo1W0otaHUtVCKHZygkxYoZYFSdoxS' \
			b'mswgRlAK7kqIyUdGqZRvgVJ2GaVsgVK2QKlhSSVK2aVDUCrfqE7MpU0o1Ts/odLKnUFZQCkLlLJAKQuUskApO0YpO49SmuEESiFmEaV6gtahlLJQKZpAKeUa2qCJmvcQpZSqI1DK1Jt31IZXN8Mrz9Ih2okJPIuxKTnhDgIkqKWJDeIFtTCZh5h8ZNRKuReo' \
			b'tTyZZ4vJPFtM5o1KKlHLLx2CWsN75t1C8gRc/ZSe1Sk9iym9PqkAF6b0LKb0LKb0LKb07HhKz85P6aUMJ4ALMYvA1RO0DriUi0rRBHBpXdEMTdS8h8ClVB0DXGYDrg24bgRcLAtw63Rw6+RTCDjhziKOikiJDeIZuBzcOhGTjwRcOfcxcLllr06hZABcfD8E' \
			b'rlFJBXAVhJR0keCO7u1ycgUuuQRwod7KpkFxAlxCuJKlJ4cTHhgAl5v33UwZ7gOXxiwB14CgVcCVuKgU7QNXYhyaoYma9wC4ElXHANfmj74B1w2By7MUiHbC4nKwuBwsLgeLy8HiSokN4gW4YHEhJh8ZuFLuBXAtW1yusLhcYXGNSiqBa0wIN+IoeXDje1uX' \
			b'j4zr0WTeJORSk8vB5OqTCnLB5HIwuRxMLgeTy41NLjdvcqUMJ5ALMYvI1RO0DrmUjUrRBHJpXdEOTdS8h8ilVB2DXG5Drg25boZcgUVAtBML8vgUEBhwZxHHyKWJjZ4ZuQKQK4yOjFwp9wK5llfnuWIdjSuW0YxKKpErLB0CXMN7Bq6F5Am4+lUzTt3QHVb5' \
			b'9UkFuLBkxmHFjMOCGYf1Mm68XEZuZ4BLM5wALsQsAldP0DrgUi4qRRPApYxDMzRR8x4Cl1J1DHCVPukbcG3AdSRwRW5/0U54hPIpBJxwZxHHwKWJDeIFuOAdiph8ZOBKuRfAtewd6grvUFd4h45KKoErLh0CXMN7Bq6F5Am4eh9Rpz6iDj6ifVIBLviIOviI' \
			b'OviIOviIurGPqJv3EU0ZTgAXYhaBq39+HXApF5WiCeBSxmnRKe8hcGnUMcBVOq5vwLUB15HA1XDji3bCbdRhBwQ54c4ijoFLExvEC3DBhdSNjwxcKfcCuJZdSF3hQuoKF9JRSSVw7dEySs3ANbxn4FpI3vasScCljqQOjqR9UgEuOJI6OJI6OJI6OJK6sSOp' \
			b'm3ckTRlOABdiFoGrJ2gdcCkXlaIJ4FLGoRmaqHkPgUupOga4Su/2Dbg24DoOuLi14azl4azl4azl4azFJ4s4Kym9umx5ddnycNnyZnQk4Mq5j4HLL7ts+cJlyxcuW6OSCuAqCCnpIsEd3dt6MbkCl++9trx6bXl4bfkBU3DuapClJ4cTHhgAl5/32koZ7gOX' \
			b'xiwB14CgVcCVuKgU7QNXYhyaoYma9wC4ElXHAFezv6PCHcUud234OmabhQ3CFmwvx/IgWy00csXml4P55WB+OZhfDuaXpjeIF/PLwfxyoyObX6mAwvxyy+aXK8wvV7jHDwvcs7/c0tGoCTaklU2w+SdkAwa1wlxvhTm1whyssJxarDAHK8zBCnOwwhysMDe2' \
			b'wty8FaYZTlhhiFm0wnqC1llhSqBSNGGFIUFAazRR8x5aYUrVMWBWesofXGOYvo/46QHsnN6np8Qrvm9OiFu3gFlUT8v7V/v6kAlWVx4OEr6eXHKYEpiAM5tdte51ZTU2H9n0SrkWpteyY8TeHnq+8IxAk/b/e/ZXPXuI8ZVv7HxC3/tF8BuG0Ur2CMzbxXi4' \
			b'RmQaZF2P4pVRwDKKWEYhyxSY5afdIyDyaogpCycMMcQc2o7Pr3aSkGaJKH0GuxIT0SaNnCxv5cdmbGmSKX0JxUgKHmPNAZ8bQa1uM8E2E+xUvchYeYzbE7keQ/ceQ/ceQ/ceQ/ceQ/cpvUG8IBqG7hGTj4xmqYACzZaH7n0xdO+LoftRSSWQxaWDNZ/hbJgB' \
			b'I9r8E2KBtYD5fgDf6wC+xwB+n1q6kxjA9xjA9xjA9xjA9+MBfD8/gJ8ynEAxxCx2J/vn1+GY8lIpmkAxJAhadMp7iF0adYQFZjf3+ikEIxbo1+geJpK5GTQLa9ztm8qqTzkG9C0G9C0G9C0G9C0G9FNig3hxt8eAfnFkd/uUe+FuvzygbwvbzBYD+qOSSnf7' \
			b'PVpGqdndfnjPPFxI3vasSe72OqBveMPsrkamg2Lhdo+BfYuBfYuBfYuBfTse2LfzA/spwwm3e8Qsut33BK1zu1duKkVT64W6zEQ0ibjeOy1j6H6v1B0DbJv7/Waa3cw04/bEAH/AAH/AAH/AAH/AAH/AAH9KbBDPQBYwwB/M6MibtKfcx0AWlgf4QzHAH4oB' \
			b'/lFJ5b7tZulgIBvd23oxuQJZ6Af4gw7wBwzwhwFTcO5qkKUnhxMeGABYmB/gTxnuA5jGLAHYgKBVAJa4qBTtA1hiHJqhiZr3ALgSVccA1+W438995WaDrxPDl2zgcJalj/I5ITE40LW06FpadC0tupYWXcuU2CBev0UktlgcHdkWS7kXtthy19IWXUv5dgNz' \
			b'nR9nbqPwVrM3+K7QnlUWlw6xyob3zMWF5Mkq67uXVruXFt3LPqlYY+heWnQvLbqXFt1LO+5e2vnuZcpwwhpDzKI11j+/zhqLMOvRxbTTXczEPC0+5T+0xDTqGEDbvPIfEJSdxxKzlegPTviGmlhiFpaYhSWGMf+U2CBeLDELS8yOjmyJpdwLS8wuW2K2sMRs' \
			b'YYkNSyotMbt0iCU2vGdLbCF5ssRsb4lZtcQsLLGcVCwxC0vMwhKzsMQsLDE7tsTsvCWmGU5YYohZtMR6gtZZYspFpWjCElPGoRmaqHkPLTGl6hjg2rzyN+C6IXB5bknRTiyEDJijDFgIqTOVAQshU2KDeAEuLIRETD4ycKXcC+BaXggZioWQoVgIOSqpBC6/' \
			b'dOxUcPM9A9dC8gRc/TrIoOsgA9ZB9kkFuLAOMmAdZMA6yIB1kGG8DjLMr4NMGU4AF2IWgasnaB1wKReVogng0rqiGZqoeQ+BS6k6Brg2r/x7Alw6JHxyAOOR10kQcwWQuSGYBW5a0VisjQxYG6k+FwFrIwPWRqbERs8MZlgbiZh8ZDBLuRdgtrw2MhRrI0Ox' \
			b'NnJUUglmYekQMBveM5gtJE9g1q+NDOpzEbA2sk8qYIa1kQFrIwPWRgasjQzjtZFhfm1kynACzBCzCGY9QXWq6wpIU14qXROQphll6pqohSiqBQW2nNdR2HYR29Lfso+YItehL6beFjIdhUYnM6WaKqiKNZO+XikBI45OJQZMJYbxkREn5VggzvJUYiimEkMx' \
			b'lbiHMnvl94SwfOUbxpeFtG1f+dHXVTFbuDv0edUwPyuY+DABIohZBJG+MgeRA+lmvp+acgFHm6iNOLSElJoSLSZAotwnfgOJBwISHU9aiJ500yChCVhzOgWJDiDRjY4MEinHAiS6ZZDoCpDoDoBEN3sISOQbBomFtAkkugIkupUg0c2DhPJhAiQQswgSfWUO' \
			b'ggTSzYGE5gKONlEbcQgSSs0KkDja+XwDiXsBEjyhiXn9aCZBIiUgiYg6lx8xlx/N6EggkXMcg0RcnsuPxVx+NMsgURQ+IoTkq7+x9WJaBYloxiARzTqQiPPT84kP+yChMUsgMajMIZDQdDMgkXIBR5uojTgAiUTNCpAod0n/JCBxj5en3KfRXm4nB91y08Ci' \
			b'CVjbnAKLA7C40ZGBJeVYAItbBhZXAIsbA8uopBJk3OwhIJNvGGQW0iaQcdX+N4slrzZXzhhQXIMePSl1SD2EHzcPP5rhBPwgZhF+MunrhnYTgUrRBAwp08D/JmreQxhSqg7DkCvdtDcY2mBoFoY8t5Non5+GIU3AMKQTTRETTYjJR4ahlGMBQ8sTTbGYaIrF' \
			b'RNOopBKG/OwhMJRvGIYW0iYY8lMwhEmmzA0DimvQoyeHE9IMYWh+hillOAFDiFmEoUz6ShhS9ilFEzCkFQX/m6h5D2FIqVoBQ6VT9QZDGwzNwlDgRhLtC9MwpAmMnhmGMEWEmHxkGEo5FjC0PEUUiymiWEwRjUoqYSjMHgJD+YZhaCFtgqEwBUOYHsrcMKC4' \
			b'Bj16cjgh9RCG5ueGUoYTMISYRRjKpK+EIWWfUjQBQ8o08L+JmvcQhpSqFTBUukhvMLTB0CwMRW4h0b44DUOawASca9wzDMXRkWEo5VjA0LLbcyzcnmOxonZUUglDcfYQGMo3DEMLaRMMxSkYgqNz5oYBxTXo0ZPDCamHMDTv5ZwynIAhxCzCUP/8OhhS9ilF' \
			b'EzCkTNOiU95DGNKoFTAkjs22IvggMCJVJ0DqBnsCOAUmFmNgkyvhibT3U25s4o7BKXfSPQGuAVdUecM7PXBrUP17+AqAMKq44b0tSCYAZ/Q88cDwVhZn2w7lGIjzK2HOXne1B0kwMXDHu7jy3vmyHQaJPmbEdtzQHYufoGDXDJCwy2i44+aTjHSazKpptuM2' \
			b't7DPdrxWozjyohB9pFwUsmyk7e2eYgsrbVRUAY873v2RuLRztqRKHxA/pnTDfJYrlorp9LzjALhmp0w2C5MtVZUbFCabhclmYbJZmGx2bLLteHdw+coOA59Gc0tF4KeVksSToVU0rQW8jCwUytgq62aMfOGr5/rEWhLEHNpwJWWw8lOAqLFuWGCnTb5d1/Mf' \
			b'DdpELWS4okTpy3j7WEL4l6CXfhsjv5Z/GYUtQNgGwWBPYl8i8Bz2xgS5wFsA7BBal3F1cs5OUJQBs+vttRH4rZht2wO2NaA2AWiTQHYAwEjnDgLX4gycVZByBTglUOKGnQekg1CUlE4BKKNPgps9oDkKZRbn2xKkMHrsbL+z0hgP1kyZlSq/Vt+ndX1Kyw/q' \
			b't/D/oGInjZ5TZ1Zk1uKxCiflZX0ME/q4YA6dQyWTbUOsuMuKeciaqAvFPEYpD5gJ8vK/aM3sX/hGFx7cfQ1d8Z3wZqyhR2tnPOJt6c+rnaM+h6gpS/ypNJVoMkSRCSwg7rI090av00Oae1Br3cVorpAy/FctNoP545trsgAld13IsuUu2EVq9lCrLRN1lGZX' \
			b'/yQ5ekykiEXcHGcRN4d0/OB4w/JLGKrtB6OZ7f16EWd19gsvYrrnzql04ymdi2P15g6Y5zDu4vMnl7kPbofrb+g/nkL9RY9cd5z6u2Vv1xtAQFb5fpKEGX9PX+C5w5x6zBNqbvHpDbi3WqFs79uI/dCPRAu9XDHsF51703zTyHu/vX4v2SVMMKczzGGV10NQ' \
			b'aK7nqHrpXWd+8Ryy0pnd53vfz73rWcKSwgse3M47Pyl84wcKXzqJuZX+6heg9DyKu8Zy7w5a7lY3Vp97x5O8PSYpkHd8V72+2yNel/4uD9c2z7OaNv4EWnq3RrnuzOt3enJwjaXdPCb4ZR2kZy5DB4mVTKtsMX/f9LFmnbzZQNedH3bGHKWU39xn7dQ6xpsN' \
			b'cVFxF6GWxPmOlTNeiHLOzXPfVEHZ76o9QlHtvrLmDu+4o3v3FZcTt+JLsGPHh8tR4PO9Ybll+KF2pSqnjm7Zv5WObLvXkaWqXEu7/Tneu+EM6r3WpWXt+zeeQMXNJb6Hma2f5GUsZZvTa7RU6PTvZfa2OsnUU3uMWi++od31dDicQ4cH+ltfYn/2FPq76a72' \
			b'bMd6y4y9iLfxGdX2VCrrr6ey8cwqK762m8o+IJXtNpVdqbLheirbnFtlzaayD0pl2wseUr4wlY2XMXR1efp5SoerBzZ6fDrd47UrFzVgfH1lq/5JsvmYwEQmcprLUDsSKB00/pT6t7go6kSDxQ9ZH5nJO/Z9uIy3ojv/YPCNXontLevm3HrJ2dejKdY5XvBr' \
			b'cs0axYO+yWHg0HiH1RSLUMf/a1+jkna0HvASbNmD+rpuad+hFUBSefFWmpq46V+wsXlMUCjv19t2Vtp0+KHosNn7X6/D5iHrsIEOc9gqHabqv273tloRhWVtbUVPvWjoUD1FN1XjRhuN6CYjk1IPad+TXpFUywtKVQqLbTwGgieTckZFLS08nxKvLFpJQoZ7' \
			b'WOj+FZONkxul5DC4Gdh2IR5cm2dArIRVEdgkW7YMueivx0lrBtwUhTgxO42oczsYErIpv6aa2yfkOD6bgtf2BrxuZ9h9t1juetzbY3tCr7Ow3t2A9TOv6mFLmONezNdorXUv1amXaRj0V8/WslLj8f/oLTdobYk78o12LZlY+R6aEB0hse/2hfFrxh+QpZuP' \
			b'uNxwiHNWvG57nejiMMkRYjhjkakpd9PBj5sPQs6J5y0MKZagd2BI0bePyY4VMQ6bGN+qGENQzzeGdzYxxv5Z+L8QMXbd4518KtA8ZiUjcXjMikYiQWfZc4cy2MT7dsXb3VXxdvn/7oh3syjeJ5r5OYeEf8p9K1TSXSsjgzyycBOpl3GTW5icmRoZqs0NJR8b' \
			b'JJpz2ylSxIIGWBkwoqhZXSDGPmZFp1als+weQXXehP8TwLx0qD6VwLsbC7xDLucWeHctyJ8S825WzE87wX9KSb+kbYpuJvE89Xubc/AnNXB4F9zQmzm37ulylPSTrMf5sftN1m9B1uNdlnXQf3dkfXLO5Ty+WycS94txjDyF2LNYfUJfq5PJPm95XleX4tt4' \
			b'tBZMzoZtWnBrWmDuiRZoVe6oFownJs/tyrspQq8ILHGX4n97Qnvo0nzej9YIfyc14pJWj9xIK+I91Io23gfFCJtifErFaO6jYjT3QTHyVO9trYjadAO6waJ+AT7WZzSnLnIZ4dEK0lSvec8y49B23MReIlqK4K9hUjicFxHcVa9tzYlJHDiAsqPLjgNc+O6K' \
			b'zo928pVdliB8nqrhTZh5++U4+miCsQ3nzZ85Icr582xe91RusMl6+Q2EWijY2SNyJ+mc/pOcHD7DOZ0XNnsOE5k6Xocx/uv3cW77UCnDT5RRl9/KWy4S22rlhY08+c97gMoX1r7jtSn9H0ug1+2A+n+/9yd7P0tsLUsa5QtlvPwfG70L5eGGlDPsHCQ+Vmv/' \
			b'eIlKESZkxqPJnPpk4Cyl/MG7TC09sPjHS2rm/njpCp2F5mYVzbWSze+cZuRrvPSN1vThw8NfZ1Xhyp80pDD5lCGFyScMzSRHhp8N7D8HGKv8yT/53F+T9nj/jl/A03+M3uk89T/9xLH/y09N592O4otnpAXbW5S6rrrRn9DbXYzEuULqzBkljwv+tEfbDm74' \
			b'BXfTLKU1CalvT/y45c54oEImV4gt53gGKbUXLaihwsFk+irfnu6I58h0zYH2tScRWObrOpltqxMcoVmIRr1cIbfcTzoHxg6klyDl8gSYOw6Dg2hsu6oIPO3B3eKzFrB3oMWPN+gXX5rr5JkHK05xpDGF+SSoZNjEGmLdVvf9QIOfphdVvGFXynZXnfBII2Xz' \
			b'SVDhZpNwkXAe+rznBxr8iB4bNe/R/Z0ZUc8NkcWdB5rXHTwKekRqHRLej+GB3HQDXnSb8EP42+q+HxgyPaK/eB3hHzbmekXoqvMdw0mRxZTgT9n9fKgKwZNf9/xAg6/rj9Yn0onUnut0Y6pdXHXw4BmxNekO5KKzhcupMPfXz/sJT7e+sDaWr+77gQZf1xW+' \
			b'HCUK1UUeYObW5dZWaqr7fqDB13W5L0d72uoiDzBz685rK3XVfT/Q4O29b3DDfmRdPd3wPJKVGp/tsfxBdXbNYW+1e3FYYil/y3gvOExdQTCOnOk+EawmZ4rJNo0r4JWl8hYPFrT9UBazmSfgMLVuHGGsaefn7wRIzvM5VusP9oc76oFrZj1ZDjhu7j7H2+ou' \
			b'HGD3keMCF8hudkm+AwfYPeWBeX8d4dhV/MgDzuL9/zWyOJzp+gImU6ApjxwMuOtN2VT35UDzrfP2vTfN11b35UDzHTmYcNebr6vuy4Hme1gO4fwxi3tyoPna6rWr2VNbwbRL99BOarjXThjHYfIhKYSTcT9sYOIu+y7Kh9l5DRkvcyHe1fBg8HY6dayKf6R2' \
			b'e6m5xeSJpir/bQ1B9H646ofHLZRSej0M5W1JRqjt5Wle7UYp0yq3vOIs7K82s1pKHJfCC9ywT7lk2GlRKoq8bI5FTh08+DNoMlzCQyMyJCKrlAwJoWN/YgrVPhV/lCktWcJMBn/ixUqLWZ0xD7ysyUsOOl7Ln0NIIZTmu6v/D5Qw4UU='

	_PARSER_TOP             = 'expr_commas'
	_PARSER_CONFLICT_REDUCE = {'BAR'}

	_UPARTIAL = '\u2202' # \partial
	_USUM     = '\u2211' # \sum
	_UINTG    = '\u222b' # \int
	_UXSECT   = '\u2229' # &
	_UUNION   = '\u222a' # |
	_USYMDIFF = '\u2296' # ^^

	_LETTER   = fr'[a-zA-Z]'
	_LETTERU  = fr'[a-zA-Z_]'

	_VARTEX   = '(?:' + '|'.join (reversed (sorted (x.replace ('\\', '\\\\').replace ('+', '\\+').replace ('*', '\\*').replace ('^', '\\^') for x in AST.Var.TEX2PY))) + ')'
	_VARTEX1  = fr'(?:(\d)|({_LETTER})|(\\partial|\\infty))'
	_VARPY    = fr'(?:{_LETTER}(?:\w|\\_)*)'
	_VARUNI   = fr'(?:{"|".join (AST.Var.UNI2PY)})'
	_VAR      = fr'(?:{_VARPY}|{_VARTEX}(?!{_LETTERU})|{_VARUNI})'

	_STR      = r'\'(?:\\.|[^\'])*\'|"(?:\\.|[^"])*["]'

	_FUNCPY   = f"(?:{'|'.join (reversed (sorted (AST.Func.PY)))})"
	_FUNCTEX  = f"(?:{'|'.join (reversed (sorted (AST.Func.TEX)))})"

	TOKENS    = OrderedDict ([ # order matters
		('FUNC',         fr'(@|\%|{_FUNCPY}(?!\w|\\_))|\\({_FUNCTEX})(?!{_LETTERU})|(\${_LETTERU}\w*)|\\operatorname\s*{{\s*(@|\\\%|\$?(?:{_LETTER}|\\_)(?:\w|\\_)*)\s*}}'), # AST.Func.ESCAPE, AST.Func.NOREMAP, AST.Func.NOEVAL HERE!
		('LEFTDOT',      fr'\\left\s*\.'),

		('SQRT',          r'sqrt\b|\\sqrt(?!{_LETTER})'),
		('LOG',           r'log\b|\\log(?!{_LETTER})'),
		('LN',            r'ln\b|\\ln(?!{_LETTER})'),
		('LIM',          fr'\\lim(?!{_LETTER})'),
		('SUM',          fr'\\sum(?:\s*\\limits)?(?!{_LETTER})|{_USUM}'),
		('INTG',         fr'\\int(?:\s*\\limits)?(?!{_LETTER})|{_UINTG}'),
		('LEFT',         fr'\\left(?!{_LETTERU})'),
		('RIGHT',        fr'\\right(?!{_LETTERU})'),
		('CDOT',         fr'\\cdot(?!{_LETTERU})'),
		('TO',           fr'\\to(?!{_LETTERU})'),
		('CUP',          fr'\\cup(?!{_LETTERU})'),
		('OMINUS',       fr'\\ominus(?!{_LETTERU})'),
		('CAP',          fr'\\cap(?!{_LETTERU})'),
		('MAPSTO',       fr'\\mapsto(?!{_LETTERU})'),
		('EMPTYSET',     fr'\\emptyset(?!{_LETTERU})'),
		('SETMINUS',     fr'\\setminus(?!{_LETTERU})'),
		('SUBSTACK',      r'\\substack(?!{_LETTERU})'),

		('BEG_MAT',       r'\\begin\s*{\s*matrix\s*}'),
		('END_MAT',       r'\\end\s*{\s*matrix\s*}'),
		('BEG_BMAT',      r'\\begin\s*{\s*bmatrix\s*}'),
		('END_BMAT',      r'\\end\s*{\s*bmatrix\s*}'),
		('BEG_VMAT',      r'\\begin\s*{\s*vmatrix\s*}'),
		('END_VMAT',      r'\\end\s*{\s*vmatrix\s*}'),
		('BEG_PMAT',      r'\\begin\s*{\s*pmatrix\s*}'),
		('END_PMAT',      r'\\end\s*{\s*pmatrix\s*}'),
		('BEG_CASES',     r'\\begin\s*{\s*cases\s*}'),
		('END_CASES',     r'\\end\s*{\s*cases\s*}'),
		('FRAC2',        fr'\\frac\s*{_VARTEX1}\s*{_VARTEX1}'),
		('FRAC1',        fr'\\frac\s*{_VARTEX1}'),
		('FRAC',          r'\\frac(?!{_LETTERU})'),
		('BINOM2',       fr'\\binom\s*{_VARTEX1}\s*{_VARTEX1}'),
		('BINOM1',       fr'\\binom\s*{_VARTEX1}'),
		('BINOM',         r'\\binom(?!{_LETTERU})'),
		('IF',            r'if(?!{_LETTERU})'),
		('ELSE',          r'else(?!{_LETTERU})'),
		('CMP',          fr'==|!=|<=|<|>=|>|in\b|not\s+in\b|(?:\\neq?|\\le|\\lt|\\ge|\\gt|\\in(?!fty)|\\notin)(?!{_LETTERU})|{"|".join (AST.Eq.UNI2PY)}'),
		('EQ',            r'='),
		('NUM',           r'(?:(\d*\.\d+)|(\d+\.?))((?:[eE]|{[eE]})(?:[+-]?\d+|{[+-]?\d+}))?'),
		('VAR',          fr"(?:(?:(\\partial\s?|{_UPARTIAL})|(d))({_VAR})|({_VAR}))('*)"),
		('ATTR',         fr'\.\s*(?:({_LETTERU}\w*)|\\operatorname\s*{{\s*({_LETTER}(?:\w|\\_)*)\s*}})'),
		('STR',          fr"({_STR})|\\text\s*{{\s*({_STR})\s*}}"),
		('SUB1',         fr'_{_VARTEX1}'),
		('SUB',           r'_'),
		('COLON',         r'{:}|:'),
		('DBLBAR',        r'\|\|'),
		('DBLCARET',      r'\^\^'),
		('DBLAMP',        r'&&'),
		('CARET1',       fr'\^{_VARTEX1}'),
		('CARET',         r'\^'),
		('DBLSTAR',       r'\*\*'),
		('CURLYL',        r'{'),
		('CURLYR',        r'}'),
		('PARENL',        r'\('),
		('PARENR',        r'\)'),
		('BRACKL',        r'\['),
		('BRACKR',        r'\]'),
		('SLASHCURLYL',   r'\\{'),
		('SLASHCURLYR',   r'\\}'),
		('SLASHBRACKL',   r'\\\['),
		('BAR',           r'\|'),
		('PLUS',          r'\+'),
		('MINUS',         r'-'),
		('STAR',          r'\*'),
		('DIVIDE',        r'/'),
		('EXCL',          r'!'),
		('AMP',           r'&'),
		('DBLSLASH',      r'\\\\'),
		('COMMA',         r','),
		('ignore',        r'\\[,:;]|\\?\s+|\\text\s*{\s*[^}]*\s*}'),
	])

	_PYGREEK_QUICK = '(?:' + '|'.join (reversed (sorted (g for g in AST.Var.GREEK))) + ')'
	_PYMULTI_QUICK = '(?:' + '|'.join (reversed (sorted (g for g in AST.Var.PY2TEXMULTI))) + ')'
	_VARPY_QUICK   = fr'(?:{_PYGREEK_QUICK}|{_LETTER})'
	_VAR_QUICK     = fr'(?:{_VARPY_QUICK}|{_VARTEX}|{_VARUNI})'

	TOKENS_QUICK   = OrderedDict ([ # quick input mode different tokens
		('FUNC',         fr'(@|\%|{_FUNCPY}(?!\w|\\_))|\\({_FUNCTEX})|(\${_LETTERU}\w*)|\\operatorname\s*{{\s*(@|\\\%|{_LETTER}(?:\w|\\_)*)\s*}}'), # AST.Func.ESCAPE, AST.Func.NOREMAP, AST.Func.NOEVAL HERE!

		('SQRT',          r'sqrt\b|\\sqrt'),
		('LOG',           r'log\b|\\log'),
		('LN',            r'ln\b|\\ln'),
		('LIM',          fr'\\lim'),
		('SUM',          fr'\\sum(?:\s*\\limits)?|{_USUM}'),
		('INTG',         fr'\\int(?:\s*\\limits)?|{_UINTG}'),
		('LEFT',         fr'\\left'),
		('RIGHT',        fr'\\right'),
		('CDOT',         fr'\\cdot'),
		('TO',           fr'\\to'),
		('CUP',          fr'\\cup'),
		('OMINUS',       fr'\\ominus'),
		('CAP',          fr'\\cap'),
		('MAPSTO',       fr'\\mapsto'),
		('EMPTYSET',     fr'\\emptyset'),
		('SETMINUS',     fr'\\setminus'),
		('SUBSTACK',      r'\\substack'),

		('CMP',          fr'==|!=|<=|<|>=|>|in\b|not\s+in\b|(?:\\neq?|\\le|\\lt|\\ge|\\gt|\\in(?!fty)|\\notin)|{"|".join (AST.Eq.UNI2PY)}'),
		('VAR',          fr"(?:(?:(\\partial\s?|partial|{_UPARTIAL})|(d(?!elta)))({_VAR_QUICK})|(None|True|False|{_PYMULTI_QUICK}|{_VAR_QUICK}))('*)"),
	])

	TOKENS_LONG    = OrderedDict () # initialized in __init__()

	# grammar definition and implementation

	def expr_commas_1      (self, expr_comma, COMMA):                              return expr_comma if expr_comma.is_comma else AST (',', (expr_comma,))
	def expr_commas_2      (self, expr_comma):                                     return expr_comma
	def expr_commas_3      (self):                                                 return AST.CommaEmpty
	def expr_comma_1       (self, expr_comma, COMMA, expr_colon):                  return _expr_comma (expr_comma, expr_colon)
	def expr_comma_2       (self, expr_colon):                                     return expr_colon

	def expr_colon_1       (self, expr, COLON, expr_colon):                        return _expr_colon (expr, expr_colon)
	def expr_colon_2       (self, expr, COLON):                                    return AST ('slice', expr, False, None)
	def expr_colon_3       (self, COLON, expr_colon):                              return _ast_pre_slice (False, expr_colon)
	def expr_colon_4       (self, COLON):                                          return AST ('slice', False, False, None)
	def expr_colon_5       (self, expr):                                           return expr

	def expr               (self, expr_eq):                                        return expr_eq

	def expr_eq_1          (self, expr_mapsto1, EQ, expr_mapsto2):                 return AST ('=', '=', expr_mapsto1, expr_mapsto2)
	def expr_eq_2          (self, expr_mapsto):                                    return expr_mapsto

	def expr_mapsto_1      (self, expr_paren, MAPSTO, expr_colon):                 return _expr_mapsto (expr_paren.strip (), expr_colon)
	def expr_mapsto_2      (self, expr_piece):                                     return expr_piece

	def expr_piece_1       (self, expr_cmp, IF, expr_eq, ELSE, expr_mapsto):       return _expr_piece (expr_cmp, expr_eq, expr_mapsto)
	def expr_piece_2       (self, expr_cmp, IF, expr_eq):                          return AST ('piece', ((expr_cmp, expr_eq),))
	def expr_piece_3       (self, expr_cmp):                                       return expr_cmp

	def expr_cmp_1         (self, expr_union1, CMP, expr_union2):                  return AST ('=', AST.Eq.ANY2PY.get (CMP.text.replace (' ', ''), CMP.text.replace (' ', '')), expr_union1, expr_union2)
	def expr_cmp_2         (self, expr_union):                                     return expr_union

	def expr_union_1       (self, expr_union, DBLBAR, expr_sdiff):                 return AST.flatcat ('||', expr_union, expr_sdiff)
	def expr_union_2       (self, expr_union, CUP, expr_sdiff):                    return AST.flatcat ('||', expr_union, expr_sdiff)
	def expr_union_3       (self, expr_sdiff):                                     return expr_sdiff

	def expr_sdiff_1       (self, expr_sdiff, DBLCARET, expr_xsect):               return AST.flatcat ('^^', expr_sdiff, expr_xsect)
	def expr_sdiff_2       (self, expr_sdiff, OMINUS, expr_xsect):                 return AST.flatcat ('^^', expr_sdiff, expr_xsect)
	def expr_sdiff_3       (self, expr_xsect):                                     return expr_xsect

	def expr_xsect_1       (self, expr_xsect, DBLAMP, expr_add):                   return AST.flatcat ('&&', expr_xsect, expr_add)
	def expr_xsect_2       (self, expr_xsect, CAP, expr_add):                      return AST.flatcat ('&&', expr_xsect, expr_add)
	def expr_xsect_3       (self, expr_add):                                       return expr_add

	def expr_add_1         (self, expr_add, PLUS, expr_mul_exp):                   return AST.flatcat ('+', expr_add, expr_mul_exp)
	def expr_add_2         (self, expr_add, MINUS, expr_mul_exp):                  return AST.flatcat ('+', expr_add, _expr_neg (expr_mul_exp))
	def expr_add_3         (self, expr_add, SETMINUS, expr_mul_exp):               return AST.flatcat ('+', expr_add, _expr_neg (expr_mul_exp))
	def expr_add_4         (self, expr_mul_exp):                                   return expr_mul_exp

	def expr_mul_exp_1     (self, expr_mul_exp, CDOT, expr_neg):                   return _expr_mul_exp (expr_mul_exp, expr_neg)
	def expr_mul_exp_2     (self, expr_mul_exp, STAR, expr_neg):                   return _expr_mul_exp (expr_mul_exp, expr_neg)
	def expr_mul_exp_3     (self, expr_neg):                                       return expr_neg

	def expr_neg_1         (self, MINUS, expr_neg):                                return _expr_neg (expr_neg)
	def expr_neg_2         (self, expr_diff):                                      return expr_diff

	def expr_diff          (self, expr_div):                                       return _expr_diff (expr_div)

	def expr_div_1         (self, expr_div, DIVIDE, expr_mul_imp):                 return AST ('/', expr_div, expr_mul_imp)
	def expr_div_2         (self, expr_div, DIVIDE, MINUS, expr_mul_imp):          return AST ('/', expr_div, _expr_neg (expr_mul_imp))
	def expr_div_3         (self, expr_mul_imp):                                   return expr_mul_imp

	def expr_mul_imp_1     (self, expr_mul_imp, expr_intg):                        return _expr_mul_imp (expr_mul_imp, expr_intg, self._USER_FUNCS)
	def expr_mul_imp_2     (self, expr_intg):                                      return expr_intg

	def expr_intg_1        (self, INTG, expr_sub, expr_super, expr_add):           return _expr_intg (expr_add, (expr_sub, expr_super))
	def expr_intg_2        (self, INTG, expr_add):                                 return _expr_intg (expr_add)
	def expr_intg_3        (self, expr_lim):                                       return expr_lim

	def expr_lim_1         (self, LIM, SUB, CURLYL, expr_var, TO, expr, CURLYR, expr_neg):                          return AST ('lim', expr_neg, expr_var, expr)
	def expr_lim_2         (self, LIM, SUB, CURLYL, expr_var, TO, expr, caret_or_dblstar, PLUS, CURLYR, expr_neg):  return AST ('lim', expr_neg, expr_var, expr, '+')
	def expr_lim_3         (self, LIM, SUB, CURLYL, expr_var, TO, expr, caret_or_dblstar, MINUS, CURLYR, expr_neg): return AST ('lim', expr_neg, expr_var, expr, '-')
	def expr_lim_6         (self, expr_sum):                                                                        return expr_sum

	def expr_sum_1         (self, SUM, SUB, CURLYL, varass, CURLYR, expr_super, expr_neg):                          return AST ('sum', expr_neg, varass [0], varass [1], expr_super)
	def expr_sum_2         (self, expr_func):                                                                       return expr_func

	def expr_func_1        (self, SQRT, BRACKL, expr, BRACKR, expr_neg_func):      return _expr_func (1, 'sqrt', expr_neg_func, expr)
	def expr_func_2        (self, SQRT, expr_super, expr_neg_func):                return AST ('^', _expr_func (1, 'sqrt', expr_neg_func), expr_super)
	def expr_func_3        (self, SQRT, expr_neg_func):                            return _expr_func (1, 'sqrt', expr_neg_func)
	def expr_func_4        (self, LN, expr_super, expr_neg_func):                  return AST ('^', _expr_func (1, 'log', expr_neg_func), expr_super)
	def expr_func_5        (self, LN, expr_neg_func):                              return _expr_func (1, 'log', expr_neg_func)
	def expr_func_6        (self, LOG, expr_sub, expr_neg_func):                   return _expr_func (1, 'log', expr_neg_func, expr_sub)
	def expr_func_7        (self, LOG, expr_super, expr_neg_func):                 return AST ('^', _expr_func (1, 'log', expr_neg_func), expr_super)
	def expr_func_8        (self, LOG, expr_neg_func):                             return _expr_func (1, 'log', expr_neg_func)
	def expr_func_9        (self, FUNC, expr_neg_func):                            return _expr_func_func (FUNC, expr_neg_func)
	def expr_func_10       (self, FUNC, expr_super, expr_neg_func):                return _expr_func_func (FUNC, expr_neg_func, expr_super)
	def expr_func_11       (self, expr_pow):                                       return expr_pow

	def expr_pow_1         (self, expr_pow, expr_super):                           return AST ('^', expr_pow, expr_super)
	def expr_pow_2         (self, expr_fact):                                      return expr_fact

	def expr_fact_1        (self, expr_fact, EXCL):                                return AST ('!', expr_fact)
	def expr_fact_2        (self, expr_attr):                                      return expr_attr

	def expr_attr_1        (self, expr_attr, ATTR):                                return AST ('.', expr_attr, ATTR.grp [0] or ATTR.grp [1])
	def expr_attr_2        (self, expr_abs):                                       return expr_abs

	def expr_abs_1         (self, LEFT, BAR1, expr_commas, RIGHT, BAR2):           return AST ('|', expr_commas)
	def expr_abs_2         (self, BAR1, expr_commas, BAR2):                        return AST ('|', expr_commas)
	def expr_abs_3         (self, expr_paren):                                     return expr_paren

	def expr_paren_1       (self, LEFT, PARENL, expr_commas, RIGHT, PARENR):       return AST ('(', expr_commas)
	def expr_paren_2       (self, PARENL, expr_commas, PARENR):                    return AST ('(', expr_commas)
	def expr_paren_3       (self, expr_frac):                                      return expr_frac

	def expr_frac_1        (self, FRAC, expr_binom1, expr_binom2):                 return AST ('/', expr_binom1.no_curlys, expr_binom2.no_curlys)
	def expr_frac_2        (self, FRAC1, expr_binom):                              return AST ('/', _ast_from_tok_digit_or_var (FRAC1), expr_binom.no_curlys)
	def expr_frac_3        (self, FRAC2):                                          return AST ('/', _ast_from_tok_digit_or_var (FRAC2), _ast_from_tok_digit_or_var (FRAC2, 3))
	def expr_frac_4        (self, expr_binom):                                     return expr_binom

	def expr_binom_1       (self, BINOM, expr_subs1, expr_subs2):                  return AST ('func', 'binomial', (expr_subs1.no_curlys, expr_subs2.no_curlys))
	def expr_binom_2       (self, BINOM1, expr_subs):                              return AST ('func', 'binomial', (_ast_from_tok_digit_or_var (BINOM1), expr_subs.no_curlys))
	def expr_binom_3       (self, BINOM2):                                         return AST ('func', 'binomial', (_ast_from_tok_digit_or_var (BINOM2), _ast_from_tok_digit_or_var (BINOM2, 3)))
	def expr_binom_4       (self, expr_subs):                                      return expr_subs

	def expr_subs_1        (self, LEFTDOT, expr_commas, RIGHT, BAR, SUB, CURLYL, subsvars, CURLYR): return _expr_subs (expr_commas, subsvars)
	def expr_subs_2        (self, expr_cases):                                     return expr_cases
	def subsvars_1         (self, SUBSTACK, CURLYL, subsvarss, CURLYR):            return subsvarss
	def subsvars_2         (self, varass):                                         return (varass,)
	def subsvarss_1        (self, subsvarsv, DBLSLASH):                            return subsvarsv
	def subsvarss_2        (self, subsvarsv):                                      return subsvarsv
	def subsvarsv_1        (self, subsvarsv, DBLSLASH, varass):                    return subsvarsv + (varass,)
	def subsvarsv_2        (self, varass):                                         return (varass,)

	def expr_cases_1       (self, BEG_CASES, casess, END_CASES):                   return AST ('piece', casess)
	def expr_cases_2       (self, expr_mat):                                       return expr_mat
	def casess_1           (self, casessp, DBLSLASH):                              return casessp
	def casess_2           (self, casessp):                                        return casessp
	def casessp_1          (self, casessp, DBLSLASH, casessc):                     return casessp + (casessc,)
	def casessp_2          (self, casessc):                                        return (casessc,)
	def casessc_1          (self, expr1, AMP, expr2):                              return (expr1, expr2)
	def casessc_2          (self, expr, AMP):                                      return (expr, True)

	def expr_mat_1         (self, LEFT, BRACKL, BEG_MAT, mat_rows, END_MAT, RIGHT, BRACKR): return _expr_mat (mat_rows)
	def expr_mat_2         (self, BEG_MAT, mat_rows, END_MAT):                     return _expr_mat (mat_rows)
	def expr_mat_3         (self, BEG_BMAT, mat_rows, END_BMAT):                   return _expr_mat (mat_rows)
	def expr_mat_4         (self, BEG_VMAT, mat_rows, END_VMAT):                   return _expr_mat (mat_rows)
	def expr_mat_5         (self, BEG_PMAT, mat_rows, END_PMAT):                   return _expr_mat (mat_rows)
	def expr_mat_6         (self, expr_vec):                                       return expr_vec
	def mat_rows_1         (self, mat_row, DBLSLASH):                              return mat_row
	def mat_rows_2         (self, mat_row):                                        return mat_row
	def mat_rows_3         (self):                                                 return ()
	def mat_row_1          (self, mat_row, DBLSLASH, mat_col):                     return mat_row + (mat_col,)
	def mat_row_2          (self, mat_col):                                        return (mat_col,)
	def mat_col_1          (self, mat_col, AMP, expr):                             return mat_col + (expr,)
	def mat_col_2          (self, expr):                                           return (expr,)

	def expr_vec_1         (self, SLASHBRACKL, expr_commas, BRACKR):               return _expr_vec (expr_commas)
	def expr_vec_2         (self, expr_bracket):                                   return expr_bracket

	def expr_bracket_1     (self, LEFT, BRACKL, expr_commas, RIGHT, BRACKR):       return AST ('[', expr_commas.comma if expr_commas.is_comma else (expr_commas,))
	def expr_bracket_2     (self, BRACKL, expr_commas, BRACKR):                    return AST ('[', expr_commas.comma if expr_commas.is_comma else (expr_commas,))
	def expr_bracket_3     (self, expr_curly):                                     return expr_curly

	def expr_curly_1       (self, LEFT, SLASHCURLYL, expr_commas, RIGHT, SLASHCURLYR): return _expr_curly (expr_commas, forceset = True)
	def expr_curly_2       (self, SLASHCURLYL, expr_commas, CURLYR):               return AST ('set', expr_commas.comma) if expr_commas.is_comma else AST ('set', (expr_commas,))
	def expr_curly_3       (self, CURLYL, expr_commas, CURLYR):                    return _expr_curly (expr_commas)
	def expr_curly_4       (self, expr_term):                                      return expr_term

	def expr_term_1        (self, expr_num):                                       return expr_num
	def expr_term_2        (self, expr_var):                                       return expr_var
	def expr_term_3        (self, STR):                                            return AST ('"', py_ast.literal_eval (STR.grp [0] or STR.grp [1]))
	def expr_term_4        (self, SUB):                                            return AST ('@', '_') # for last expression variable
	def expr_term_5        (self, EMPTYSET):                                       return AST.SetEmpty

	def expr_num           (self, NUM):                                            return _expr_num (NUM)
	def expr_var           (self, VAR):                                            return _expr_var (VAR)

	def expr_sub_1         (self, SUB, expr_frac):                                 return expr_frac
	def expr_sub_2         (self, SUB1):                                           return _ast_from_tok_digit_or_var (SUB1)

	def expr_super_1       (self, DBLSTAR, expr_neg_func):                         return expr_neg_func
	def expr_super_3       (self, CARET, expr_frac):                               return expr_frac
	def expr_super_4       (self, CARET1):                                         return _ast_from_tok_digit_or_var (CARET1)

	def expr_neg_func_1    (self, MINUS, expr_neg_func):                           return _expr_neg (expr_neg_func)
	def expr_neg_func_2    (self, expr_func):                                      return expr_func

	def varass             (self, expr_var, EQ, expr):                             return (expr_var, expr)

	def caret_or_dblstar_1 (self, DBLSTAR):                                        return '**'
	def caret_or_dblstar_2 (self, CARET):                                          return '^'

	#...............................................................................................
	# autocomplete means autocomplete AST tree so it can be rendered, not necessarily expression

	_AUTOCOMPLETE_SUBSTITUTE = {
		'CARET1'          : 'CARET',
		'SUB1'            : 'SUB',
		'FRAC2'           : 'FRAC',
		'FRAC1'           : 'FRAC',
		'expr_super'      : 'CARET',
		'caret_or_dblstar': 'CARET',
	}

	_AUTOCOMPLETE_CONTINUE = {
		'RIGHT'      : ' \\right',
		'COMMA'      : ',',
		'PARENL'     : '(',
		'PARENR'     : ')',
		'CURLYR'     : '}',
		'BRACKR'     : ']',
		'BAR'        : '|',
		'SLASHCURLYR': '\\}',
	}

	_AUTOCOMPLETE_COMMA_CLOSE = {
		'CURLYL'     : 'CURLYR',
		'PARENL'     : 'PARENR',
		'BRACKL'     : 'BRACKR',
		'SLASHCURLYL': 'CURLYR', # normal non-latex set closing, latex closing special cased
		'SLASHBRACKL': 'BRACKR',
	}

	def _insert_symbol (self, sym, tokinc = 0):
		tokidx       = self.tokidx
		self.tokidx += tokinc

		for sym in ((sym,) if isinstance (sym, str) else sym):
			if sym in self.TOKENS:
				self.tokens.insert (tokidx, lalr1.Token (self._AUTOCOMPLETE_SUBSTITUTE.get (sym, sym), '', self.tok.pos))

				if self.autocompleting:
					if sym not in self._AUTOCOMPLETE_CONTINUE:
						self.autocompleting = False
					elif self.autocomplete and self.autocomplete [-1] == ' \\right':
						self.autocomplete [-1] = self.autocomplete [-1] + self._AUTOCOMPLETE_CONTINUE [sym]
					else:
						self.autocomplete.append (self._AUTOCOMPLETE_CONTINUE [sym])

			else:
				self.tokens.insert (tokidx, lalr1.Token (self._AUTOCOMPLETE_SUBSTITUTE.get (sym, 'VAR'), '', self.tok.pos, ('', '', '', '', '')))
				self._mark_error ()

			tokidx += 1

		return True # for convenience

	def _mark_error (self, sym_ins = None, tokinc = 0, at = None):
		self.autocompleting = False

		if self.erridx is None:
			self.erridx = self.tokens [self.tokidx].pos if at is None else at

		if sym_ins is not None:
			return self._insert_symbol (sym_ins, tokinc)

	def _parse_autocomplete_expr_commas (self, rule, pos):
		idx = -pos + (self.stack [-pos].sym == 'LEFT')

		if self.tokens [self.tokidx - 1] == 'COMMA' and (self.stack [idx].sym not in {'CURLYL', 'PARENL'} or \
				not self.stack [-1].red.is_comma or self.stack [-1].red.comma.len > 1):
			self._mark_error ()

		if self.stack [idx - 1].sym == 'LEFT':
			return self._insert_symbol ('RIGHT')

		return self._insert_symbol (self._AUTOCOMPLETE_COMMA_CLOSE [self.stack [idx].sym])

	def _parse_autocomplete_expr_intg (self):
		s               = self.stack [-1]
		self.stack [-1] = lalr1.State (s.idx, s.sym, AST ('*', (s.red, AST.VarNull)))
		expr_vars       = set ()

		if self.autocompleting:
			stack = [s [2]]

			while stack:
				ast = stack.pop ()

				if ast.is_var:
					if not (ast.is_differential or ast.is_part_any):
						expr_vars.add (ast.var)
				else:
					stack.extend (filter (lambda a: isinstance (a, tuple), ast))

		expr_vars = expr_vars - {'_'} - {ast.var for ast in AST.CONSTS}

		if len (expr_vars) == 1:
			self.autocomplete.append (f' d{expr_vars.pop ()}')
		else:
			self._mark_error ()

		return True

	def parse_getextrastate (self):
		return (self.autocomplete [:], self.autocompleting, self.erridx)

	def parse_setextrastate (self, state):
		self.autocomplete, self.autocompleting, self.erridx = state

	def parse_error (self): # add tokens to continue parsing for autocomplete if syntax allows
		if isinstance (self.rederr, lalr1.Incomplete):
			self.parse_results.append ((self.rederr.red, self.tok.pos, []))

			return False

		if self.tok != '$end':
			self.parse_results.append ((None, self.tok.pos, []))

			return False

		if self.tokidx and self.tokens [self.tokidx - 1] == 'LEFT':
			for irule, pos in self.strules [self.stidx]:
				if self.rules [irule] [1] [pos] == 'PARENL':
					break
			else:
				raise RuntimeError ('could not find left parenthesis rule')

		else:
			irule, pos = self.strules [self.stidx] [0]

		rule = self.rules [irule]

		if pos == 1:
			if rule == ('expr_func', ('FUNC', 'expr_neg_func')):
				return self._insert_symbol (('PARENL', 'PARENR'))

			if rule == ('expr_paren', ('PARENL', 'expr_commas', 'PARENR')) and self.stack [-2].sym == 'expr_mul_imp' and \
					(self.stack [-2].red.is_attr or (self.stack [-2].red.is_var and self.stack [-2].red.var in self._USER_FUNCS)):
				return self._insert_symbol ('PARENR')

		if pos and rule [1] [pos - 1] == 'expr_commas' and rule [0] != 'expr_abs':
			return self._parse_autocomplete_expr_commas (rule, pos)

		if pos >= len (rule [1]): # end of rule
			if rule [0] == 'expr_intg':
				return self._parse_autocomplete_expr_intg ()

			return False

		return self._insert_symbol (rule [1] [pos])

	def parse_success (self, red):
		self.parse_results.append ((red, self.erridx, self.autocomplete))

		return True # continue parsing if conflict branches remain to find best resolution

	def parse (self, text):
		if not text.strip ():
			return (AST.VarNull, 0, [])

		self.parse_results  = [] # [(reduction, erridx, autocomplete), ...]
		self.autocomplete   = []
		self.autocompleting = True
		self.erridx         = None

		lalr1.LALR1.parse (self, text)

		if not self.parse_results:
			return (None, 0, [])

		rated = sorted ((r is None, -e if e is not None else float ('-inf'), len (a), i, (r, e, a)) \
				for i, (r, e, a) in enumerate (self.parse_results))

		if os.environ.get ('SYMPAD_DEBUG'):
			rated = list (rated)

			print (file = sys.stderr)

			for res in rated [:32]:
				res = res [-1]
				res = (res [0].no_curlys.flat (),) + res [1:] if isinstance (res [0], AST) else res

				print ('parse:', res, file = sys.stderr)

			if len (rated) > 32:
				print (f'... total {len (rated)}', file = sys.stderr)

			print (file = sys.stderr)

		res = next (iter (rated)) [-1]

		return (res [0].no_curlys.flat (),) + res [1:] if isinstance (res [0], AST) else res

class sparser: # for single script
	Parser = Parser

# if __name__ == '__main__' and not _RUNNING_AS_SINGLE_SCRIPT: ## DEBUG!
# 	p = Parser ()
# 	# p.set_user_funcs ({'f': 1})
# 	a = p.parse (r'x**-y[0]')
# 	# a = sym.ast2spt (a)
# 	print (a)
# Patch SymPy matrix multiplication for intermediate simplification step to control expression blowup.

from collections import defaultdict

SPATCHED = False

try: # try to patch and fail silently if SymPy has changed too much since this was written
	from sympy import S, count_ops, cancel, together, SparseMatrix
	from sympy.matrices.common import MatrixArithmetic, classof
	from sympy.matrices.dense import DenseMatrix
	from sympy.matrices.sparse import SparseMatrix

	_DEFAULT_MatrixArithmetic_eval_matrix_mul = MatrixArithmetic._eval_matrix_mul
	_DEFAULT_DenseMatrix_eval_matrix_mul      = DenseMatrix._eval_matrix_mul
	_DEFAULT_SparseMatrix_eval_matrix_mul     = SparseMatrix._eval_matrix_mul

	SPATCHED = True

except:
	pass

def _dotprodsimp (a, b, simplify = True):
	"""Sum-of-products with optional intermediate product simplification
	targeted at the kind of blowup that occurs during summation of products.
	Intended to reduce expression blowup during matrix multiplication or other
	similar operations.

	Parameters
	==========

	a, b : iterable
		These will be multiplied then summed together either normally or
		using simplification on the intermediate products and cancelling at
		the end according to the 'simplify' flag. The elements must already be
		sympyfied and the sequences need not be of the same length, the shorter
		will be used.

	simplify : bool
		When set intermediate and final simplification will be used, not set
		will indicate a normal sum of products.
	"""

	expr = S.Zero
	itra = iter (a)
	itrb = iter (b)

	# simple non-simplified sum of products
	if not simplify:
		try:
			expr = next (itra) * next (itrb)

			for a in itra:
				expr += a * next (itrb)

		except StopIteration:
			pass

		return expr

	# part 1, the expanded summation
	try:
		prod    = next (itra) * next (itrb)
		_expand = getattr (prod, 'expand', None)
		expr    = _expand (power_base = False, power_exp = False, log = False, \
				multinomial = False, basic = False) if _expand else prod

		for a in itra:
			prod     = a * next (itrb)
			_expand  = getattr (prod, 'expand', None)
			expr    += _expand (power_base = False, power_exp = False, log = False, \
					multinomial = False, basic = False) if _expand else prod

	except StopIteration:
		pass

	# part 2, the cancelation and grouping
	exprops  = count_ops (expr)
	expr2    = expr.expand (power_base = False, power_exp = False, log = False, multinomial = True, basic = False)
	expr2ops = count_ops (expr2)

	if expr2ops < exprops:
		expr    = expr2
		exprops = expr2ops

	if exprops < 6: # empirically tested cutoff for expensive simplification
		return expr

	expr2    = cancel (expr)
	expr2ops = count_ops (expr2)

	if expr2ops < exprops:
		expr    = expr2
		exprops = expr2ops

	expr3    = together (expr2, deep = True)
	expr3ops = count_ops (expr3)

	if expr3ops < exprops:
		return expr3

	return expr

def _MatrixArithmetic_eval_matrix_mul (self, other):
	return self._new (self.rows, other.cols, lambda i, j:
		_dotprodsimp ((self [i,k] for k in range (self.cols)),
		(other [k,j] for k in range (self.cols))))

def _DenseMatrix_eval_matrix_mul (self, other):
	other_len = other.rows * other.cols
	new_len   = self.rows * other.cols
	new_mat   = [S.Zero] * new_len

	# if we multiply an n x 0 with a 0 x m, the
	# expected behavior is to produce an n x m matrix of zeros
	if self.cols != 0 and other.rows != 0:
		for i in range (new_len):
			row, col    = i // other.cols, i % other.cols
			row_indices = range (self.cols * row, self.cols * (row + 1))
			col_indices = range (col, other_len, other.cols)
			new_mat [i] = _dotprodsimp (
				(self._mat [a] for a in row_indices),
				(other._mat [b] for b in col_indices))

	return classof (self, other)._new (self.rows, other.cols, new_mat, copy = False)

def _SparseMatrix_eval_matrix_mul (self, other):
	"""Fast multiplication exploiting the sparsity of the matrix."""
	if not isinstance (other, SparseMatrix):
		return self.mul (self._new (other))

	# if we made it here, we're both sparse matrices
	# create quick lookups for rows and cols
	row_lookup = defaultdict (dict)
	for (i,j), val in self._smat.items ():
		row_lookup [i][j] = val
	col_lookup = defaultdict (dict)
	for (i,j), val in other._smat.items ():
		col_lookup [j][i] = val

	smat = {}
	for row in row_lookup.keys ():
		for col in col_lookup.keys ():
			# find the common indices of non-zero entries.
			# these are the only things that need to be multiplied.
			indices = set (col_lookup [col].keys ()) & set (row_lookup [row].keys ())
			if indices:
				smat [row, col] = _dotprodsimp ((row_lookup [row][k] for k in indices),
					(col_lookup [col][k] for k in indices))

	return self._new (self.rows, other.cols, smat)

def set_matmulsimp (state):
	if SPATCHED:
		idx                               = bool (state)
		MatrixArithmetic._eval_matrix_mul = (_DEFAULT_MatrixArithmetic_eval_matrix_mul, _MatrixArithmetic_eval_matrix_mul) [idx]
		DenseMatrix._eval_matrix_mul      = (_DEFAULT_DenseMatrix_eval_matrix_mul, _DenseMatrix_eval_matrix_mul) [idx]
		SparseMatrix._eval_matrix_mul     = (_DEFAULT_SparseMatrix_eval_matrix_mul, _SparseMatrix_eval_matrix_mul) [idx]

class spatch: # for single script
	SPATCHED       = SPATCHED
	set_matmulsimp = set_matmulsimp
# Plot functions and expressions to image using matplotlib.

import base64
from io import BytesIO
import itertools as it
import math

import sympy as sp

_SPLOT = False

try:
	import matplotlib
	import matplotlib.pyplot as plt

	matplotlib.style.use ('bmh') # ('seaborn') # ('classic') # ('fivethirtyeight')

	_SPLOT       = True
	_FIGURE      = None
	_TRANSPARENT = True

except:
	pass

#...............................................................................................
def _cast_num (arg):
	try:
		return float (arg)
	except:
		return None

def _process_head (obj, args, fs, style = None, ret_xrng = False, ret_yrng = False, kw = {}):
	global _FIGURE, _TRANSPARENT

	if style is not None:
		if style [:1] == '-':
			style, _TRANSPARENT = style [1:], True
		else:
			_TRANSPARENT = False

		matplotlib.style.use (style)

	args = list (reversed (args))

	if args and args [-1] == '+': # continuing plot on previous figure?
		args.pop ()

	elif _FIGURE:
		plt.close (_FIGURE)

		_FIGURE = None

	if not _FIGURE:
		_FIGURE = plt.figure ()

	if fs is not None: # process figsize if present
		if isinstance (fs, (sp.Tuple, tuple)):
			fs = (_cast_num (fs [0]), _cast_num (fs [1]))

		else:
			fs = _cast_num (fs)

			if fs >= 0:
				fs = (fs, fs * 3 / 4)
			else:
				fs = (-fs, -fs)

		_FIGURE.set_figwidth (fs [0])
		_FIGURE.set_figheight (fs [1])

	xmax, ymin, ymax = None, None, None
	xmin             = _cast_num (args [-1]) if args else None

	if xmin is not None: # process xmin / xmax, ymin, ymax if present
		args = args [:-1]
		xmax = _cast_num (args [-1]) if args else None

		if xmax is not None:
			args = args [:-1]
			ymin = _cast_num (args [-1]) if args else None

			if ymin is not None:
				args = args [:-1]
				ymax = _cast_num (args [-1]) if args else None

				if ymax is not None:
					args = args [:-1]
				else:
					xmin, xmax, ymin, ymax = -xmin, xmin, xmax, ymin
		else:
			xmin, xmax = -xmin, xmin

	if xmin is not None:
		obj.xlim (xmin, xmax)
	elif ret_xrng:
		xmin, xmax = obj.xlim ()

	if ymin is not None:
		obj.ylim (ymin, ymax)
	elif ret_yrng:
		ymin, ymax = obj.ylim ()

	kw = dict ((k, # cast certain SymPy objects which don't play nice with matplotlib using numpy
		int (v) if isinstance (v, sp.Integer) else
		float (v) if isinstance (v, (sp.Float, sp.Rational)) else
		v) for k, v in kw.items ())

	return args, xmin, xmax, ymin, ymax, kw

def _process_fmt (args, kw = {}):
	kw    = kw.copy ()
	fargs = []

	if args and isinstance (args [-1], str):
		fmt, lbl = (args.pop ().split ('=', 1) + [None]) [:2]
		fmt, clr = (fmt.split ('#', 1) + [None]) [:2]

		if lbl:
			kw ['label'] = lbl.strip ()

		if clr:
			clr = clr.strip ()

			if len (clr) == 6:
				try:
					_   = int (clr, 16)
					clr = f'#{clr}'
				except:
					pass

			kw ['color'] = clr

		fargs = [fmt.strip ()]

	if args and isinstance (args [-1], dict):
		kw.update (args.pop ())

	return args, fargs, kw

def _figure_to_image ():
	data = BytesIO ()

	_FIGURE.savefig (data, format = 'png', bbox_inches = 'tight', facecolor = 'none', edgecolor = 'none', transparent = _TRANSPARENT)

	return base64.b64encode (data.getvalue ()).decode ()

#...............................................................................................
def plotf (*args, fs = None, res = 12, style = None, **kw):
	"""Plot function(s), point(s) and / or line(s).

plotf ([+,] [limits,] *args, fs = None, res = 12, **kw)

limits  = set absolute axis bounds: (default x is (0, 1), y is automatic)
  x              -> (-x, x, y auto)
  x0, x1         -> (x0, x1, y auto)
  x, y0, y1      -> (-x, x, y0, y1)
  x0, x1, y0, y1 -> (x0, x1, y0, y1)

fs      = set figure figsize if present: (default is (6.4, 4.8))
  x      -> (x, x * 3 / 4)
  -x     -> (x, x)
  (x, y) -> (x, y)

res     = minimum target resolution points per 50 x pixels (more or less 1 figsize x unit),
          may be raised a little to align with grid
style   = optional matplotlib plot style

*args   = functions and their formatting: (func, ['fmt',] [{kw},] func, ['fmt',] [{kw},] ...)
  func                      -> callable function takes x and returns y
	(x, y)                    -> point at x, y
	(x0, y0, x1, y1, ...)     -> connected lines from x0, y1 to x1, y1 to etc...
	((x0, y0), (x1, y1), ...) -> same thing

	fmt                       = 'fmt[#color][=label]'
	"""

	if not _SPLOT:
		return None

	obj    = plt
	legend = False

	args, xmin, xmax, ymin, ymax, kw = _process_head (obj, args, fs, style, ret_xrng = True, kw = kw)

	while args:
		arg = args.pop ()

		if isinstance (arg, (sp.Tuple, tuple, list)): # list of x, y coords
			if isinstance (arg [0], (sp.Tuple, tuple, list)):
				arg = list (it.chain.from_iterable (arg))

			pargs = [arg [0::2], arg [1::2]]

		else: # y = function (x)
			if not callable (arg):
				if len (arg.free_symbols) != 1:
					raise ValueError ('expression must have exactly one free variable')

				arg = sp.Lambda (arg.free_symbols.pop (), arg)

			win = _FIGURE.axes [-1].get_window_extent ()
			xrs = (win.x1 - win.x0) // 50 # scale resolution to roughly 'res' points every 50 pixels
			rng = res * xrs
			dx  = dx2 = xmax - xmin

			while dx2 < (res * xrs) / 2: # align sampling grid on integers and fractions of integers while rng stays small enough
				rng = int (rng + (dx2 - (rng % dx2)) % dx2)
				dx2 = dx2 * 2

			xs = [xmin + dx * i / rng for i in range (rng + 1)]
			ys = [None] * len (xs)

			for i in range (len (xs)):
				try:
					ys [i] = _cast_num (arg (xs [i]))
				except (ValueError, ZeroDivisionError, FloatingPointError):
					pass

			# remove lines crossing graph vertically due to poles (more or less)
			if ymin is not None:
				for i in range (1, len (xs)):
					if ys [i] is not None and ys [i-1] is not None:
						if ys [i] < ymin and ys [i-1] > ymax:
							ys [i] = None
						elif ys [i] > ymax and ys [i-1] < ymin:
							ys [i] = None

			pargs = [xs, ys]

		args, fargs, kwf = _process_fmt (args, kw)
		legend           = legend or ('label' in kwf)

		obj.plot (*(pargs + fargs), **kwf)

	if legend or 'label' in kw:
		obj.legend ()

	return _figure_to_image ()

#...............................................................................................
def __fxfy2fxy (f1, f2): # u = f1 (x, y), v = f2 (x, y) -> (u, v) = f' (x, y)
	return lambda x, y, f1 = f1, f2 = f2: (float (f1 (x, y)), float (f2 (x, y)))

def __fxy2fxy (f): # (u, v) = f (x, y) -> (u, v) = f' (x, y)
	return lambda x, y, f = f: tuple (float (v) for v in f (x, y))

def __fdy2fxy (f): # v/u = f (x, y) -> (u, v) = f' (x, y)
	return lambda x, y, f = f: tuple ((math.cos (t), math.sin (t)) for t in (math.atan2 (f (x, y), 1),)) [0]

def _process_funcxy (args, testx, testy):
	isdy = False
	f    = args.pop ()

	if isinstance (f, (sp.Tuple, tuple, list)): # if (f1 (x, y), f2 (x, y)) functions or expressions present in args they are individual u and v functions
		c1, c2 = callable (f [0]), callable (f [1])

		if c1 and c2: # two Lambdas
			f = __fxfy2fxy (f [0], f [1])

		elif not (c1 or c2): # two expressions
			vars = tuple (sorted (sp.Tuple (f [0], f [1]).free_symbols, key = lambda s: s.name))

			if len (vars) != 2:
				raise ValueError ('expression must have exactly two free variables')

			return args, __fxfy2fxy (sp.Lambda (vars, f [0]), sp.Lambda (vars, f [1])), False

		else:
			raise ValueError ('field must be specified by two lambdas or two expressions, not a mix')

	# one function or expression
	if not callable (f): # convert expression to function
		if len (f.free_symbols) != 2:
			raise ValueError ('expression must have exactly two free variables')

		f = sp.Lambda (tuple (sorted (f.free_symbols, key = lambda s: s.name)), f)

	for y in testy: # check if returns 1 dy or 2 u and v values
		for x in testx:
			try:
				v = f (x, y)
			except (ValueError, ZeroDivisionError, FloatingPointError):
				continue

			try:
				_, _ = v
				f    = __fxy2fxy (f)

				break

			except:
				f    = __fdy2fxy (f)
				isdy = True

				break

		else:
			continue

		break

	return args, f, isdy

_plotv_clr_mag  = lambda x, y, u, v: math.sqrt (u**2 + v**2)
_plotv_clr_dir  = lambda x, y, u, v: math.atan2 (v, u)

_plotv_clr_func = {'mag': _plotv_clr_mag, 'dir': _plotv_clr_dir}

#...............................................................................................
def plotv (*args, fs = None, res = 13, style = None, resw = 1, kww = {}, **kw):
	"""Plot vector field.

plotv (['+',] [limits,] func(s), [color,] [fmt,] [*walks,] fs = None, res = 13, style = None, resw = 1, kww = {}, **kw)

limits  = set absolute axis bounds: (default x is (0, 1), y is automatic)
  x              -> (-x, x, y auto)
  x0, x1         -> (x0, x1, y auto)
  x, y0, y1      -> (-x, x, y0, y1)
  x0, x1, y0, y1 -> (x0, x1, y0, y1)

fs      = set figure figsize if present: (default is (6.4, 4.8))
  x      -> (x, x / 6 * 4)
  -x     -> (x, x)
  (x, y) -> (x, y)

res     = (w, h) number of arrows across x and y dimensions, if single digit then h will be w*3/4
resw    = resolution for optional plotw, see plotw for meaning
kww     = optional keyword arguments to be passed to plotw if that is being called
style   = optional matplotlib plot style

func(s) = function or two functions or expressions returning either (u, v) or v/u
	f (x, y)               -> returning (u, v)
	f (x, y)               -> returning v/u will be interpreted without direction
	(f1 (x, y), f2 (x, y)) -> returning u and v respectively

color   = followed optionally by individual arrow color selection function (can not be expression)
	'mag'               -> color by magnitude of (u, v) vector
	'dir'               -> color by direction of (u, v) vector
  f (x, y, u, v)      -> relative scalar, will be scaled according to whole field to select color

fmt     = followed optionally by color and label format string '[#color][=label]'

*walks  = followed optionally by arguments to plotw for individual x, y walks and formatting
	"""

	if not _SPLOT:
		return None

	obj = plt

	args, xmin, xmax, ymin, ymax, kw = _process_head (obj, args, fs, style, ret_xrng = True, ret_yrng = True, kw = kw)

	if not isinstance (res, (sp.Tuple, tuple, list)):
		win = _FIGURE.axes [-1].get_window_extent ()
		res = (int (res), int ((win.y1 - win.y0) // ((win.x1 - win.x0) / (res + 1))))
	else:
		res = (int (res [0]), int (res [1]))

	xs = (xmax - xmin) / (res [0] + 1)
	ys = (ymax - ymin) / (res [1] + 1)
	x0 = xmin + xs / 2
	y0 = ymin + ys / 2
	xd = (xmax - xs / 2) - x0
	yd = (ymax - ys / 2) - y0
	X  = [[x0 + xd * i / (res [0] - 1)] * res [1] for i in range (res [0])]
	Y  = [y0 + yd * i / (res [1] - 1) for i in range (res [1])]
	Y  = [Y [:] for _ in range (res [0])]
	U  = [[0] * res [1] for _ in range (res [0])]
	V  = [[0] * res [1] for _ in range (res [0])]

	args, f, isdy = _process_funcxy (args, [x [0] for x in X], Y [0])

	if isdy:
		d, kw = kw, {'headwidth': 0, 'headlength': 0, 'headaxislength': 0, 'pivot': 'middle'}
		kw.update (d)

	# populate U and Vs from X, Y grid
	for j in range (res [1]):
		for i in range (res [0]):
			try:
				U [i] [j], V [i] [j] = f (X [i] [j], Y [i] [j])
			except (ValueError, ZeroDivisionError, FloatingPointError):
				U [i] [j] = V [i] [j] = 0

	clrf = None

	if args:
		if callable (args [-1]): # color function present? f (x, y, u, v)
			clrf = args.pop ()

		elif isinstance (args [-1], str): # pre-defined color function string?
			clrf = _plotv_clr_func.get (args [-1])

			if clrf:
				args.pop ()

	args, _, kw = _process_fmt (args, kw)

	if clrf:
		C = [[float (clrf (X [i] [j], Y [i] [j], U [i] [j], V [i] [j])) for j in range (res [1])] for i in range (res [0])]

		obj.quiver (X, Y, U, V, C, **kw)

	else:
		obj.quiver (X, Y, U, V, **kw)

	if 'label' in kw:
		obj.legend ()

	if args: # if arguments remain, pass them on to plotw to draw differential curves
		plotw (resw = resw, from_plotv = (args, xmin, xmax, ymin, ymax, f), **kww)

	return _figure_to_image ()

#...............................................................................................
def plotw (*args, fs = None, resw = 1, style = None, from_plotv = False, **kw):
	"""Plot walk(s) over vector field.

plotw (['+',] [limits,] func(s), *args, fs = None, resw = 1, style = None, **kw)

limits  = set absolute axis bounds: (default x is (0, 1), y is automatic)
  x              -> (-x, x, y auto)
  x0, x1         -> (x0, x1, y auto)
  x, y0, y1      -> (-x, x, y0, y1)
  x0, x1, y0, y1 -> (x0, x1, y0, y1)

fs      = set figure figsize if present: (default is (6.4, 4.8))
  x      -> (x, x / 6 * 4)
  -x     -> (x, x)
  (x, y) -> (x, y)

resw    = maximum pixel steps to allow walk step to deviate before drawing, smaller = better quality
style   = optional matplotlib plot style

func(s) = function or two functions returning either (u, v) or v/u
	f (x, y)            -> returning (u, v)
	f (x, y)            -> returning v/u will be interpreted without direction
	f (x, y), f2 (x, y) -> returning u and v respectively

*args   = followed by initial x, y points for walks (x, y, ['fmt',] [{kw},] x, y, ['fmt',] [{kw},] ...)
	fmt   = 'fmt[#color][=label]'

HACK: Python complex type used as 2D vector.
	"""

	def dot (p0, p1): # dot product of two 2d vectors stored as complexes
		return p0.real * p1.real + p0.imag * p1.imag

	def walk (x, y, f, o = 1): # returns [(x, y), (x, y), ...], True if looped else False
		def delta (p, d = None):
			try:
				t = math.atan2 (*(f (p.real, p.imag) [::-1]))

				return complex (math.cos (t), math.sin (t))

			except (ValueError, ZeroDivisionError, FloatingPointError):
				if d is not None:
					return d

			raise FloatingPointError

		xys = [(x, y)]
		err = 0
		p0  = complex (x, y)
		p   = p0
#		d   = pxs
		d   = delta (p, pxs)

		while 1:
#			d  = delta (p, d)
			s  = 0
			o2 = o
			p2 = p
			d2 = d

			while 1:
				st = 0.25 * pxm
				d3 = o2 * d2

				while 1:
					p3 = p2 + d3 * st # * pxm

					try:
						d4 = delta (p3)
						dc = math.acos (dot (d2, d4))

						if dc > 2.748893571891069: # (7 * pi / 8), abrupt reverse of direction?
							o2 = -o2

						elif dc > 0.005:
							st = st * (0.004 / dc)
							continue

						err = err + dc * st # * pxm
						d2  = d4

						break

					except FloatingPointError:
						break

				s      = s + st
				isloop = (dot (d3, p0 - p2) > 0) and abs (p3 - p0) < (2 * err) # (8 * pxm)
				p2     = p3

				if isloop or p2.real < xmin or p2.real > xmax or p2.imag < ymin or p2.imag > ymax:
					xys.extend ([(p2.real, p2.imag)] + [(x, y)] * bool (isloop))
					return xys, isloop

				if abs (p2 - (p + o * d * s)) >= resw: # * pxm)) >= resw:
					xys.append ((p2.real, p2.imag))

					o = o2
					p = p2
					d = d2

					break

	if not _SPLOT:
		return None

	obj = plt

	if from_plotv:
		args, xmin, xmax, ymin, ymax, f  = from_plotv
	else:
		args, xmin, xmax, ymin, ymax, kw = _process_head (obj, args, fs, style, ret_xrng = True, ret_yrng = True, kw = kw)
		args, f, _                       = _process_funcxy (args, [xmin + (xmax - xmin) * i / 4 for i in range (5)], [ymin + (ymax - ymin) * i / 4 for i in range (5)])

	win  = _FIGURE.axes [-1].get_window_extent ()
	pxs  = complex ((xmax - xmin) / (win.x1 - win.x0), (ymax - ymin) / (win.y1 - win.y0)) # pixel scale from xmin/max ymin/max scale
	pxm  = abs (pxs)
	resw = resw * pxm

	leg = False

	while args:
		x, y        = args.pop ()
		xys, isloop = walk (x, y, f)

		if not isloop:
			xys = xys [::-1] [:-1] + walk (x, y, f, -1) [0]

		args, fargs, kwf = _process_fmt (args, kw)
		leg              = leg or ('label' in kwf)

		obj.plot (*([[xy [0] for xy in xys], [xy [1] for xy in xys]] + fargs), **kwf)

	if leg or 'label' in kw:
		obj.legend ()

	return _figure_to_image ()

#...............................................................................................
class splot: # for single script
	plotf = plotf
	plotv = plotv
	plotw = plotw
#!/usr/bin/env python
# python 3.6+

# Server for web component and state machine for expressions.

import getopt
import io
import json
import os
import re
import subprocess
import sys
import time
import threading
import traceback
import webbrowser

from collections import OrderedDict
from http.server import HTTPServer, SimpleHTTPRequestHandler
from socketserver import ThreadingMixIn
from urllib.parse import parse_qs


_VERSION         = '1.0.6'

__OPTS, __ARGV   = getopt.getopt (sys.argv [1:], 'hvdnuEqysmltNOSgGz', ['child', 'firstrun',
	'help', 'version', 'debug', 'nobrowser', 'ugly', 'EI', 'quick', 'nopyS', 'nosimplify', 'nomatsimp',
	'noeval', 'nodoit', 'noN', 'noO', 'noS', 'nogamma', 'noGamma', 'nozeta'])

_SYMPAD_PATH     = os.path.dirname (sys.argv [0])
_SYMPAD_NAME     = os.path.basename (sys.argv [0])
_SYMPAD_CHILD    = ('--child', '') in __OPTS
_SYMPAD_FIRSTRUN = ('--firstrun', '') in __OPTS

_DEFAULT_ADDRESS = ('localhost', 9000)
_STATIC_FILES    = {'/style.css': 'css', '/script.js': 'javascript', '/index.html': 'html', '/help.html': 'html'}

__name_indent    = ' ' * (7 + len (_SYMPAD_NAME))
_HELP            = f'usage: {_SYMPAD_NAME} ' \
		'[-h | --help] [-v | --version] \n' \
		f'{__name_indent} [-d | --debug] [-n | --nobrowser] \n' \
		f'{__name_indent} [-u | --ugly] [-E | --EI] \n' \
		f'{__name_indent} [-q | --quick] [-y | --nopyS] \n' \
		f'{__name_indent} [-s | --nosimplify] [-m | -nomatsimp] \n' \
		f'{__name_indent} [-N | --noN] [-O | --noO] [-S | --noS] \n'\
		f'{__name_indent} [-g | --nogamma] [-G | --noGamma] \n' \
		f'{__name_indent} [-z | --nozeta] \n' \
		f'{__name_indent} [host:port | host | :port]' '''

  -h, --help       - This
  -v, --version    - Show version string
  -d, --debug      - Dump debug info to server output
  -n, --nobrowser  - Don't start system browser to SymPad page
  -u, --ugly       - Start in draft display style (only on command line)
  -E, --EI         - Start with SymPy constants 'E' and 'I' not 'e' and 'i'
  -q, --quick      - Start in quick input mode
  -y, --nopyS      - Start without Python S escaping
  -s, --nosimplify - Start without post-evaluation simplification
  -m, --nomatsimp  - Start without matrix simplification
  -N, --noN        - Start without N lambda function
  -S, --noS        - Start without S lambda function
  -O, --noO        - Start without O lambda function
  -g, --nogamma    - Start without gamma lambda function
  -G, --noGamma    - Start without Gamma lambda function
  -z, --nozeta     - Start without zeta lambda function
'''

if _SYMPAD_CHILD: # sympy slow to import so don't do it for watcher process as is unnecessary there


	_SYS_STDOUT   = sys.stdout
	_DISPLAYSTYLE = [1] # use "\displaystyle{}" formatting in MathJax
	_HISTORY      = []  # persistent history across browser closings

	_PARSER       = sparser.Parser ()
	_VAR_LAST     = '_' # name of last evaluated expression variable
	_START_ENV    = OrderedDict ([('EI', False), ('quick', False), ('pyS', True), ('simplify', True), ('matsimp', True),
		('eval', True), ('doit', True),('N', True), ('O', True), ('S', True), ('gamma', True), ('Gamma', True), ('zeta', True)])

	_ENV          = _START_ENV.copy () # This is individual session STATE! Threading can corrupt this! It is GLOBAL to survive multiple Handlers.
	_VARS         = {_VAR_LAST: AST.Zero} # This also!

	_ONE_FUNCS    = OrderedDict ([
		('N',     AST ('lamb', ('func', '$N', (('@', 'x'),)), (('@', 'x'),))),
		('O',     AST ('lamb', ('func', '$O', (('@', 'x'),)), (('@', 'x'),))),
		('S',     AST ('lamb', ('func', '$S', (('@', 'x'),)), (('@', 'x'),))),
		('gamma', AST ('lamb', ('func', '$gamma', (('@', 'z'),)), (('@', 'z'),))),
		('Gamma', AST ('lamb', ('func', '$gamma', (('@', 'z'),)), (('@', 'z'),))),
		('zeta',  AST ('lamb', ('func', '$zeta', (('@', 'z'),)), (('@', 'z'),))),
	])

#...............................................................................................
class RealityRedefinitionError (NameError):	pass
class CircularReferenceError (RecursionError): pass
class AE35UnitError (Exception): pass

def _ast_remap (ast, map_, recurse = True):
	if not isinstance (ast, AST) or ast.is_lamb or (ast.is_func and ast.func == AST.Func.NOREMAP): # non-AST, lambda definition or stop remap
		return ast

	elif ast.is_var:
		var = map_.get (ast.var)

		if var: # user var
			return var if var.is_lamb or not recurse else _ast_remap (var, map_)

	elif ast.is_func:
		lamb = map_.get (ast.func)

		if lamb and lamb.is_lamb: # 'execute' user lambda
			if len (ast.args) != len (lamb.vars):
				raise TypeError (f"lambda function '{ast.func}' takes {len (lamb.vars)} argument(s)")

			args = dict (zip ((v.var for v in lamb.vars), ast.args))

			return _ast_remap (_ast_remap (lamb.lamb, args, False), map_) # remap lambda vars to func args then global remap

		return AST ('func', ast.func, \
				tuple (('(', _ast_remap (a, map_, recurse)) \
				if (a.is_var and map_.get (a.var, AST.VarNull).is_ass) \
				else _ast_remap (a, map_, recurse) for a in ast.args)) # wrap var assignment args in parens to avoid creating kwargs

	return AST (*(_ast_remap (a, map_, recurse) for a in ast))

def _update_vars ():
	one_funcs  = dict (fa for fa in filter (lambda fa: _ENV.get (fa [0]), _ONE_FUNCS.items ()))
	user_funcs = dict (va for va in filter (lambda va: va [1].is_lamb and va [0] != _VAR_LAST, _VARS.items ()))

	user_funcs.update (one_funcs)

	sym.set_user_funcs (user_funcs)
	_PARSER.set_user_funcs (user_funcs)

def _prepare_ass (ast): # check and prepare for simple or tuple assignment
	vars = None

	if ast.is_ass:
		if ast.lhs.is_var: # simple assignment?
			ast, vars = ast.rhs, [ast.lhs.var]

	elif ast.is_comma: # tuple assignment? ('x, y = y, x' comes from parser as ('x', 'y = y', 'x')) so restructure
		lhss = []
		itr  = iter (ast.comma)

		for c in itr:
			if c.is_var:
				lhss.append (c.var)
			elif not c.is_ass or not c.lhs.is_var:
				break

			else:
				t    = (c.rhs,) + tuple (itr)
				ast  = t [0] if len (t) == 1 else AST (',', t)
				vars = lhss + [c.lhs.var]

	if vars:
		for var in vars: # trying to change a fundemental law of the universe?
			if AST ('@', var) in AST.CONSTS:
				raise RealityRedefinitionError ('The only thing that is constant is change - Heraclitus, except for constants...')

	return _ast_remap (ast, _VARS), vars

def _execute_ass (ast, vars): # execute assignment if it was detected
	def _set_vars (vars):
		try: # check for circular references
			_ast_remap (AST (',', tuple (('@', v) for v in vars)), {**_VARS, **vars})
		except RecursionError:
			raise CircularReferenceError ("I'm sorry, Dave. I'm afraid I can't do that.") from None

		_VARS.update (vars)

	if not vars: # no assignment
		_VARS [_VAR_LAST] = ast

		return [ast]

	if len (vars) == 1: # simple assignment
		_set_vars ({vars [0]: ast})

		asts = [AST ('=', '=', ('@', vars [0]), ast)]

	else: # tuple assignment
		ast  = ast.strip_paren ()
		asts = ast.comma if ast.is_comma else tuple (sym.spt2ast (a) for a in sym.ast2spt (ast))

		if len (vars) < len (asts):
			raise ValueError (f'too many values to unpack (expected {len (vars)})')
		elif len (vars) > len (asts):
			raise ValueError (f'not enough values to unpack (expected {len (vars)}, got {len (asts)})')

		_set_vars (dict (zip (vars, asts)))

		asts = [AST ('=', '=', ('@', vars [i]), asts [i]) for i in range (len (vars))]

	_update_vars ()

	return asts

def _admin_vars (*args):
	asts = []

	for v, e in sorted (_VARS.items ()):
		if v != _VAR_LAST and not e.is_lamb:
			asts.append (AST ('=', '=', ('@', v), e))

	if not asts:
		return 'No variables defined.'

	return asts

def _admin_funcs (*args):
	asts = []

	for v, e in sorted (_VARS.items ()):
		if v != _VAR_LAST and e.is_lamb:
			asts.append (AST ('=', '=', ('@', v), e))

	if not asts:
		return 'No functions defined.'

	return asts

def _admin_del (*args):
	vars = OrderedDict ()
	msgs = []

	for arg in args:
		if arg.is_func_vars: # delete all vars?
			vars.update (filter (lambda va: not va [1].is_lamb and va [0] != _VAR_LAST, _VARS.items ()))
		elif arg.is_func_funcs: # delete all funcs?
			vars.update (filter (lambda va: va [1].is_lamb, _VARS.items ()))

		else:
			var = arg.as_identifier ()

			if var is None:
				raise TypeError (f'invalid argument {sym.ast2nat (arg)!r}')

			vars [var] = _VARS.get (var)

			if vars [var] is None:
				raise AE35UnitError (f'Variable {var!r} is not defined, it can only be attributable to human error.')

	for var, ast in vars.items ():
		msgs.append (f'{"Function" if ast.is_lamb else "Variable"} {var!r} deleted.')

		del _VARS [var]

	_update_vars ()

	if not msgs:
		msgs.append ('No variables specified!')

	return msgs

def _admin_delall (*args):
	last_var = _VARS [_VAR_LAST]

	_VARS.clear ()
	_update_vars ()

	_VARS [_VAR_LAST] = last_var

	return 'All assignments deleted.'

def _admin_env (*args):
	def _envop (env, apply):
		msgs = []

		for var, state in env.items ():
			if apply:
				_ENV [var] = state

			if var == 'EI':
				msgs.append (f'Uppercase E and I is {"on" if state else "off"}.')

				if apply:
					AST.EI (state)

					for var in (AST.E.var, AST.I.var):
						if var in _VARS:
							del _VARS [var]

			elif var == 'quick':
				msgs.append (f'Quick input mode is {"on" if state else "off"}.')

				if apply:
					_PARSER.set_quick (state)

			elif var == 'pyS':
				msgs.append (f'Python S escaping {"on" if state else "off"}.')

				if apply:
					sym.set_pyS (state)

			elif var == 'simplify':
				msgs.append (f'Post-evaluation simplify is {"on" if state else "off"}.')

				if apply:
					sym.set_simplify (state)

			elif var == 'matsimp':
				msgs.append (f'Matrix simplify is {"broken" if not spatch.SPATCHED else "on" if state else "off"}.')

				if apply:
					spatch.set_matmulsimp (state)

			elif var == 'eval':
				msgs.append (f'Expression evaluation is {"on" if state else "off"}.')

				if apply:
					sym.set_eval (state)

			elif var == 'doit':
				msgs.append (f'Expression doit is {"on" if state else "off"}.')

				if apply:
					sym.set_doit (state)

			elif var in _ONE_FUNCS:
				msgs.append (f'Function {var} is {"on" if state else "off"}.')

				if apply:
					_update_vars ()

		return msgs

	# start here
	if not args:
		return _envop (_ENV, False)

	env = OrderedDict ()

	for arg in args:
		if arg.is_ass:
			var = arg.lhs.as_identifier ()

			if var:
				state = bool (sym.ast2spt (arg.rhs))

		else:
			var = arg.as_identifier ()

			if var:
				if var [:2] == 'no':
					var, state = var [2:], False
				else:
					state = True

		if var is None:
			raise TypeError (f'invalid argument {sym.ast2nat (arg)!r}')
		elif var not in {'EI', 'quick', 'pyS', 'simplify', 'matsimp', 'eval', 'doit', *_ONE_FUNCS}:
			raise NameError (f'invalid environment setting {var!r}')

		env [var] = state

	return _envop (env, True)

def _admin_envreset (*args):
	return ['Environment has been reset.'] + _admin_env (*(AST ('@', var if state else f'no{var}') for var, state in _START_ENV.items ()))

#...............................................................................................
class Handler (SimpleHTTPRequestHandler):
	def do_GET (self):
		if self.path == '/':
			self.path = '/index.html'

		fnm = os.path.join (_SYMPAD_PATH, self.path.lstrip ('/'))

		if self.path != '/env.js' and (self.path not in _STATIC_FILES or (not _RUNNING_AS_SINGLE_SCRIPT and not os.path.isfile (fnm))):
			self.send_error (404, f'Invalid path {self.path!r}')

		else:
			self.send_response (200)

			if self.path == '/env.js':
				content = 'text/javascript'
				data    = f'History = {_HISTORY}\nHistIdx = {len (_HISTORY)}\nVersion = {"v" + _VERSION!r}\nDisplayStyle = {_DISPLAYSTYLE [0]}'.encode ('utf8')

				self.send_header ('Cache-Control', 'no-store')

			else:
				content = _STATIC_FILES [self.path]

				if _RUNNING_AS_SINGLE_SCRIPT:
					data = _FILES [self.path [1:]]
				else:
					data = open (fnm, 'rb').read ()

			self.send_header ('Content-type', f'text/{content}')
			self.end_headers ()
			self.wfile.write (data)

	def do_POST (self):
		request = parse_qs (self.rfile.read (int (self.headers ['Content-Length'])).decode ('utf8'), keep_blank_values = True)

		for key, val in list (request.items ()):
			if isinstance (val, list) and len (val) == 1:
				request [key] = val [0]

		if request ['mode'] == 'validate':
			response = self.validate (request)
		else: # request ['mode'] == 'evaluate':
			response = self.evaluate (request)

		response ['mode'] = request ['mode']
		response ['idx']  = request ['idx']
		response ['text'] = request ['text']

		self.send_response (200)
		self.send_header ('Content-type', 'application/json')
		self.send_header ('Cache-Control', 'no-store')
		self.end_headers ()
		self.wfile.write (json.dumps (response).encode ('utf8'))
		# self.wfile.write (json.dumps ({**request, **response}).encode ('utf8'))

	def validate (self, request):
		ast, erridx, autocomplete = _PARSER.parse (request ['text'])
		tex = nat = py            = None

		if ast is not None:
			tex = sym.ast2tex (ast)
			nat = sym.ast2nat (ast)
			py  = sym.ast2py (ast)

			if os.environ.get ('SYMPAD_DEBUG'):
				print ('ast:', ast, file = sys.stderr)
				print ('tex:', tex, file = sys.stderr)
				print ('nat:', nat, file = sys.stderr)
				print ('py: ', py, file = sys.stderr)
				print (file = sys.stderr)

		return {
			'tex'         : tex,
			'nat'         : nat,
			'py'          : py,
			'erridx'      : erridx,
			'autocomplete': autocomplete,
		}

	def evaluate (self, request):
		try:
			_HISTORY.append (request ['text'])

			sys.stdout = io.StringIO ()
			ast, _, _  = _PARSER.parse (request ['text'])

			if ast.is_func and ast.func in {'plotf', 'plotv', 'plotw'}: # plotting?
				args, kw = AST.args2kwargs (_ast_remap (ast.args, _VARS), sym.ast2spt)
				ret      = getattr (splot, ast.func) (*args, **kw)

				return {'msg': ['Plotting not available because matplotlib is not installed.']} if ret is None else {'img': ret}

			elif ast.is_func and ast.func in AST.Func.ADMIN: # special admin function?
				asts = globals () [f'_admin_{ast.func}'] (*ast.args)

				if isinstance (asts, str):
					return {'msg': [asts]}
				elif isinstance (asts, list) and isinstance (asts [0], str):
					return {'msg': asts}

			else: # not admin function, normal evaluation
				ast, vars = _prepare_ass (ast)

				sym.set_precision (ast)

				spt = sym.ast2spt (ast, _VARS)
				ast = sym.spt2ast (spt)

				if os.environ.get ('SYMPAD_DEBUG'):
					import sympy as sp

					print ('spt:        ', repr (spt), file = sys.stderr)
					print ('spt type:   ', type (spt), file = sys.stderr)
					print ('sympy latex:', sp.latex (spt), file = sys.stderr)
					print ('ast:        ', ast, file = sys.stderr)
					print (file = sys.stderr)

				asts = _execute_ass (ast, vars)

			response = {}

			if asts and asts [0] is not AST.None_:
				response.update ({'math': [{
					'tex': sym.ast2tex (ast),
					'nat': sym.ast2nat (ast),
					'py' : sym.ast2py (ast),
				} for ast in asts]})

			if sys.stdout.tell ():
				sys.stdout.seek (0)

				response ['msg'] = sys.stdout.read ().strip ().split ('\n')

			return response

		except Exception:
			return {'err': ''.join (traceback.format_exception (*sys.exc_info ())).strip ().split ('\n')}

		finally:
			sys.stdout = _SYS_STDOUT

#...............................................................................................
def start_server (logging = True):
	if not logging:
		Handler.log_message = lambda *args, **kwargs: None

	# _update_vars ()

	if ('--ugly', '') in __OPTS or ('-u', '') in __OPTS:
		_DISPLAYSTYLE [0] = 0

	# make sure all env options are initialized according to command line options
	for short, long in zip ('EqysmltNOSgGz', \
			['EI', 'quick', 'nopyS', 'nosimplify', 'nomatsimp', 'noeval', 'nodoit', 'noN', 'noO', 'noS', 'nogamma', 'noGamma', 'nozeta']):
		if (f'--{long}', '') in __OPTS or (f'-{short}', '') in __OPTS:
			_admin_env (AST ('@', long))
		else:
			_admin_env (AST ('@', long [2:] if long [:2] == 'no' else f'no{long}'))

	_START_ENV.update (_ENV)

	if not __ARGV:
		host, port = _DEFAULT_ADDRESS
	else:
		host, port = (re.split (r'(?<=\]):' if __ARGV [0].startswith ('[') else ':', __ARGV [0]) + [_DEFAULT_ADDRESS [1]]) [:2]
		host, port = host.strip ('[]'), int (port)

	try:
		httpd  = HTTPServer ((host, port), Handler)
		thread = threading.Thread (target = httpd.serve_forever, daemon = True)

		thread.start ()

		return httpd

	except OSError as e:
		if e.errno != 98:
			raise

		print (f'Port {port} seems to be in use, try specifying different port as a command line parameter, e.g. localhost:8001')

		sys.exit (-1)

_MONTH_NAME = (None, 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec')

def child ():
	httpd = start_server ()

	def log_message (msg):
		y, m, d, hh, mm, ss, _, _, _ = time.localtime (time.time ())

		sys.stderr.write (f'{httpd.server_address [0]} - - ' \
				f'[{"%02d/%3s/%04d %02d:%02d:%02d" % (d, _MONTH_NAME [m], y, hh, mm, ss)}] {msg}\n')

	fnms    = (_SYMPAD_NAME,) if _RUNNING_AS_SINGLE_SCRIPT else (_SYMPAD_NAME, 'splot.py', 'spatch.py', 'sparser.py', 'sym.py', 'sxlat.py', 'sast.py', 'lalr1.py')
	watch   = [os.path.join (_SYMPAD_PATH, fnm) for fnm in fnms]
	tstamps = [os.stat (fnm).st_mtime for fnm in watch]

	if _SYMPAD_FIRSTRUN:
		print ('Sympad server running. If a browser window does not automatically open to the address below then try navigating to that URL manually.\n')

	log_message (f'Serving at http://{httpd.server_address [0]}:{httpd.server_address [1]}/')

	if _SYMPAD_FIRSTRUN and ('--nobrowser', '') not in __OPTS and ('-n', '') not in __OPTS:
		webbrowser.open (f'http://{httpd.server_address [0] if httpd.server_address [0] != "0.0.0.0" else "127.0.0.1"}:{httpd.server_address [1]}')

	try:
		while 1:
			time.sleep (0.5)

			if [os.stat (fnm).st_mtime for fnm in watch] != tstamps:
				log_message ('Files changed, restarting...')
				sys.exit (0)

	except KeyboardInterrupt:
		sys.exit (0)

	sys.exit (-1)

def parent ():
	if ('--help', '') in __OPTS or ('-h', '') in __OPTS:
		print (_HELP.lstrip ())
		sys.exit (0)

	if ('--version', '') in __OPTS or ('-v', '') in __OPTS:
		print (_VERSION)
		sys.exit (0)

	args      = [sys.executable] + sys.argv + ['--child']
	first_run = ['--firstrun']

	try:
		while 1:
			ret       = subprocess.run (args + first_run)
			first_run = []

			if ret.returncode != 0 and not os.environ.get ('SYMPAD_DEBUG'):
				sys.exit (0)

	except KeyboardInterrupt:
		sys.exit (0)

#...............................................................................................
# if __name__ == '__main__' and not _RUNNING_AS_SINGLE_SCRIPT: # DEBUG!
# 	vars = {'f': AST ('lamb', ('@', 'x'), (('@', 'x'),)), 'g': AST ('lamb', ('func', 'f', (('@', 'x'),)), (('@', 'x'),))}
# 	ast = AST ('func', 'g', (('#', '1'),))
# 	res = _ast_remap (ast, vars)
# 	print (res)
# 	sys.exit (0)

if __name__ == '__main__':
	if ('--debug', '') in __OPTS or ('-d', '') in __OPTS:
		os.environ ['SYMPAD_DEBUG'] = '1'

	if _SYMPAD_CHILD:
		child ()
	else:
		parent ()
